// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_command.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_5fcommand_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_5fcommand_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
#include "geometry.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_5fcommand_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_5fcommand_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[31]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_5fcommand_2eproto;
namespace rocos {
class CntPerUnit;
struct CntPerUnitDefaultTypeInternal;
extern CntPerUnitDefaultTypeInternal _CntPerUnit_default_instance_;
class Disabled;
struct DisabledDefaultTypeInternal;
extern DisabledDefaultTypeInternal _Disabled_default_instance_;
class DraggingCommand;
struct DraggingCommandDefaultTypeInternal;
extern DraggingCommandDefaultTypeInternal _DraggingCommand_default_instance_;
class Enabled;
struct EnabledDefaultTypeInternal;
extern EnabledDefaultTypeInternal _Enabled_default_instance_;
class MotionCommand;
struct MotionCommandDefaultTypeInternal;
extern MotionCommandDefaultTypeInternal _MotionCommand_default_instance_;
class MoveC;
struct MoveCDefaultTypeInternal;
extern MoveCDefaultTypeInternal _MoveC_default_instance_;
class MoveJ;
struct MoveJDefaultTypeInternal;
extern MoveJDefaultTypeInternal _MoveJ_default_instance_;
class MoveJ_IK;
struct MoveJ_IKDefaultTypeInternal;
extern MoveJ_IKDefaultTypeInternal _MoveJ_IK_default_instance_;
class MoveL;
struct MoveLDefaultTypeInternal;
extern MoveLDefaultTypeInternal _MoveL_default_instance_;
class MoveL_FK;
struct MoveL_FKDefaultTypeInternal;
extern MoveL_FKDefaultTypeInternal _MoveL_FK_default_instance_;
class MoveP;
struct MovePDefaultTypeInternal;
extern MovePDefaultTypeInternal _MoveP_default_instance_;
class MovePath;
struct MovePathDefaultTypeInternal;
extern MovePathDefaultTypeInternal _MovePath_default_instance_;
class MultiAxisCommand;
struct MultiAxisCommandDefaultTypeInternal;
extern MultiAxisCommandDefaultTypeInternal _MultiAxisCommand_default_instance_;
class MultiAxisDisabled;
struct MultiAxisDisabledDefaultTypeInternal;
extern MultiAxisDisabledDefaultTypeInternal _MultiAxisDisabled_default_instance_;
class MultiAxisEnabled;
struct MultiAxisEnabledDefaultTypeInternal;
extern MultiAxisEnabledDefaultTypeInternal _MultiAxisEnabled_default_instance_;
class MultiAxisMode;
struct MultiAxisModeDefaultTypeInternal;
extern MultiAxisModeDefaultTypeInternal _MultiAxisMode_default_instance_;
class MultiAxisMove;
struct MultiAxisMoveDefaultTypeInternal;
extern MultiAxisMoveDefaultTypeInternal _MultiAxisMove_default_instance_;
class MultiAxisStop;
struct MultiAxisStopDefaultTypeInternal;
extern MultiAxisStopDefaultTypeInternal _MultiAxisStop_default_instance_;
class MultiAxisSync;
struct MultiAxisSyncDefaultTypeInternal;
extern MultiAxisSyncDefaultTypeInternal _MultiAxisSync_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Path_PathEntry;
struct Path_PathEntryDefaultTypeInternal;
extern Path_PathEntryDefaultTypeInternal _Path_PathEntry_default_instance_;
class RobotCommand;
struct RobotCommandDefaultTypeInternal;
extern RobotCommandDefaultTypeInternal _RobotCommand_default_instance_;
class RobotCommandRequest;
struct RobotCommandRequestDefaultTypeInternal;
extern RobotCommandRequestDefaultTypeInternal _RobotCommandRequest_default_instance_;
class RobotCommandResponse;
struct RobotCommandResponseDefaultTypeInternal;
extern RobotCommandResponseDefaultTypeInternal _RobotCommandResponse_default_instance_;
class SingleAxisCommand;
struct SingleAxisCommandDefaultTypeInternal;
extern SingleAxisCommandDefaultTypeInternal _SingleAxisCommand_default_instance_;
class SingleAxisDisabled;
struct SingleAxisDisabledDefaultTypeInternal;
extern SingleAxisDisabledDefaultTypeInternal _SingleAxisDisabled_default_instance_;
class SingleAxisEnabled;
struct SingleAxisEnabledDefaultTypeInternal;
extern SingleAxisEnabledDefaultTypeInternal _SingleAxisEnabled_default_instance_;
class SingleAxisMode;
struct SingleAxisModeDefaultTypeInternal;
extern SingleAxisModeDefaultTypeInternal _SingleAxisMode_default_instance_;
class SingleAxisMove;
struct SingleAxisMoveDefaultTypeInternal;
extern SingleAxisMoveDefaultTypeInternal _SingleAxisMove_default_instance_;
class SingleAxisStop;
struct SingleAxisStopDefaultTypeInternal;
extern SingleAxisStopDefaultTypeInternal _SingleAxisStop_default_instance_;
class ZeroOffset;
struct ZeroOffsetDefaultTypeInternal;
extern ZeroOffsetDefaultTypeInternal _ZeroOffset_default_instance_;
}  // namespace rocos
PROTOBUF_NAMESPACE_OPEN
template<> ::rocos::CntPerUnit* Arena::CreateMaybeMessage<::rocos::CntPerUnit>(Arena*);
template<> ::rocos::Disabled* Arena::CreateMaybeMessage<::rocos::Disabled>(Arena*);
template<> ::rocos::DraggingCommand* Arena::CreateMaybeMessage<::rocos::DraggingCommand>(Arena*);
template<> ::rocos::Enabled* Arena::CreateMaybeMessage<::rocos::Enabled>(Arena*);
template<> ::rocos::MotionCommand* Arena::CreateMaybeMessage<::rocos::MotionCommand>(Arena*);
template<> ::rocos::MoveC* Arena::CreateMaybeMessage<::rocos::MoveC>(Arena*);
template<> ::rocos::MoveJ* Arena::CreateMaybeMessage<::rocos::MoveJ>(Arena*);
template<> ::rocos::MoveJ_IK* Arena::CreateMaybeMessage<::rocos::MoveJ_IK>(Arena*);
template<> ::rocos::MoveL* Arena::CreateMaybeMessage<::rocos::MoveL>(Arena*);
template<> ::rocos::MoveL_FK* Arena::CreateMaybeMessage<::rocos::MoveL_FK>(Arena*);
template<> ::rocos::MoveP* Arena::CreateMaybeMessage<::rocos::MoveP>(Arena*);
template<> ::rocos::MovePath* Arena::CreateMaybeMessage<::rocos::MovePath>(Arena*);
template<> ::rocos::MultiAxisCommand* Arena::CreateMaybeMessage<::rocos::MultiAxisCommand>(Arena*);
template<> ::rocos::MultiAxisDisabled* Arena::CreateMaybeMessage<::rocos::MultiAxisDisabled>(Arena*);
template<> ::rocos::MultiAxisEnabled* Arena::CreateMaybeMessage<::rocos::MultiAxisEnabled>(Arena*);
template<> ::rocos::MultiAxisMode* Arena::CreateMaybeMessage<::rocos::MultiAxisMode>(Arena*);
template<> ::rocos::MultiAxisMove* Arena::CreateMaybeMessage<::rocos::MultiAxisMove>(Arena*);
template<> ::rocos::MultiAxisStop* Arena::CreateMaybeMessage<::rocos::MultiAxisStop>(Arena*);
template<> ::rocos::MultiAxisSync* Arena::CreateMaybeMessage<::rocos::MultiAxisSync>(Arena*);
template<> ::rocos::Path* Arena::CreateMaybeMessage<::rocos::Path>(Arena*);
template<> ::rocos::Path_PathEntry* Arena::CreateMaybeMessage<::rocos::Path_PathEntry>(Arena*);
template<> ::rocos::RobotCommand* Arena::CreateMaybeMessage<::rocos::RobotCommand>(Arena*);
template<> ::rocos::RobotCommandRequest* Arena::CreateMaybeMessage<::rocos::RobotCommandRequest>(Arena*);
template<> ::rocos::RobotCommandResponse* Arena::CreateMaybeMessage<::rocos::RobotCommandResponse>(Arena*);
template<> ::rocos::SingleAxisCommand* Arena::CreateMaybeMessage<::rocos::SingleAxisCommand>(Arena*);
template<> ::rocos::SingleAxisDisabled* Arena::CreateMaybeMessage<::rocos::SingleAxisDisabled>(Arena*);
template<> ::rocos::SingleAxisEnabled* Arena::CreateMaybeMessage<::rocos::SingleAxisEnabled>(Arena*);
template<> ::rocos::SingleAxisMode* Arena::CreateMaybeMessage<::rocos::SingleAxisMode>(Arena*);
template<> ::rocos::SingleAxisMove* Arena::CreateMaybeMessage<::rocos::SingleAxisMove>(Arena*);
template<> ::rocos::SingleAxisStop* Arena::CreateMaybeMessage<::rocos::SingleAxisStop>(Arena*);
template<> ::rocos::ZeroOffset* Arena::CreateMaybeMessage<::rocos::ZeroOffset>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rocos {

enum MoveC_OrientationMode : int {
  MoveC_OrientationMode_UNCONSTRAINED = 0,
  MoveC_OrientationMode_FIXED = 1,
  MoveC_OrientationMode_MoveC_OrientationMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MoveC_OrientationMode_MoveC_OrientationMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MoveC_OrientationMode_IsValid(int value);
constexpr MoveC_OrientationMode MoveC_OrientationMode_OrientationMode_MIN = MoveC_OrientationMode_UNCONSTRAINED;
constexpr MoveC_OrientationMode MoveC_OrientationMode_OrientationMode_MAX = MoveC_OrientationMode_FIXED;
constexpr int MoveC_OrientationMode_OrientationMode_ARRAYSIZE = MoveC_OrientationMode_OrientationMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveC_OrientationMode_descriptor();
template<typename T>
inline const std::string& MoveC_OrientationMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveC_OrientationMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveC_OrientationMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveC_OrientationMode_descriptor(), enum_t_value);
}
inline bool MoveC_OrientationMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveC_OrientationMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveC_OrientationMode>(
    MoveC_OrientationMode_descriptor(), name, value);
}
enum Path_PathEntry_MoveType : int {
  Path_PathEntry_MoveType_MOVE_J = 0,
  Path_PathEntry_MoveType_MOVE_L = 1,
  Path_PathEntry_MoveType_MOVE_P = 2,
  Path_PathEntry_MoveType_MOVE_C = 3,
  Path_PathEntry_MoveType_Path_PathEntry_MoveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Path_PathEntry_MoveType_Path_PathEntry_MoveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Path_PathEntry_MoveType_IsValid(int value);
constexpr Path_PathEntry_MoveType Path_PathEntry_MoveType_MoveType_MIN = Path_PathEntry_MoveType_MOVE_J;
constexpr Path_PathEntry_MoveType Path_PathEntry_MoveType_MoveType_MAX = Path_PathEntry_MoveType_MOVE_C;
constexpr int Path_PathEntry_MoveType_MoveType_ARRAYSIZE = Path_PathEntry_MoveType_MoveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Path_PathEntry_MoveType_descriptor();
template<typename T>
inline const std::string& Path_PathEntry_MoveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Path_PathEntry_MoveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Path_PathEntry_MoveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Path_PathEntry_MoveType_descriptor(), enum_t_value);
}
inline bool Path_PathEntry_MoveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Path_PathEntry_MoveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Path_PathEntry_MoveType>(
    Path_PathEntry_MoveType_descriptor(), name, value);
}
enum Synchronization : int {
  SYNC_NONE = 0,
  SYNC_TIME = 1,
  SYNC_PHASE = 2,
  Synchronization_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Synchronization_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Synchronization_IsValid(int value);
constexpr Synchronization Synchronization_MIN = SYNC_NONE;
constexpr Synchronization Synchronization_MAX = SYNC_PHASE;
constexpr int Synchronization_ARRAYSIZE = Synchronization_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Synchronization_descriptor();
template<typename T>
inline const std::string& Synchronization_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Synchronization>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Synchronization_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Synchronization_descriptor(), enum_t_value);
}
inline bool Synchronization_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Synchronization* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Synchronization>(
    Synchronization_descriptor(), name, value);
}
enum Mode : int {
  MODE_CSP = 0,
  MODE_CSV = 1,
  MODE_CST = 2,
  Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Mode_IsValid(int value);
constexpr Mode Mode_MIN = MODE_CSP;
constexpr Mode Mode_MAX = MODE_CST;
constexpr int Mode_ARRAYSIZE = Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Mode_descriptor();
template<typename T>
inline const std::string& Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Mode_descriptor(), enum_t_value);
}
inline bool Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Mode>(
    Mode_descriptor(), name, value);
}
enum DraggingFlag : int {
  J0 = 0,
  J1 = 1,
  J2 = 2,
  J3 = 3,
  J4 = 4,
  J5 = 5,
  J6 = 6,
  TOOL_X = 100,
  TOOL_Y = 101,
  TOOL_Z = 102,
  TOOL_ROLL = 103,
  TOOL_PITCH = 104,
  TOOL_YAW = 105,
  FLANGE_X = 200,
  FLANGE_Y = 201,
  FLANGE_Z = 202,
  FLANGE_ROLL = 203,
  FLANGE_PITCH = 204,
  FLANGE_YAW = 205,
  OBJECT_X = 300,
  OBJECT_Y = 301,
  OBJECT_Z = 302,
  OBJECT_ROLL = 303,
  OBJECT_PITCH = 304,
  OBJECT_YAW = 305,
  BASE_X = 400,
  BASE_Y = 401,
  BASE_Z = 402,
  BASE_ROLL = 403,
  BASE_PITCH = 404,
  BASE_YAW = 405,
  DraggingFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DraggingFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DraggingFlag_IsValid(int value);
constexpr DraggingFlag DraggingFlag_MIN = J0;
constexpr DraggingFlag DraggingFlag_MAX = BASE_YAW;
constexpr int DraggingFlag_ARRAYSIZE = DraggingFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DraggingFlag_descriptor();
template<typename T>
inline const std::string& DraggingFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DraggingFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DraggingFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DraggingFlag_descriptor(), enum_t_value);
}
inline bool DraggingFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DraggingFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DraggingFlag>(
    DraggingFlag_descriptor(), name, value);
}
enum DraggingDirection : int {
  NONE = 0,
  POSITIVE = 1,
  NEGATIVE = -1,
  DraggingDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DraggingDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DraggingDirection_IsValid(int value);
constexpr DraggingDirection DraggingDirection_MIN = NEGATIVE;
constexpr DraggingDirection DraggingDirection_MAX = POSITIVE;
constexpr int DraggingDirection_ARRAYSIZE = DraggingDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DraggingDirection_descriptor();
template<typename T>
inline const std::string& DraggingDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DraggingDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DraggingDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DraggingDirection_descriptor(), enum_t_value);
}
inline bool DraggingDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DraggingDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DraggingDirection>(
    DraggingDirection_descriptor(), name, value);
}
// ===================================================================

class SingleAxisEnabled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SingleAxisEnabled) */ {
 public:
  inline SingleAxisEnabled() : SingleAxisEnabled(nullptr) {}
  ~SingleAxisEnabled() override;
  explicit constexpr SingleAxisEnabled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleAxisEnabled(const SingleAxisEnabled& from);
  SingleAxisEnabled(SingleAxisEnabled&& from) noexcept
    : SingleAxisEnabled() {
    *this = ::std::move(from);
  }

  inline SingleAxisEnabled& operator=(const SingleAxisEnabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleAxisEnabled& operator=(SingleAxisEnabled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleAxisEnabled& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleAxisEnabled* internal_default_instance() {
    return reinterpret_cast<const SingleAxisEnabled*>(
               &_SingleAxisEnabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SingleAxisEnabled& a, SingleAxisEnabled& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleAxisEnabled* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleAxisEnabled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleAxisEnabled* New() const final {
    return new SingleAxisEnabled();
  }

  SingleAxisEnabled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleAxisEnabled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleAxisEnabled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleAxisEnabled& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleAxisEnabled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SingleAxisEnabled";
  }
  protected:
  explicit SingleAxisEnabled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SingleAxisEnabled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SingleAxisDisabled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SingleAxisDisabled) */ {
 public:
  inline SingleAxisDisabled() : SingleAxisDisabled(nullptr) {}
  ~SingleAxisDisabled() override;
  explicit constexpr SingleAxisDisabled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleAxisDisabled(const SingleAxisDisabled& from);
  SingleAxisDisabled(SingleAxisDisabled&& from) noexcept
    : SingleAxisDisabled() {
    *this = ::std::move(from);
  }

  inline SingleAxisDisabled& operator=(const SingleAxisDisabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleAxisDisabled& operator=(SingleAxisDisabled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleAxisDisabled& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleAxisDisabled* internal_default_instance() {
    return reinterpret_cast<const SingleAxisDisabled*>(
               &_SingleAxisDisabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SingleAxisDisabled& a, SingleAxisDisabled& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleAxisDisabled* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleAxisDisabled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleAxisDisabled* New() const final {
    return new SingleAxisDisabled();
  }

  SingleAxisDisabled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleAxisDisabled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleAxisDisabled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleAxisDisabled& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleAxisDisabled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SingleAxisDisabled";
  }
  protected:
  explicit SingleAxisDisabled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SingleAxisDisabled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SingleAxisMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SingleAxisMode) */ {
 public:
  inline SingleAxisMode() : SingleAxisMode(nullptr) {}
  ~SingleAxisMode() override;
  explicit constexpr SingleAxisMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleAxisMode(const SingleAxisMode& from);
  SingleAxisMode(SingleAxisMode&& from) noexcept
    : SingleAxisMode() {
    *this = ::std::move(from);
  }

  inline SingleAxisMode& operator=(const SingleAxisMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleAxisMode& operator=(SingleAxisMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleAxisMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleAxisMode* internal_default_instance() {
    return reinterpret_cast<const SingleAxisMode*>(
               &_SingleAxisMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SingleAxisMode& a, SingleAxisMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleAxisMode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleAxisMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleAxisMode* New() const final {
    return new SingleAxisMode();
  }

  SingleAxisMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleAxisMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleAxisMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleAxisMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleAxisMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SingleAxisMode";
  }
  protected:
  explicit SingleAxisMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .rocos.Mode value = 2;
  void clear_value();
  ::rocos::Mode value() const;
  void set_value(::rocos::Mode value);
  private:
  ::rocos::Mode _internal_value() const;
  void _internal_set_value(::rocos::Mode value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SingleAxisMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SingleAxisMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SingleAxisMove) */ {
 public:
  inline SingleAxisMove() : SingleAxisMove(nullptr) {}
  ~SingleAxisMove() override;
  explicit constexpr SingleAxisMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleAxisMove(const SingleAxisMove& from);
  SingleAxisMove(SingleAxisMove&& from) noexcept
    : SingleAxisMove() {
    *this = ::std::move(from);
  }

  inline SingleAxisMove& operator=(const SingleAxisMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleAxisMove& operator=(SingleAxisMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleAxisMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleAxisMove* internal_default_instance() {
    return reinterpret_cast<const SingleAxisMove*>(
               &_SingleAxisMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SingleAxisMove& a, SingleAxisMove& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleAxisMove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleAxisMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleAxisMove* New() const final {
    return new SingleAxisMove();
  }

  SingleAxisMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleAxisMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleAxisMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleAxisMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleAxisMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SingleAxisMove";
  }
  protected:
  explicit SingleAxisMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kMaxVelFieldNumber = 3,
    kMaxAccFieldNumber = 4,
    kIdFieldNumber = 1,
    kRawDataFieldNumber = 7,
    kMaxJerkFieldNumber = 5,
    kLeastTimeFieldNumber = 6,
  };
  // double pos = 2;
  void clear_pos();
  double pos() const;
  void set_pos(double value);
  private:
  double _internal_pos() const;
  void _internal_set_pos(double value);
  public:

  // optional double max_vel = 3;
  bool has_max_vel() const;
  private:
  bool _internal_has_max_vel() const;
  public:
  void clear_max_vel();
  double max_vel() const;
  void set_max_vel(double value);
  private:
  double _internal_max_vel() const;
  void _internal_set_max_vel(double value);
  public:

  // optional double max_acc = 4;
  bool has_max_acc() const;
  private:
  bool _internal_has_max_acc() const;
  public:
  void clear_max_acc();
  double max_acc() const;
  void set_max_acc(double value);
  private:
  double _internal_max_acc() const;
  void _internal_set_max_acc(double value);
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool raw_data = 7;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  bool raw_data() const;
  void set_raw_data(bool value);
  private:
  bool _internal_raw_data() const;
  void _internal_set_raw_data(bool value);
  public:

  // optional double max_jerk = 5;
  bool has_max_jerk() const;
  private:
  bool _internal_has_max_jerk() const;
  public:
  void clear_max_jerk();
  double max_jerk() const;
  void set_max_jerk(double value);
  private:
  double _internal_max_jerk() const;
  void _internal_set_max_jerk(double value);
  public:

  // optional double least_time = 6;
  bool has_least_time() const;
  private:
  bool _internal_has_least_time() const;
  public:
  void clear_least_time();
  double least_time() const;
  void set_least_time(double value);
  private:
  double _internal_least_time() const;
  void _internal_set_least_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SingleAxisMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double pos_;
  double max_vel_;
  double max_acc_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  bool raw_data_;
  double max_jerk_;
  double least_time_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SingleAxisStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SingleAxisStop) */ {
 public:
  inline SingleAxisStop() : SingleAxisStop(nullptr) {}
  ~SingleAxisStop() override;
  explicit constexpr SingleAxisStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleAxisStop(const SingleAxisStop& from);
  SingleAxisStop(SingleAxisStop&& from) noexcept
    : SingleAxisStop() {
    *this = ::std::move(from);
  }

  inline SingleAxisStop& operator=(const SingleAxisStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleAxisStop& operator=(SingleAxisStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleAxisStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleAxisStop* internal_default_instance() {
    return reinterpret_cast<const SingleAxisStop*>(
               &_SingleAxisStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SingleAxisStop& a, SingleAxisStop& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleAxisStop* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleAxisStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleAxisStop* New() const final {
    return new SingleAxisStop();
  }

  SingleAxisStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleAxisStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleAxisStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleAxisStop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleAxisStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SingleAxisStop";
  }
  protected:
  explicit SingleAxisStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SingleAxisStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class SingleAxisCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SingleAxisCommand) */ {
 public:
  inline SingleAxisCommand() : SingleAxisCommand(nullptr) {}
  ~SingleAxisCommand() override;
  explicit constexpr SingleAxisCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleAxisCommand(const SingleAxisCommand& from);
  SingleAxisCommand(SingleAxisCommand&& from) noexcept
    : SingleAxisCommand() {
    *this = ::std::move(from);
  }

  inline SingleAxisCommand& operator=(const SingleAxisCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleAxisCommand& operator=(SingleAxisCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleAxisCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kEnabled = 1,
    kDisabled = 2,
    kMode = 3,
    kMove = 4,
    kStop = 5,
    COMMAND_NOT_SET = 0,
  };

  static inline const SingleAxisCommand* internal_default_instance() {
    return reinterpret_cast<const SingleAxisCommand*>(
               &_SingleAxisCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SingleAxisCommand& a, SingleAxisCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleAxisCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleAxisCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleAxisCommand* New() const final {
    return new SingleAxisCommand();
  }

  SingleAxisCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleAxisCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleAxisCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleAxisCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleAxisCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SingleAxisCommand";
  }
  protected:
  explicit SingleAxisCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kDisabledFieldNumber = 2,
    kModeFieldNumber = 3,
    kMoveFieldNumber = 4,
    kStopFieldNumber = 5,
  };
  // .rocos.SingleAxisEnabled enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  const ::rocos::SingleAxisEnabled& enabled() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SingleAxisEnabled* release_enabled();
  ::rocos::SingleAxisEnabled* mutable_enabled();
  void set_allocated_enabled(::rocos::SingleAxisEnabled* enabled);
  private:
  const ::rocos::SingleAxisEnabled& _internal_enabled() const;
  ::rocos::SingleAxisEnabled* _internal_mutable_enabled();
  public:
  void unsafe_arena_set_allocated_enabled(
      ::rocos::SingleAxisEnabled* enabled);
  ::rocos::SingleAxisEnabled* unsafe_arena_release_enabled();

  // .rocos.SingleAxisDisabled disabled = 2;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  const ::rocos::SingleAxisDisabled& disabled() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SingleAxisDisabled* release_disabled();
  ::rocos::SingleAxisDisabled* mutable_disabled();
  void set_allocated_disabled(::rocos::SingleAxisDisabled* disabled);
  private:
  const ::rocos::SingleAxisDisabled& _internal_disabled() const;
  ::rocos::SingleAxisDisabled* _internal_mutable_disabled();
  public:
  void unsafe_arena_set_allocated_disabled(
      ::rocos::SingleAxisDisabled* disabled);
  ::rocos::SingleAxisDisabled* unsafe_arena_release_disabled();

  // .rocos.SingleAxisMode mode = 3;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  const ::rocos::SingleAxisMode& mode() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SingleAxisMode* release_mode();
  ::rocos::SingleAxisMode* mutable_mode();
  void set_allocated_mode(::rocos::SingleAxisMode* mode);
  private:
  const ::rocos::SingleAxisMode& _internal_mode() const;
  ::rocos::SingleAxisMode* _internal_mutable_mode();
  public:
  void unsafe_arena_set_allocated_mode(
      ::rocos::SingleAxisMode* mode);
  ::rocos::SingleAxisMode* unsafe_arena_release_mode();

  // .rocos.SingleAxisMove move = 4;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::rocos::SingleAxisMove& move() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SingleAxisMove* release_move();
  ::rocos::SingleAxisMove* mutable_move();
  void set_allocated_move(::rocos::SingleAxisMove* move);
  private:
  const ::rocos::SingleAxisMove& _internal_move() const;
  ::rocos::SingleAxisMove* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::rocos::SingleAxisMove* move);
  ::rocos::SingleAxisMove* unsafe_arena_release_move();

  // .rocos.SingleAxisStop stop = 5;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::rocos::SingleAxisStop& stop() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SingleAxisStop* release_stop();
  ::rocos::SingleAxisStop* mutable_stop();
  void set_allocated_stop(::rocos::SingleAxisStop* stop);
  private:
  const ::rocos::SingleAxisStop& _internal_stop() const;
  ::rocos::SingleAxisStop* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::rocos::SingleAxisStop* stop);
  ::rocos::SingleAxisStop* unsafe_arena_release_stop();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:rocos.SingleAxisCommand)
 private:
  class _Internal;
  void set_has_enabled();
  void set_has_disabled();
  void set_has_mode();
  void set_has_move();
  void set_has_stop();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::SingleAxisEnabled* enabled_;
    ::rocos::SingleAxisDisabled* disabled_;
    ::rocos::SingleAxisMode* mode_;
    ::rocos::SingleAxisMove* move_;
    ::rocos::SingleAxisStop* stop_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisEnabled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisEnabled) */ {
 public:
  inline MultiAxisEnabled() : MultiAxisEnabled(nullptr) {}
  ~MultiAxisEnabled() override;
  explicit constexpr MultiAxisEnabled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisEnabled(const MultiAxisEnabled& from);
  MultiAxisEnabled(MultiAxisEnabled&& from) noexcept
    : MultiAxisEnabled() {
    *this = ::std::move(from);
  }

  inline MultiAxisEnabled& operator=(const MultiAxisEnabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisEnabled& operator=(MultiAxisEnabled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisEnabled& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiAxisEnabled* internal_default_instance() {
    return reinterpret_cast<const MultiAxisEnabled*>(
               &_MultiAxisEnabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MultiAxisEnabled& a, MultiAxisEnabled& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisEnabled* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisEnabled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisEnabled* New() const final {
    return new MultiAxisEnabled();
  }

  MultiAxisEnabled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisEnabled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisEnabled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisEnabled& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisEnabled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisEnabled";
  }
  protected:
  explicit MultiAxisEnabled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rocos.MultiAxisEnabled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisDisabled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisDisabled) */ {
 public:
  inline MultiAxisDisabled() : MultiAxisDisabled(nullptr) {}
  ~MultiAxisDisabled() override;
  explicit constexpr MultiAxisDisabled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisDisabled(const MultiAxisDisabled& from);
  MultiAxisDisabled(MultiAxisDisabled&& from) noexcept
    : MultiAxisDisabled() {
    *this = ::std::move(from);
  }

  inline MultiAxisDisabled& operator=(const MultiAxisDisabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisDisabled& operator=(MultiAxisDisabled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisDisabled& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiAxisDisabled* internal_default_instance() {
    return reinterpret_cast<const MultiAxisDisabled*>(
               &_MultiAxisDisabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MultiAxisDisabled& a, MultiAxisDisabled& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisDisabled* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisDisabled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisDisabled* New() const final {
    return new MultiAxisDisabled();
  }

  MultiAxisDisabled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisDisabled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisDisabled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisDisabled& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisDisabled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisDisabled";
  }
  protected:
  explicit MultiAxisDisabled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rocos.MultiAxisDisabled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisMode) */ {
 public:
  inline MultiAxisMode() : MultiAxisMode(nullptr) {}
  ~MultiAxisMode() override;
  explicit constexpr MultiAxisMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisMode(const MultiAxisMode& from);
  MultiAxisMode(MultiAxisMode&& from) noexcept
    : MultiAxisMode() {
    *this = ::std::move(from);
  }

  inline MultiAxisMode& operator=(const MultiAxisMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisMode& operator=(MultiAxisMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiAxisMode* internal_default_instance() {
    return reinterpret_cast<const MultiAxisMode*>(
               &_MultiAxisMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MultiAxisMode& a, MultiAxisMode& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisMode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisMode* New() const final {
    return new MultiAxisMode();
  }

  MultiAxisMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisMode";
  }
  protected:
  explicit MultiAxisMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .rocos.Mode value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  ::rocos::Mode _internal_value(int index) const;
  void _internal_add_value(::rocos::Mode value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_value();
  public:
  ::rocos::Mode value(int index) const;
  void set_value(int index, ::rocos::Mode value);
  void add_value(::rocos::Mode value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_value();

  // @@protoc_insertion_point(class_scope:rocos.MultiAxisMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> value_;
  mutable std::atomic<int> _value_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisSync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisSync) */ {
 public:
  inline MultiAxisSync() : MultiAxisSync(nullptr) {}
  ~MultiAxisSync() override;
  explicit constexpr MultiAxisSync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisSync(const MultiAxisSync& from);
  MultiAxisSync(MultiAxisSync&& from) noexcept
    : MultiAxisSync() {
    *this = ::std::move(from);
  }

  inline MultiAxisSync& operator=(const MultiAxisSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisSync& operator=(MultiAxisSync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisSync& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiAxisSync* internal_default_instance() {
    return reinterpret_cast<const MultiAxisSync*>(
               &_MultiAxisSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MultiAxisSync& a, MultiAxisSync& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisSync* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisSync* New() const final {
    return new MultiAxisSync();
  }

  MultiAxisSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisSync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisSync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisSync& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisSync* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisSync";
  }
  protected:
  explicit MultiAxisSync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .rocos.Synchronization value = 1;
  void clear_value();
  ::rocos::Synchronization value() const;
  void set_value(::rocos::Synchronization value);
  private:
  ::rocos::Synchronization _internal_value() const;
  void _internal_set_value(::rocos::Synchronization value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MultiAxisSync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisMove) */ {
 public:
  inline MultiAxisMove() : MultiAxisMove(nullptr) {}
  ~MultiAxisMove() override;
  explicit constexpr MultiAxisMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisMove(const MultiAxisMove& from);
  MultiAxisMove(MultiAxisMove&& from) noexcept
    : MultiAxisMove() {
    *this = ::std::move(from);
  }

  inline MultiAxisMove& operator=(const MultiAxisMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisMove& operator=(MultiAxisMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiAxisMove* internal_default_instance() {
    return reinterpret_cast<const MultiAxisMove*>(
               &_MultiAxisMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MultiAxisMove& a, MultiAxisMove& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisMove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisMove* New() const final {
    return new MultiAxisMove();
  }

  MultiAxisMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisMove";
  }
  protected:
  explicit MultiAxisMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPosFieldNumber = 1,
    kMaxVelFieldNumber = 3,
    kMaxAccFieldNumber = 4,
    kMaxJerkFieldNumber = 5,
    kLeastTimeFieldNumber = 6,
    kRawDataFieldNumber = 7,
    kSyncFieldNumber = 8,
  };
  // repeated double target_pos = 1;
  int target_pos_size() const;
  private:
  int _internal_target_pos_size() const;
  public:
  void clear_target_pos();
  private:
  double _internal_target_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_target_pos() const;
  void _internal_add_target_pos(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_target_pos();
  public:
  double target_pos(int index) const;
  void set_target_pos(int index, double value);
  void add_target_pos(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      target_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_target_pos();

  // repeated double max_vel = 3;
  int max_vel_size() const;
  private:
  int _internal_max_vel_size() const;
  public:
  void clear_max_vel();
  private:
  double _internal_max_vel(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_max_vel() const;
  void _internal_add_max_vel(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_max_vel();
  public:
  double max_vel(int index) const;
  void set_max_vel(int index, double value);
  void add_max_vel(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      max_vel() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_max_vel();

  // repeated double max_acc = 4;
  int max_acc_size() const;
  private:
  int _internal_max_acc_size() const;
  public:
  void clear_max_acc();
  private:
  double _internal_max_acc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_max_acc() const;
  void _internal_add_max_acc(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_max_acc();
  public:
  double max_acc(int index) const;
  void set_max_acc(int index, double value);
  void add_max_acc(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      max_acc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_max_acc();

  // repeated double max_jerk = 5;
  int max_jerk_size() const;
  private:
  int _internal_max_jerk_size() const;
  public:
  void clear_max_jerk();
  private:
  double _internal_max_jerk(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_max_jerk() const;
  void _internal_add_max_jerk(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_max_jerk();
  public:
  double max_jerk(int index) const;
  void set_max_jerk(int index, double value);
  void add_max_jerk(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      max_jerk() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_max_jerk();

  // optional double least_time = 6;
  bool has_least_time() const;
  private:
  bool _internal_has_least_time() const;
  public:
  void clear_least_time();
  double least_time() const;
  void set_least_time(double value);
  private:
  double _internal_least_time() const;
  void _internal_set_least_time(double value);
  public:

  // optional bool raw_data = 7;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  bool raw_data() const;
  void set_raw_data(bool value);
  private:
  bool _internal_raw_data() const;
  void _internal_set_raw_data(bool value);
  public:

  // optional .rocos.Synchronization sync = 8;
  bool has_sync() const;
  private:
  bool _internal_has_sync() const;
  public:
  void clear_sync();
  ::rocos::Synchronization sync() const;
  void set_sync(::rocos::Synchronization value);
  private:
  ::rocos::Synchronization _internal_sync() const;
  void _internal_set_sync(::rocos::Synchronization value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MultiAxisMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > target_pos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > max_vel_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > max_acc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > max_jerk_;
  double least_time_;
  bool raw_data_;
  int sync_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisStop) */ {
 public:
  inline MultiAxisStop() : MultiAxisStop(nullptr) {}
  ~MultiAxisStop() override;
  explicit constexpr MultiAxisStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisStop(const MultiAxisStop& from);
  MultiAxisStop(MultiAxisStop&& from) noexcept
    : MultiAxisStop() {
    *this = ::std::move(from);
  }

  inline MultiAxisStop& operator=(const MultiAxisStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisStop& operator=(MultiAxisStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiAxisStop* internal_default_instance() {
    return reinterpret_cast<const MultiAxisStop*>(
               &_MultiAxisStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MultiAxisStop& a, MultiAxisStop& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisStop* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisStop* New() const final {
    return new MultiAxisStop();
  }

  MultiAxisStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisStop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisStop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisStop";
  }
  protected:
  explicit MultiAxisStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rocos.MultiAxisStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MultiAxisCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MultiAxisCommand) */ {
 public:
  inline MultiAxisCommand() : MultiAxisCommand(nullptr) {}
  ~MultiAxisCommand() override;
  explicit constexpr MultiAxisCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiAxisCommand(const MultiAxisCommand& from);
  MultiAxisCommand(MultiAxisCommand&& from) noexcept
    : MultiAxisCommand() {
    *this = ::std::move(from);
  }

  inline MultiAxisCommand& operator=(const MultiAxisCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiAxisCommand& operator=(MultiAxisCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiAxisCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kEnabled = 1,
    kDisabled = 2,
    kMode = 3,
    kSync = 4,
    kMove = 5,
    kStop = 6,
    COMMAND_NOT_SET = 0,
  };

  static inline const MultiAxisCommand* internal_default_instance() {
    return reinterpret_cast<const MultiAxisCommand*>(
               &_MultiAxisCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MultiAxisCommand& a, MultiAxisCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiAxisCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiAxisCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiAxisCommand* New() const final {
    return new MultiAxisCommand();
  }

  MultiAxisCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiAxisCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiAxisCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiAxisCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiAxisCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MultiAxisCommand";
  }
  protected:
  explicit MultiAxisCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kDisabledFieldNumber = 2,
    kModeFieldNumber = 3,
    kSyncFieldNumber = 4,
    kMoveFieldNumber = 5,
    kStopFieldNumber = 6,
  };
  // .rocos.MultiAxisEnabled enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  const ::rocos::MultiAxisEnabled& enabled() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisEnabled* release_enabled();
  ::rocos::MultiAxisEnabled* mutable_enabled();
  void set_allocated_enabled(::rocos::MultiAxisEnabled* enabled);
  private:
  const ::rocos::MultiAxisEnabled& _internal_enabled() const;
  ::rocos::MultiAxisEnabled* _internal_mutable_enabled();
  public:
  void unsafe_arena_set_allocated_enabled(
      ::rocos::MultiAxisEnabled* enabled);
  ::rocos::MultiAxisEnabled* unsafe_arena_release_enabled();

  // .rocos.MultiAxisDisabled disabled = 2;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  const ::rocos::MultiAxisDisabled& disabled() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisDisabled* release_disabled();
  ::rocos::MultiAxisDisabled* mutable_disabled();
  void set_allocated_disabled(::rocos::MultiAxisDisabled* disabled);
  private:
  const ::rocos::MultiAxisDisabled& _internal_disabled() const;
  ::rocos::MultiAxisDisabled* _internal_mutable_disabled();
  public:
  void unsafe_arena_set_allocated_disabled(
      ::rocos::MultiAxisDisabled* disabled);
  ::rocos::MultiAxisDisabled* unsafe_arena_release_disabled();

  // .rocos.MultiAxisMode mode = 3;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  const ::rocos::MultiAxisMode& mode() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisMode* release_mode();
  ::rocos::MultiAxisMode* mutable_mode();
  void set_allocated_mode(::rocos::MultiAxisMode* mode);
  private:
  const ::rocos::MultiAxisMode& _internal_mode() const;
  ::rocos::MultiAxisMode* _internal_mutable_mode();
  public:
  void unsafe_arena_set_allocated_mode(
      ::rocos::MultiAxisMode* mode);
  ::rocos::MultiAxisMode* unsafe_arena_release_mode();

  // .rocos.MultiAxisSync sync = 4;
  bool has_sync() const;
  private:
  bool _internal_has_sync() const;
  public:
  void clear_sync();
  const ::rocos::MultiAxisSync& sync() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisSync* release_sync();
  ::rocos::MultiAxisSync* mutable_sync();
  void set_allocated_sync(::rocos::MultiAxisSync* sync);
  private:
  const ::rocos::MultiAxisSync& _internal_sync() const;
  ::rocos::MultiAxisSync* _internal_mutable_sync();
  public:
  void unsafe_arena_set_allocated_sync(
      ::rocos::MultiAxisSync* sync);
  ::rocos::MultiAxisSync* unsafe_arena_release_sync();

  // .rocos.MultiAxisMove move = 5;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::rocos::MultiAxisMove& move() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisMove* release_move();
  ::rocos::MultiAxisMove* mutable_move();
  void set_allocated_move(::rocos::MultiAxisMove* move);
  private:
  const ::rocos::MultiAxisMove& _internal_move() const;
  ::rocos::MultiAxisMove* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::rocos::MultiAxisMove* move);
  ::rocos::MultiAxisMove* unsafe_arena_release_move();

  // .rocos.MultiAxisStop stop = 6;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::rocos::MultiAxisStop& stop() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisStop* release_stop();
  ::rocos::MultiAxisStop* mutable_stop();
  void set_allocated_stop(::rocos::MultiAxisStop* stop);
  private:
  const ::rocos::MultiAxisStop& _internal_stop() const;
  ::rocos::MultiAxisStop* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::rocos::MultiAxisStop* stop);
  ::rocos::MultiAxisStop* unsafe_arena_release_stop();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:rocos.MultiAxisCommand)
 private:
  class _Internal;
  void set_has_enabled();
  void set_has_disabled();
  void set_has_mode();
  void set_has_sync();
  void set_has_move();
  void set_has_stop();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::MultiAxisEnabled* enabled_;
    ::rocos::MultiAxisDisabled* disabled_;
    ::rocos::MultiAxisMode* mode_;
    ::rocos::MultiAxisSync* sync_;
    ::rocos::MultiAxisMove* move_;
    ::rocos::MultiAxisStop* stop_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class Enabled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Enabled) */ {
 public:
  inline Enabled() : Enabled(nullptr) {}
  ~Enabled() override;
  explicit constexpr Enabled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Enabled(const Enabled& from);
  Enabled(Enabled&& from) noexcept
    : Enabled() {
    *this = ::std::move(from);
  }

  inline Enabled& operator=(const Enabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline Enabled& operator=(Enabled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Enabled& default_instance() {
    return *internal_default_instance();
  }
  static inline const Enabled* internal_default_instance() {
    return reinterpret_cast<const Enabled*>(
               &_Enabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Enabled& a, Enabled& b) {
    a.Swap(&b);
  }
  inline void Swap(Enabled* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Enabled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Enabled* New() const final {
    return new Enabled();
  }

  Enabled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Enabled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Enabled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Enabled& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enabled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Enabled";
  }
  protected:
  explicit Enabled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetPosFieldNumber = 1,
    kTargetVelFieldNumber = 2,
  };
  // repeated double target_pos = 1;
  int target_pos_size() const;
  private:
  int _internal_target_pos_size() const;
  public:
  void clear_target_pos();
  private:
  double _internal_target_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_target_pos() const;
  void _internal_add_target_pos(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_target_pos();
  public:
  double target_pos(int index) const;
  void set_target_pos(int index, double value);
  void add_target_pos(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      target_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_target_pos();

  // repeated double target_vel = 2;
  int target_vel_size() const;
  private:
  int _internal_target_vel_size() const;
  public:
  void clear_target_vel();
  private:
  double _internal_target_vel(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_target_vel() const;
  void _internal_add_target_vel(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_target_vel();
  public:
  double target_vel(int index) const;
  void set_target_vel(int index, double value);
  void add_target_vel(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      target_vel() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_target_vel();

  // @@protoc_insertion_point(class_scope:rocos.Enabled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > target_pos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > target_vel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class Disabled final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Disabled) */ {
 public:
  inline Disabled() : Disabled(nullptr) {}
  ~Disabled() override;
  explicit constexpr Disabled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Disabled(const Disabled& from);
  Disabled(Disabled&& from) noexcept
    : Disabled() {
    *this = ::std::move(from);
  }

  inline Disabled& operator=(const Disabled& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disabled& operator=(Disabled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disabled& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disabled* internal_default_instance() {
    return reinterpret_cast<const Disabled*>(
               &_Disabled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Disabled& a, Disabled& b) {
    a.Swap(&b);
  }
  inline void Swap(Disabled* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disabled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Disabled* New() const final {
    return new Disabled();
  }

  Disabled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Disabled>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Disabled& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Disabled& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Disabled* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Disabled";
  }
  protected:
  explicit Disabled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rocos.Disabled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ZeroOffset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.ZeroOffset) */ {
 public:
  inline ZeroOffset() : ZeroOffset(nullptr) {}
  ~ZeroOffset() override;
  explicit constexpr ZeroOffset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ZeroOffset(const ZeroOffset& from);
  ZeroOffset(ZeroOffset&& from) noexcept
    : ZeroOffset() {
    *this = ::std::move(from);
  }

  inline ZeroOffset& operator=(const ZeroOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZeroOffset& operator=(ZeroOffset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZeroOffset& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZeroOffset* internal_default_instance() {
    return reinterpret_cast<const ZeroOffset*>(
               &_ZeroOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ZeroOffset& a, ZeroOffset& b) {
    a.Swap(&b);
  }
  inline void Swap(ZeroOffset* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZeroOffset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ZeroOffset* New() const final {
    return new ZeroOffset();
  }

  ZeroOffset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ZeroOffset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ZeroOffset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ZeroOffset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ZeroOffset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.ZeroOffset";
  }
  protected:
  explicit ZeroOffset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .google.protobuf.Int32Value value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  PROTOBUF_NAMESPACE_ID::Int32Value* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Int32Value >*
      mutable_value();
  private:
  const PROTOBUF_NAMESPACE_ID::Int32Value& _internal_value(int index) const;
  PROTOBUF_NAMESPACE_ID::Int32Value* _internal_add_value();
  public:
  const PROTOBUF_NAMESPACE_ID::Int32Value& value(int index) const;
  PROTOBUF_NAMESPACE_ID::Int32Value* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Int32Value >&
      value() const;

  // @@protoc_insertion_point(class_scope:rocos.ZeroOffset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Int32Value > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class CntPerUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.CntPerUnit) */ {
 public:
  inline CntPerUnit() : CntPerUnit(nullptr) {}
  ~CntPerUnit() override;
  explicit constexpr CntPerUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CntPerUnit(const CntPerUnit& from);
  CntPerUnit(CntPerUnit&& from) noexcept
    : CntPerUnit() {
    *this = ::std::move(from);
  }

  inline CntPerUnit& operator=(const CntPerUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CntPerUnit& operator=(CntPerUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CntPerUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CntPerUnit* internal_default_instance() {
    return reinterpret_cast<const CntPerUnit*>(
               &_CntPerUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CntPerUnit& a, CntPerUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(CntPerUnit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CntPerUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CntPerUnit* New() const final {
    return new CntPerUnit();
  }

  CntPerUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CntPerUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CntPerUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CntPerUnit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CntPerUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.CntPerUnit";
  }
  protected:
  explicit CntPerUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .google.protobuf.DoubleValue value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::DoubleValue >*
      mutable_value();
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_value(int index) const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_add_value();
  public:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& value(int index) const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::DoubleValue >&
      value() const;

  // @@protoc_insertion_point(class_scope:rocos.CntPerUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::DoubleValue > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MoveJ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MoveJ) */ {
 public:
  inline MoveJ() : MoveJ(nullptr) {}
  ~MoveJ() override;
  explicit constexpr MoveJ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveJ(const MoveJ& from);
  MoveJ(MoveJ&& from) noexcept
    : MoveJ() {
    *this = ::std::move(from);
  }

  inline MoveJ& operator=(const MoveJ& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveJ& operator=(MoveJ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveJ& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveJ* internal_default_instance() {
    return reinterpret_cast<const MoveJ*>(
               &_MoveJ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MoveJ& a, MoveJ& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveJ* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveJ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveJ* New() const final {
    return new MoveJ();
  }

  MoveJ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveJ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveJ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveJ& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveJ* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MoveJ";
  }
  protected:
  explicit MoveJ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kAsynchronousFieldNumber = 6,
  };
  // .rocos.JointArray q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;
  public:
  void clear_q();
  const ::rocos::JointArray& q() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::JointArray* release_q();
  ::rocos::JointArray* mutable_q();
  void set_allocated_q(::rocos::JointArray* q);
  private:
  const ::rocos::JointArray& _internal_q() const;
  ::rocos::JointArray* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::rocos::JointArray* q);
  ::rocos::JointArray* unsafe_arena_release_q();

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acceleration = 3;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double time = 4;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // double radius = 5;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool asynchronous = 6;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MoveJ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::JointArray* q_;
  double speed_;
  double acceleration_;
  double time_;
  double radius_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MoveJ_IK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MoveJ_IK) */ {
 public:
  inline MoveJ_IK() : MoveJ_IK(nullptr) {}
  ~MoveJ_IK() override;
  explicit constexpr MoveJ_IK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveJ_IK(const MoveJ_IK& from);
  MoveJ_IK(MoveJ_IK&& from) noexcept
    : MoveJ_IK() {
    *this = ::std::move(from);
  }

  inline MoveJ_IK& operator=(const MoveJ_IK& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveJ_IK& operator=(MoveJ_IK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveJ_IK& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveJ_IK* internal_default_instance() {
    return reinterpret_cast<const MoveJ_IK*>(
               &_MoveJ_IK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MoveJ_IK& a, MoveJ_IK& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveJ_IK* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveJ_IK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveJ_IK* New() const final {
    return new MoveJ_IK();
  }

  MoveJ_IK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveJ_IK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveJ_IK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveJ_IK& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveJ_IK* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MoveJ_IK";
  }
  protected:
  explicit MoveJ_IK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kAsynchronousFieldNumber = 6,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acceleration = 3;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double time = 4;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // double radius = 5;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool asynchronous = 6;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MoveJ_IK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  double speed_;
  double acceleration_;
  double time_;
  double radius_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MoveL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MoveL) */ {
 public:
  inline MoveL() : MoveL(nullptr) {}
  ~MoveL() override;
  explicit constexpr MoveL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveL(const MoveL& from);
  MoveL(MoveL&& from) noexcept
    : MoveL() {
    *this = ::std::move(from);
  }

  inline MoveL& operator=(const MoveL& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveL& operator=(MoveL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveL& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveL* internal_default_instance() {
    return reinterpret_cast<const MoveL*>(
               &_MoveL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MoveL& a, MoveL& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveL* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveL* New() const final {
    return new MoveL();
  }

  MoveL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveL& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MoveL";
  }
  protected:
  explicit MoveL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kAsynchronousFieldNumber = 6,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acceleration = 3;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double time = 4;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // double radius = 5;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool asynchronous = 6;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MoveL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  double speed_;
  double acceleration_;
  double time_;
  double radius_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MoveL_FK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MoveL_FK) */ {
 public:
  inline MoveL_FK() : MoveL_FK(nullptr) {}
  ~MoveL_FK() override;
  explicit constexpr MoveL_FK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveL_FK(const MoveL_FK& from);
  MoveL_FK(MoveL_FK&& from) noexcept
    : MoveL_FK() {
    *this = ::std::move(from);
  }

  inline MoveL_FK& operator=(const MoveL_FK& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveL_FK& operator=(MoveL_FK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveL_FK& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveL_FK* internal_default_instance() {
    return reinterpret_cast<const MoveL_FK*>(
               &_MoveL_FK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MoveL_FK& a, MoveL_FK& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveL_FK* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveL_FK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveL_FK* New() const final {
    return new MoveL_FK();
  }

  MoveL_FK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveL_FK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveL_FK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveL_FK& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveL_FK* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MoveL_FK";
  }
  protected:
  explicit MoveL_FK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kAsynchronousFieldNumber = 6,
  };
  // .rocos.JointArray q = 1;
  bool has_q() const;
  private:
  bool _internal_has_q() const;
  public:
  void clear_q();
  const ::rocos::JointArray& q() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::JointArray* release_q();
  ::rocos::JointArray* mutable_q();
  void set_allocated_q(::rocos::JointArray* q);
  private:
  const ::rocos::JointArray& _internal_q() const;
  ::rocos::JointArray* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::rocos::JointArray* q);
  ::rocos::JointArray* unsafe_arena_release_q();

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acceleration = 3;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double time = 4;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // double radius = 5;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool asynchronous = 6;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MoveL_FK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::JointArray* q_;
  double speed_;
  double acceleration_;
  double time_;
  double radius_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MoveC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MoveC) */ {
 public:
  inline MoveC() : MoveC(nullptr) {}
  ~MoveC() override;
  explicit constexpr MoveC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveC(const MoveC& from);
  MoveC(MoveC&& from) noexcept
    : MoveC() {
    *this = ::std::move(from);
  }

  inline MoveC& operator=(const MoveC& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveC& operator=(MoveC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveC& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveC* internal_default_instance() {
    return reinterpret_cast<const MoveC*>(
               &_MoveC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MoveC& a, MoveC& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveC* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveC* New() const final {
    return new MoveC();
  }

  MoveC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MoveC";
  }
  protected:
  explicit MoveC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoveC_OrientationMode OrientationMode;
  static constexpr OrientationMode UNCONSTRAINED =
    MoveC_OrientationMode_UNCONSTRAINED;
  static constexpr OrientationMode FIXED =
    MoveC_OrientationMode_FIXED;
  static inline bool OrientationMode_IsValid(int value) {
    return MoveC_OrientationMode_IsValid(value);
  }
  static constexpr OrientationMode OrientationMode_MIN =
    MoveC_OrientationMode_OrientationMode_MIN;
  static constexpr OrientationMode OrientationMode_MAX =
    MoveC_OrientationMode_OrientationMode_MAX;
  static constexpr int OrientationMode_ARRAYSIZE =
    MoveC_OrientationMode_OrientationMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrientationMode_descriptor() {
    return MoveC_OrientationMode_descriptor();
  }
  template<typename T>
  static inline const std::string& OrientationMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrientationMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrientationMode_Name.");
    return MoveC_OrientationMode_Name(enum_t_value);
  }
  static inline bool OrientationMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OrientationMode* value) {
    return MoveC_OrientationMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPoseViaFieldNumber = 1,
    kPoseToFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kTimeFieldNumber = 5,
    kRadiusFieldNumber = 6,
    kModeFieldNumber = 7,
    kAsynchronousFieldNumber = 8,
  };
  // .rocos.SE3Pose pose_via = 1;
  bool has_pose_via() const;
  private:
  bool _internal_has_pose_via() const;
  public:
  void clear_pose_via();
  const ::rocos::SE3Pose& pose_via() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose_via();
  ::rocos::SE3Pose* mutable_pose_via();
  void set_allocated_pose_via(::rocos::SE3Pose* pose_via);
  private:
  const ::rocos::SE3Pose& _internal_pose_via() const;
  ::rocos::SE3Pose* _internal_mutable_pose_via();
  public:
  void unsafe_arena_set_allocated_pose_via(
      ::rocos::SE3Pose* pose_via);
  ::rocos::SE3Pose* unsafe_arena_release_pose_via();

  // .rocos.SE3Pose pose_to = 2;
  bool has_pose_to() const;
  private:
  bool _internal_has_pose_to() const;
  public:
  void clear_pose_to();
  const ::rocos::SE3Pose& pose_to() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose_to();
  ::rocos::SE3Pose* mutable_pose_to();
  void set_allocated_pose_to(::rocos::SE3Pose* pose_to);
  private:
  const ::rocos::SE3Pose& _internal_pose_to() const;
  ::rocos::SE3Pose* _internal_mutable_pose_to();
  public:
  void unsafe_arena_set_allocated_pose_to(
      ::rocos::SE3Pose* pose_to);
  ::rocos::SE3Pose* unsafe_arena_release_pose_to();

  // double speed = 3;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acceleration = 4;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double time = 5;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // double radius = 6;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // .rocos.MoveC.OrientationMode mode = 7;
  void clear_mode();
  ::rocos::MoveC_OrientationMode mode() const;
  void set_mode(::rocos::MoveC_OrientationMode value);
  private:
  ::rocos::MoveC_OrientationMode _internal_mode() const;
  void _internal_set_mode(::rocos::MoveC_OrientationMode value);
  public:

  // bool asynchronous = 8;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MoveC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_via_;
  ::rocos::SE3Pose* pose_to_;
  double speed_;
  double acceleration_;
  double time_;
  double radius_;
  int mode_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MoveP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MoveP) */ {
 public:
  inline MoveP() : MoveP(nullptr) {}
  ~MoveP() override;
  explicit constexpr MoveP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveP(const MoveP& from);
  MoveP(MoveP&& from) noexcept
    : MoveP() {
    *this = ::std::move(from);
  }

  inline MoveP& operator=(const MoveP& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveP& operator=(MoveP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveP& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveP* internal_default_instance() {
    return reinterpret_cast<const MoveP*>(
               &_MoveP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MoveP& a, MoveP& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveP* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveP* New() const final {
    return new MoveP();
  }

  MoveP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveP* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MoveP";
  }
  protected:
  explicit MoveP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kAsynchronousFieldNumber = 6,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double acceleration = 3;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double time = 4;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // double radius = 5;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // bool asynchronous = 6;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MoveP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  double speed_;
  double acceleration_;
  double time_;
  double radius_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class Path_PathEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Path.PathEntry) */ {
 public:
  inline Path_PathEntry() : Path_PathEntry(nullptr) {}
  ~Path_PathEntry() override;
  explicit constexpr Path_PathEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path_PathEntry(const Path_PathEntry& from);
  Path_PathEntry(Path_PathEntry&& from) noexcept
    : Path_PathEntry() {
    *this = ::std::move(from);
  }

  inline Path_PathEntry& operator=(const Path_PathEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path_PathEntry& operator=(Path_PathEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path_PathEntry& default_instance() {
    return *internal_default_instance();
  }
  enum ParamCase {
    kQ = 2,
    kPose = 3,
    PARAM_NOT_SET = 0,
  };

  static inline const Path_PathEntry* internal_default_instance() {
    return reinterpret_cast<const Path_PathEntry*>(
               &_Path_PathEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Path_PathEntry& a, Path_PathEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(Path_PathEntry* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path_PathEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path_PathEntry* New() const final {
    return new Path_PathEntry();
  }

  Path_PathEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path_PathEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path_PathEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Path_PathEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path_PathEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Path.PathEntry";
  }
  protected:
  explicit Path_PathEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Path_PathEntry_MoveType MoveType;
  static constexpr MoveType MOVE_J =
    Path_PathEntry_MoveType_MOVE_J;
  static constexpr MoveType MOVE_L =
    Path_PathEntry_MoveType_MOVE_L;
  static constexpr MoveType MOVE_P =
    Path_PathEntry_MoveType_MOVE_P;
  static constexpr MoveType MOVE_C =
    Path_PathEntry_MoveType_MOVE_C;
  static inline bool MoveType_IsValid(int value) {
    return Path_PathEntry_MoveType_IsValid(value);
  }
  static constexpr MoveType MoveType_MIN =
    Path_PathEntry_MoveType_MoveType_MIN;
  static constexpr MoveType MoveType_MAX =
    Path_PathEntry_MoveType_MoveType_MAX;
  static constexpr int MoveType_ARRAYSIZE =
    Path_PathEntry_MoveType_MoveType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MoveType_descriptor() {
    return Path_PathEntry_MoveType_descriptor();
  }
  template<typename T>
  static inline const std::string& MoveType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MoveType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MoveType_Name.");
    return Path_PathEntry_MoveType_Name(enum_t_value);
  }
  static inline bool MoveType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MoveType* value) {
    return Path_PathEntry_MoveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kQFieldNumber = 2,
    kPoseFieldNumber = 3,
  };
  // .rocos.Path.PathEntry.MoveType type = 1;
  void clear_type();
  ::rocos::Path_PathEntry_MoveType type() const;
  void set_type(::rocos::Path_PathEntry_MoveType value);
  private:
  ::rocos::Path_PathEntry_MoveType _internal_type() const;
  void _internal_set_type(::rocos::Path_PathEntry_MoveType value);
  public:

  // .rocos.JointArray q = 2;
  bool has_q() const;
  private:
  bool _internal_has_q() const;
  public:
  void clear_q();
  const ::rocos::JointArray& q() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::JointArray* release_q();
  ::rocos::JointArray* mutable_q();
  void set_allocated_q(::rocos::JointArray* q);
  private:
  const ::rocos::JointArray& _internal_q() const;
  ::rocos::JointArray* _internal_mutable_q();
  public:
  void unsafe_arena_set_allocated_q(
      ::rocos::JointArray* q);
  ::rocos::JointArray* unsafe_arena_release_q();

  // .rocos.SE3Pose pose = 3;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  void clear_param();
  ParamCase param_case() const;
  // @@protoc_insertion_point(class_scope:rocos.Path.PathEntry)
 private:
  class _Internal;
  void set_has_q();
  void set_has_pose();

  inline bool has_param() const;
  inline void clear_has_param();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  union ParamUnion {
    constexpr ParamUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::JointArray* q_;
    ::rocos::SE3Pose* pose_;
  } param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit constexpr Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return new Path();
  }

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Path& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Path_PathEntry PathEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kWaypointsFieldNumber = 1,
  };
  // repeated .rocos.Path.PathEntry waypoints = 1;
  int waypoints_size() const;
  private:
  int _internal_waypoints_size() const;
  public:
  void clear_waypoints();
  ::rocos::Path_PathEntry* mutable_waypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Path_PathEntry >*
      mutable_waypoints();
  private:
  const ::rocos::Path_PathEntry& _internal_waypoints(int index) const;
  ::rocos::Path_PathEntry* _internal_add_waypoints();
  public:
  const ::rocos::Path_PathEntry& waypoints(int index) const;
  ::rocos::Path_PathEntry* add_waypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Path_PathEntry >&
      waypoints() const;

  // @@protoc_insertion_point(class_scope:rocos.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Path_PathEntry > waypoints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MovePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MovePath) */ {
 public:
  inline MovePath() : MovePath(nullptr) {}
  ~MovePath() override;
  explicit constexpr MovePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovePath(const MovePath& from);
  MovePath(MovePath&& from) noexcept
    : MovePath() {
    *this = ::std::move(from);
  }

  inline MovePath& operator=(const MovePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovePath& operator=(MovePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovePath* internal_default_instance() {
    return reinterpret_cast<const MovePath*>(
               &_MovePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MovePath& a, MovePath& b) {
    a.Swap(&b);
  }
  inline void Swap(MovePath* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovePath* New() const final {
    return new MovePath();
  }

  MovePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MovePath& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovePath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MovePath";
  }
  protected:
  explicit MovePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kAsynchronousFieldNumber = 2,
  };
  // .rocos.Path path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::rocos::Path& path() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Path* release_path();
  ::rocos::Path* mutable_path();
  void set_allocated_path(::rocos::Path* path);
  private:
  const ::rocos::Path& _internal_path() const;
  ::rocos::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::rocos::Path* path);
  ::rocos::Path* unsafe_arena_release_path();

  // bool asynchronous = 2;
  void clear_asynchronous();
  bool asynchronous() const;
  void set_asynchronous(bool value);
  private:
  bool _internal_asynchronous() const;
  void _internal_set_asynchronous(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.MovePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Path* path_;
  bool asynchronous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class MotionCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.MotionCommand) */ {
 public:
  inline MotionCommand() : MotionCommand(nullptr) {}
  ~MotionCommand() override;
  explicit constexpr MotionCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionCommand(const MotionCommand& from);
  MotionCommand(MotionCommand&& from) noexcept
    : MotionCommand() {
    *this = ::std::move(from);
  }

  inline MotionCommand& operator=(const MotionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionCommand& operator=(MotionCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kMoveJ = 1,
    kMoveJIk = 2,
    kMoveL = 3,
    kMoveLFk = 4,
    kMoveC = 5,
    kMoveP = 6,
    kMovePath = 7,
    COMMAND_NOT_SET = 0,
  };

  static inline const MotionCommand* internal_default_instance() {
    return reinterpret_cast<const MotionCommand*>(
               &_MotionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MotionCommand& a, MotionCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionCommand* New() const final {
    return new MotionCommand();
  }

  MotionCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotionCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotionCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.MotionCommand";
  }
  protected:
  explicit MotionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveJFieldNumber = 1,
    kMoveJIkFieldNumber = 2,
    kMoveLFieldNumber = 3,
    kMoveLFkFieldNumber = 4,
    kMoveCFieldNumber = 5,
    kMovePFieldNumber = 6,
    kMovePathFieldNumber = 7,
  };
  // .rocos.MoveJ move_j = 1;
  bool has_move_j() const;
  private:
  bool _internal_has_move_j() const;
  public:
  void clear_move_j();
  const ::rocos::MoveJ& move_j() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveJ* release_move_j();
  ::rocos::MoveJ* mutable_move_j();
  void set_allocated_move_j(::rocos::MoveJ* move_j);
  private:
  const ::rocos::MoveJ& _internal_move_j() const;
  ::rocos::MoveJ* _internal_mutable_move_j();
  public:
  void unsafe_arena_set_allocated_move_j(
      ::rocos::MoveJ* move_j);
  ::rocos::MoveJ* unsafe_arena_release_move_j();

  // .rocos.MoveJ_IK move_j_ik = 2;
  bool has_move_j_ik() const;
  private:
  bool _internal_has_move_j_ik() const;
  public:
  void clear_move_j_ik();
  const ::rocos::MoveJ_IK& move_j_ik() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveJ_IK* release_move_j_ik();
  ::rocos::MoveJ_IK* mutable_move_j_ik();
  void set_allocated_move_j_ik(::rocos::MoveJ_IK* move_j_ik);
  private:
  const ::rocos::MoveJ_IK& _internal_move_j_ik() const;
  ::rocos::MoveJ_IK* _internal_mutable_move_j_ik();
  public:
  void unsafe_arena_set_allocated_move_j_ik(
      ::rocos::MoveJ_IK* move_j_ik);
  ::rocos::MoveJ_IK* unsafe_arena_release_move_j_ik();

  // .rocos.MoveL move_l = 3;
  bool has_move_l() const;
  private:
  bool _internal_has_move_l() const;
  public:
  void clear_move_l();
  const ::rocos::MoveL& move_l() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveL* release_move_l();
  ::rocos::MoveL* mutable_move_l();
  void set_allocated_move_l(::rocos::MoveL* move_l);
  private:
  const ::rocos::MoveL& _internal_move_l() const;
  ::rocos::MoveL* _internal_mutable_move_l();
  public:
  void unsafe_arena_set_allocated_move_l(
      ::rocos::MoveL* move_l);
  ::rocos::MoveL* unsafe_arena_release_move_l();

  // .rocos.MoveL_FK move_l_fk = 4;
  bool has_move_l_fk() const;
  private:
  bool _internal_has_move_l_fk() const;
  public:
  void clear_move_l_fk();
  const ::rocos::MoveL_FK& move_l_fk() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveL_FK* release_move_l_fk();
  ::rocos::MoveL_FK* mutable_move_l_fk();
  void set_allocated_move_l_fk(::rocos::MoveL_FK* move_l_fk);
  private:
  const ::rocos::MoveL_FK& _internal_move_l_fk() const;
  ::rocos::MoveL_FK* _internal_mutable_move_l_fk();
  public:
  void unsafe_arena_set_allocated_move_l_fk(
      ::rocos::MoveL_FK* move_l_fk);
  ::rocos::MoveL_FK* unsafe_arena_release_move_l_fk();

  // .rocos.MoveC move_c = 5;
  bool has_move_c() const;
  private:
  bool _internal_has_move_c() const;
  public:
  void clear_move_c();
  const ::rocos::MoveC& move_c() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveC* release_move_c();
  ::rocos::MoveC* mutable_move_c();
  void set_allocated_move_c(::rocos::MoveC* move_c);
  private:
  const ::rocos::MoveC& _internal_move_c() const;
  ::rocos::MoveC* _internal_mutable_move_c();
  public:
  void unsafe_arena_set_allocated_move_c(
      ::rocos::MoveC* move_c);
  ::rocos::MoveC* unsafe_arena_release_move_c();

  // .rocos.MoveP move_p = 6;
  bool has_move_p() const;
  private:
  bool _internal_has_move_p() const;
  public:
  void clear_move_p();
  const ::rocos::MoveP& move_p() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveP* release_move_p();
  ::rocos::MoveP* mutable_move_p();
  void set_allocated_move_p(::rocos::MoveP* move_p);
  private:
  const ::rocos::MoveP& _internal_move_p() const;
  ::rocos::MoveP* _internal_mutable_move_p();
  public:
  void unsafe_arena_set_allocated_move_p(
      ::rocos::MoveP* move_p);
  ::rocos::MoveP* unsafe_arena_release_move_p();

  // .rocos.MovePath move_path = 7;
  bool has_move_path() const;
  private:
  bool _internal_has_move_path() const;
  public:
  void clear_move_path();
  const ::rocos::MovePath& move_path() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MovePath* release_move_path();
  ::rocos::MovePath* mutable_move_path();
  void set_allocated_move_path(::rocos::MovePath* move_path);
  private:
  const ::rocos::MovePath& _internal_move_path() const;
  ::rocos::MovePath* _internal_mutable_move_path();
  public:
  void unsafe_arena_set_allocated_move_path(
      ::rocos::MovePath* move_path);
  ::rocos::MovePath* unsafe_arena_release_move_path();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:rocos.MotionCommand)
 private:
  class _Internal;
  void set_has_move_j();
  void set_has_move_j_ik();
  void set_has_move_l();
  void set_has_move_l_fk();
  void set_has_move_c();
  void set_has_move_p();
  void set_has_move_path();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::MoveJ* move_j_;
    ::rocos::MoveJ_IK* move_j_ik_;
    ::rocos::MoveL* move_l_;
    ::rocos::MoveL_FK* move_l_fk_;
    ::rocos::MoveC* move_c_;
    ::rocos::MoveP* move_p_;
    ::rocos::MovePath* move_path_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class DraggingCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.DraggingCommand) */ {
 public:
  inline DraggingCommand() : DraggingCommand(nullptr) {}
  ~DraggingCommand() override;
  explicit constexpr DraggingCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DraggingCommand(const DraggingCommand& from);
  DraggingCommand(DraggingCommand&& from) noexcept
    : DraggingCommand() {
    *this = ::std::move(from);
  }

  inline DraggingCommand& operator=(const DraggingCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DraggingCommand& operator=(DraggingCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DraggingCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DraggingCommand* internal_default_instance() {
    return reinterpret_cast<const DraggingCommand*>(
               &_DraggingCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DraggingCommand& a, DraggingCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DraggingCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DraggingCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DraggingCommand* New() const final {
    return new DraggingCommand();
  }

  DraggingCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DraggingCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DraggingCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DraggingCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DraggingCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.DraggingCommand";
  }
  protected:
  explicit DraggingCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagFieldNumber = 1,
    kDirFieldNumber = 2,
    kMaxSpeedFieldNumber = 3,
    kMaxAccelerationFieldNumber = 4,
  };
  // .rocos.DraggingFlag flag = 1;
  void clear_flag();
  ::rocos::DraggingFlag flag() const;
  void set_flag(::rocos::DraggingFlag value);
  private:
  ::rocos::DraggingFlag _internal_flag() const;
  void _internal_set_flag(::rocos::DraggingFlag value);
  public:

  // .rocos.DraggingDirection dir = 2;
  void clear_dir();
  ::rocos::DraggingDirection dir() const;
  void set_dir(::rocos::DraggingDirection value);
  private:
  ::rocos::DraggingDirection _internal_dir() const;
  void _internal_set_dir(::rocos::DraggingDirection value);
  public:

  // double max_speed = 3;
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);
  private:
  double _internal_max_speed() const;
  void _internal_set_max_speed(double value);
  public:

  // double max_acceleration = 4;
  void clear_max_acceleration();
  double max_acceleration() const;
  void set_max_acceleration(double value);
  private:
  double _internal_max_acceleration() const;
  void _internal_set_max_acceleration(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.DraggingCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int flag_;
  int dir_;
  double max_speed_;
  double max_acceleration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.RobotCommand) */ {
 public:
  inline RobotCommand() : RobotCommand(nullptr) {}
  ~RobotCommand() override;
  explicit constexpr RobotCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotCommand(const RobotCommand& from);
  RobotCommand(RobotCommand&& from) noexcept
    : RobotCommand() {
    *this = ::std::move(from);
  }

  inline RobotCommand& operator=(const RobotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommand& operator=(RobotCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kEnabled = 1,
    kDisabled = 2,
    kMoveJ = 3,
    kSingleAxisCommand = 4,
    kMultiAxisCommand = 5,
    kMotionCommand = 6,
    kDraggingCommand = 7,
    COMMAND_NOT_SET = 0,
  };

  static inline const RobotCommand* internal_default_instance() {
    return reinterpret_cast<const RobotCommand*>(
               &_RobotCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RobotCommand& a, RobotCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommand* New() const final {
    return new RobotCommand();
  }

  RobotCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.RobotCommand";
  }
  protected:
  explicit RobotCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kDisabledFieldNumber = 2,
    kMoveJFieldNumber = 3,
    kSingleAxisCommandFieldNumber = 4,
    kMultiAxisCommandFieldNumber = 5,
    kMotionCommandFieldNumber = 6,
    kDraggingCommandFieldNumber = 7,
  };
  // .rocos.Enabled enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  const ::rocos::Enabled& enabled() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Enabled* release_enabled();
  ::rocos::Enabled* mutable_enabled();
  void set_allocated_enabled(::rocos::Enabled* enabled);
  private:
  const ::rocos::Enabled& _internal_enabled() const;
  ::rocos::Enabled* _internal_mutable_enabled();
  public:
  void unsafe_arena_set_allocated_enabled(
      ::rocos::Enabled* enabled);
  ::rocos::Enabled* unsafe_arena_release_enabled();

  // .rocos.Disabled disabled = 2;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  const ::rocos::Disabled& disabled() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Disabled* release_disabled();
  ::rocos::Disabled* mutable_disabled();
  void set_allocated_disabled(::rocos::Disabled* disabled);
  private:
  const ::rocos::Disabled& _internal_disabled() const;
  ::rocos::Disabled* _internal_mutable_disabled();
  public:
  void unsafe_arena_set_allocated_disabled(
      ::rocos::Disabled* disabled);
  ::rocos::Disabled* unsafe_arena_release_disabled();

  // .rocos.MoveJ move_j = 3;
  bool has_move_j() const;
  private:
  bool _internal_has_move_j() const;
  public:
  void clear_move_j();
  const ::rocos::MoveJ& move_j() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MoveJ* release_move_j();
  ::rocos::MoveJ* mutable_move_j();
  void set_allocated_move_j(::rocos::MoveJ* move_j);
  private:
  const ::rocos::MoveJ& _internal_move_j() const;
  ::rocos::MoveJ* _internal_mutable_move_j();
  public:
  void unsafe_arena_set_allocated_move_j(
      ::rocos::MoveJ* move_j);
  ::rocos::MoveJ* unsafe_arena_release_move_j();

  // .rocos.SingleAxisCommand single_axis_command = 4;
  bool has_single_axis_command() const;
  private:
  bool _internal_has_single_axis_command() const;
  public:
  void clear_single_axis_command();
  const ::rocos::SingleAxisCommand& single_axis_command() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SingleAxisCommand* release_single_axis_command();
  ::rocos::SingleAxisCommand* mutable_single_axis_command();
  void set_allocated_single_axis_command(::rocos::SingleAxisCommand* single_axis_command);
  private:
  const ::rocos::SingleAxisCommand& _internal_single_axis_command() const;
  ::rocos::SingleAxisCommand* _internal_mutable_single_axis_command();
  public:
  void unsafe_arena_set_allocated_single_axis_command(
      ::rocos::SingleAxisCommand* single_axis_command);
  ::rocos::SingleAxisCommand* unsafe_arena_release_single_axis_command();

  // .rocos.MultiAxisCommand multi_axis_command = 5;
  bool has_multi_axis_command() const;
  private:
  bool _internal_has_multi_axis_command() const;
  public:
  void clear_multi_axis_command();
  const ::rocos::MultiAxisCommand& multi_axis_command() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MultiAxisCommand* release_multi_axis_command();
  ::rocos::MultiAxisCommand* mutable_multi_axis_command();
  void set_allocated_multi_axis_command(::rocos::MultiAxisCommand* multi_axis_command);
  private:
  const ::rocos::MultiAxisCommand& _internal_multi_axis_command() const;
  ::rocos::MultiAxisCommand* _internal_mutable_multi_axis_command();
  public:
  void unsafe_arena_set_allocated_multi_axis_command(
      ::rocos::MultiAxisCommand* multi_axis_command);
  ::rocos::MultiAxisCommand* unsafe_arena_release_multi_axis_command();

  // .rocos.MotionCommand motion_command = 6;
  bool has_motion_command() const;
  private:
  bool _internal_has_motion_command() const;
  public:
  void clear_motion_command();
  const ::rocos::MotionCommand& motion_command() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::MotionCommand* release_motion_command();
  ::rocos::MotionCommand* mutable_motion_command();
  void set_allocated_motion_command(::rocos::MotionCommand* motion_command);
  private:
  const ::rocos::MotionCommand& _internal_motion_command() const;
  ::rocos::MotionCommand* _internal_mutable_motion_command();
  public:
  void unsafe_arena_set_allocated_motion_command(
      ::rocos::MotionCommand* motion_command);
  ::rocos::MotionCommand* unsafe_arena_release_motion_command();

  // .rocos.DraggingCommand dragging_command = 7;
  bool has_dragging_command() const;
  private:
  bool _internal_has_dragging_command() const;
  public:
  void clear_dragging_command();
  const ::rocos::DraggingCommand& dragging_command() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::DraggingCommand* release_dragging_command();
  ::rocos::DraggingCommand* mutable_dragging_command();
  void set_allocated_dragging_command(::rocos::DraggingCommand* dragging_command);
  private:
  const ::rocos::DraggingCommand& _internal_dragging_command() const;
  ::rocos::DraggingCommand* _internal_mutable_dragging_command();
  public:
  void unsafe_arena_set_allocated_dragging_command(
      ::rocos::DraggingCommand* dragging_command);
  ::rocos::DraggingCommand* unsafe_arena_release_dragging_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:rocos.RobotCommand)
 private:
  class _Internal;
  void set_has_enabled();
  void set_has_disabled();
  void set_has_move_j();
  void set_has_single_axis_command();
  void set_has_multi_axis_command();
  void set_has_motion_command();
  void set_has_dragging_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::Enabled* enabled_;
    ::rocos::Disabled* disabled_;
    ::rocos::MoveJ* move_j_;
    ::rocos::SingleAxisCommand* single_axis_command_;
    ::rocos::MultiAxisCommand* multi_axis_command_;
    ::rocos::MotionCommand* motion_command_;
    ::rocos::DraggingCommand* dragging_command_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.RobotCommandRequest) */ {
 public:
  inline RobotCommandRequest() : RobotCommandRequest(nullptr) {}
  ~RobotCommandRequest() override;
  explicit constexpr RobotCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotCommandRequest(const RobotCommandRequest& from);
  RobotCommandRequest(RobotCommandRequest&& from) noexcept
    : RobotCommandRequest() {
    *this = ::std::move(from);
  }

  inline RobotCommandRequest& operator=(const RobotCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandRequest& operator=(RobotCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotCommandRequest* internal_default_instance() {
    return reinterpret_cast<const RobotCommandRequest*>(
               &_RobotCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RobotCommandRequest& a, RobotCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandRequest* New() const final {
    return new RobotCommandRequest();
  }

  RobotCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotCommandRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.RobotCommandRequest";
  }
  protected:
  explicit RobotCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // .rocos.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::rocos::RequestHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::RequestHeader* release_header();
  ::rocos::RequestHeader* mutable_header();
  void set_allocated_header(::rocos::RequestHeader* header);
  private:
  const ::rocos::RequestHeader& _internal_header() const;
  ::rocos::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::rocos::RequestHeader* header);
  ::rocos::RequestHeader* unsafe_arena_release_header();

  // .rocos.RobotCommand command = 2;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::rocos::RobotCommand& command() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::RobotCommand* release_command();
  ::rocos::RobotCommand* mutable_command();
  void set_allocated_command(::rocos::RobotCommand* command);
  private:
  const ::rocos::RobotCommand& _internal_command() const;
  ::rocos::RobotCommand* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::rocos::RobotCommand* command);
  ::rocos::RobotCommand* unsafe_arena_release_command();

  // @@protoc_insertion_point(class_scope:rocos.RobotCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::RequestHeader* header_;
  ::rocos::RobotCommand* command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.RobotCommandResponse) */ {
 public:
  inline RobotCommandResponse() : RobotCommandResponse(nullptr) {}
  ~RobotCommandResponse() override;
  explicit constexpr RobotCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotCommandResponse(const RobotCommandResponse& from);
  RobotCommandResponse(RobotCommandResponse&& from) noexcept
    : RobotCommandResponse() {
    *this = ::std::move(from);
  }

  inline RobotCommandResponse& operator=(const RobotCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandResponse& operator=(RobotCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotCommandResponse* internal_default_instance() {
    return reinterpret_cast<const RobotCommandResponse*>(
               &_RobotCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RobotCommandResponse& a, RobotCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandResponse* New() const final {
    return new RobotCommandResponse();
  }

  RobotCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotCommandResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.RobotCommandResponse";
  }
  protected:
  explicit RobotCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .rocos.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::rocos::ResponseHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::ResponseHeader* release_header();
  ::rocos::ResponseHeader* mutable_header();
  void set_allocated_header(::rocos::ResponseHeader* header);
  private:
  const ::rocos::ResponseHeader& _internal_header() const;
  ::rocos::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::rocos::ResponseHeader* header);
  ::rocos::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:rocos.RobotCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fcommand_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SingleAxisEnabled

// int32 id = 1;
inline void SingleAxisEnabled::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisEnabled::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisEnabled::id() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisEnabled.id)
  return _internal_id();
}
inline void SingleAxisEnabled::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SingleAxisEnabled::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisEnabled.id)
}

// -------------------------------------------------------------------

// SingleAxisDisabled

// int32 id = 1;
inline void SingleAxisDisabled::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisDisabled::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisDisabled::id() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisDisabled.id)
  return _internal_id();
}
inline void SingleAxisDisabled::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SingleAxisDisabled::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisDisabled.id)
}

// -------------------------------------------------------------------

// SingleAxisMode

// int32 id = 1;
inline void SingleAxisMode::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisMode::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisMode::id() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMode.id)
  return _internal_id();
}
inline void SingleAxisMode::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SingleAxisMode::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMode.id)
}

// .rocos.Mode value = 2;
inline void SingleAxisMode::clear_value() {
  value_ = 0;
}
inline ::rocos::Mode SingleAxisMode::_internal_value() const {
  return static_cast< ::rocos::Mode >(value_);
}
inline ::rocos::Mode SingleAxisMode::value() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMode.value)
  return _internal_value();
}
inline void SingleAxisMode::_internal_set_value(::rocos::Mode value) {
  
  value_ = value;
}
inline void SingleAxisMode::set_value(::rocos::Mode value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMode.value)
}

// -------------------------------------------------------------------

// SingleAxisMove

// int32 id = 1;
inline void SingleAxisMove::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisMove::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisMove::id() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.id)
  return _internal_id();
}
inline void SingleAxisMove::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SingleAxisMove::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.id)
}

// double pos = 2;
inline void SingleAxisMove::clear_pos() {
  pos_ = 0;
}
inline double SingleAxisMove::_internal_pos() const {
  return pos_;
}
inline double SingleAxisMove::pos() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.pos)
  return _internal_pos();
}
inline void SingleAxisMove::_internal_set_pos(double value) {
  
  pos_ = value;
}
inline void SingleAxisMove::set_pos(double value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.pos)
}

// optional double max_vel = 3;
inline bool SingleAxisMove::_internal_has_max_vel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SingleAxisMove::has_max_vel() const {
  return _internal_has_max_vel();
}
inline void SingleAxisMove::clear_max_vel() {
  max_vel_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double SingleAxisMove::_internal_max_vel() const {
  return max_vel_;
}
inline double SingleAxisMove::max_vel() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.max_vel)
  return _internal_max_vel();
}
inline void SingleAxisMove::_internal_set_max_vel(double value) {
  _has_bits_[0] |= 0x00000001u;
  max_vel_ = value;
}
inline void SingleAxisMove::set_max_vel(double value) {
  _internal_set_max_vel(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.max_vel)
}

// optional double max_acc = 4;
inline bool SingleAxisMove::_internal_has_max_acc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SingleAxisMove::has_max_acc() const {
  return _internal_has_max_acc();
}
inline void SingleAxisMove::clear_max_acc() {
  max_acc_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SingleAxisMove::_internal_max_acc() const {
  return max_acc_;
}
inline double SingleAxisMove::max_acc() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.max_acc)
  return _internal_max_acc();
}
inline void SingleAxisMove::_internal_set_max_acc(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_acc_ = value;
}
inline void SingleAxisMove::set_max_acc(double value) {
  _internal_set_max_acc(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.max_acc)
}

// optional double max_jerk = 5;
inline bool SingleAxisMove::_internal_has_max_jerk() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SingleAxisMove::has_max_jerk() const {
  return _internal_has_max_jerk();
}
inline void SingleAxisMove::clear_max_jerk() {
  max_jerk_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SingleAxisMove::_internal_max_jerk() const {
  return max_jerk_;
}
inline double SingleAxisMove::max_jerk() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.max_jerk)
  return _internal_max_jerk();
}
inline void SingleAxisMove::_internal_set_max_jerk(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_jerk_ = value;
}
inline void SingleAxisMove::set_max_jerk(double value) {
  _internal_set_max_jerk(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.max_jerk)
}

// optional double least_time = 6;
inline bool SingleAxisMove::_internal_has_least_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SingleAxisMove::has_least_time() const {
  return _internal_has_least_time();
}
inline void SingleAxisMove::clear_least_time() {
  least_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SingleAxisMove::_internal_least_time() const {
  return least_time_;
}
inline double SingleAxisMove::least_time() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.least_time)
  return _internal_least_time();
}
inline void SingleAxisMove::_internal_set_least_time(double value) {
  _has_bits_[0] |= 0x00000010u;
  least_time_ = value;
}
inline void SingleAxisMove::set_least_time(double value) {
  _internal_set_least_time(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.least_time)
}

// optional bool raw_data = 7;
inline bool SingleAxisMove::_internal_has_raw_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SingleAxisMove::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void SingleAxisMove::clear_raw_data() {
  raw_data_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SingleAxisMove::_internal_raw_data() const {
  return raw_data_;
}
inline bool SingleAxisMove::raw_data() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisMove.raw_data)
  return _internal_raw_data();
}
inline void SingleAxisMove::_internal_set_raw_data(bool value) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_ = value;
}
inline void SingleAxisMove::set_raw_data(bool value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisMove.raw_data)
}

// -------------------------------------------------------------------

// SingleAxisStop

// int32 id = 1;
inline void SingleAxisStop::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisStop::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SingleAxisStop::id() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisStop.id)
  return _internal_id();
}
inline void SingleAxisStop::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SingleAxisStop::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:rocos.SingleAxisStop.id)
}

// -------------------------------------------------------------------

// SingleAxisCommand

// .rocos.SingleAxisEnabled enabled = 1;
inline bool SingleAxisCommand::_internal_has_enabled() const {
  return command_case() == kEnabled;
}
inline bool SingleAxisCommand::has_enabled() const {
  return _internal_has_enabled();
}
inline void SingleAxisCommand::set_has_enabled() {
  _oneof_case_[0] = kEnabled;
}
inline void SingleAxisCommand::clear_enabled() {
  if (_internal_has_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.enabled_;
    }
    clear_has_command();
  }
}
inline ::rocos::SingleAxisEnabled* SingleAxisCommand::release_enabled() {
  // @@protoc_insertion_point(field_release:rocos.SingleAxisCommand.enabled)
  if (_internal_has_enabled()) {
    clear_has_command();
      ::rocos::SingleAxisEnabled* temp = command_.enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SingleAxisEnabled& SingleAxisCommand::_internal_enabled() const {
  return _internal_has_enabled()
      ? *command_.enabled_
      : reinterpret_cast< ::rocos::SingleAxisEnabled&>(::rocos::_SingleAxisEnabled_default_instance_);
}
inline const ::rocos::SingleAxisEnabled& SingleAxisCommand::enabled() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisCommand.enabled)
  return _internal_enabled();
}
inline ::rocos::SingleAxisEnabled* SingleAxisCommand::unsafe_arena_release_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.SingleAxisCommand.enabled)
  if (_internal_has_enabled()) {
    clear_has_command();
    ::rocos::SingleAxisEnabled* temp = command_.enabled_;
    command_.enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SingleAxisCommand::unsafe_arena_set_allocated_enabled(::rocos::SingleAxisEnabled* enabled) {
  clear_command();
  if (enabled) {
    set_has_enabled();
    command_.enabled_ = enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SingleAxisCommand.enabled)
}
inline ::rocos::SingleAxisEnabled* SingleAxisCommand::_internal_mutable_enabled() {
  if (!_internal_has_enabled()) {
    clear_command();
    set_has_enabled();
    command_.enabled_ = CreateMaybeMessage< ::rocos::SingleAxisEnabled >(GetArenaForAllocation());
  }
  return command_.enabled_;
}
inline ::rocos::SingleAxisEnabled* SingleAxisCommand::mutable_enabled() {
  ::rocos::SingleAxisEnabled* _msg = _internal_mutable_enabled();
  // @@protoc_insertion_point(field_mutable:rocos.SingleAxisCommand.enabled)
  return _msg;
}

// .rocos.SingleAxisDisabled disabled = 2;
inline bool SingleAxisCommand::_internal_has_disabled() const {
  return command_case() == kDisabled;
}
inline bool SingleAxisCommand::has_disabled() const {
  return _internal_has_disabled();
}
inline void SingleAxisCommand::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
inline void SingleAxisCommand::clear_disabled() {
  if (_internal_has_disabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.disabled_;
    }
    clear_has_command();
  }
}
inline ::rocos::SingleAxisDisabled* SingleAxisCommand::release_disabled() {
  // @@protoc_insertion_point(field_release:rocos.SingleAxisCommand.disabled)
  if (_internal_has_disabled()) {
    clear_has_command();
      ::rocos::SingleAxisDisabled* temp = command_.disabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SingleAxisDisabled& SingleAxisCommand::_internal_disabled() const {
  return _internal_has_disabled()
      ? *command_.disabled_
      : reinterpret_cast< ::rocos::SingleAxisDisabled&>(::rocos::_SingleAxisDisabled_default_instance_);
}
inline const ::rocos::SingleAxisDisabled& SingleAxisCommand::disabled() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisCommand.disabled)
  return _internal_disabled();
}
inline ::rocos::SingleAxisDisabled* SingleAxisCommand::unsafe_arena_release_disabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.SingleAxisCommand.disabled)
  if (_internal_has_disabled()) {
    clear_has_command();
    ::rocos::SingleAxisDisabled* temp = command_.disabled_;
    command_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SingleAxisCommand::unsafe_arena_set_allocated_disabled(::rocos::SingleAxisDisabled* disabled) {
  clear_command();
  if (disabled) {
    set_has_disabled();
    command_.disabled_ = disabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SingleAxisCommand.disabled)
}
inline ::rocos::SingleAxisDisabled* SingleAxisCommand::_internal_mutable_disabled() {
  if (!_internal_has_disabled()) {
    clear_command();
    set_has_disabled();
    command_.disabled_ = CreateMaybeMessage< ::rocos::SingleAxisDisabled >(GetArenaForAllocation());
  }
  return command_.disabled_;
}
inline ::rocos::SingleAxisDisabled* SingleAxisCommand::mutable_disabled() {
  ::rocos::SingleAxisDisabled* _msg = _internal_mutable_disabled();
  // @@protoc_insertion_point(field_mutable:rocos.SingleAxisCommand.disabled)
  return _msg;
}

// .rocos.SingleAxisMode mode = 3;
inline bool SingleAxisCommand::_internal_has_mode() const {
  return command_case() == kMode;
}
inline bool SingleAxisCommand::has_mode() const {
  return _internal_has_mode();
}
inline void SingleAxisCommand::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void SingleAxisCommand::clear_mode() {
  if (_internal_has_mode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.mode_;
    }
    clear_has_command();
  }
}
inline ::rocos::SingleAxisMode* SingleAxisCommand::release_mode() {
  // @@protoc_insertion_point(field_release:rocos.SingleAxisCommand.mode)
  if (_internal_has_mode()) {
    clear_has_command();
      ::rocos::SingleAxisMode* temp = command_.mode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SingleAxisMode& SingleAxisCommand::_internal_mode() const {
  return _internal_has_mode()
      ? *command_.mode_
      : reinterpret_cast< ::rocos::SingleAxisMode&>(::rocos::_SingleAxisMode_default_instance_);
}
inline const ::rocos::SingleAxisMode& SingleAxisCommand::mode() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisCommand.mode)
  return _internal_mode();
}
inline ::rocos::SingleAxisMode* SingleAxisCommand::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.SingleAxisCommand.mode)
  if (_internal_has_mode()) {
    clear_has_command();
    ::rocos::SingleAxisMode* temp = command_.mode_;
    command_.mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SingleAxisCommand::unsafe_arena_set_allocated_mode(::rocos::SingleAxisMode* mode) {
  clear_command();
  if (mode) {
    set_has_mode();
    command_.mode_ = mode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SingleAxisCommand.mode)
}
inline ::rocos::SingleAxisMode* SingleAxisCommand::_internal_mutable_mode() {
  if (!_internal_has_mode()) {
    clear_command();
    set_has_mode();
    command_.mode_ = CreateMaybeMessage< ::rocos::SingleAxisMode >(GetArenaForAllocation());
  }
  return command_.mode_;
}
inline ::rocos::SingleAxisMode* SingleAxisCommand::mutable_mode() {
  ::rocos::SingleAxisMode* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:rocos.SingleAxisCommand.mode)
  return _msg;
}

// .rocos.SingleAxisMove move = 4;
inline bool SingleAxisCommand::_internal_has_move() const {
  return command_case() == kMove;
}
inline bool SingleAxisCommand::has_move() const {
  return _internal_has_move();
}
inline void SingleAxisCommand::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void SingleAxisCommand::clear_move() {
  if (_internal_has_move()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_;
    }
    clear_has_command();
  }
}
inline ::rocos::SingleAxisMove* SingleAxisCommand::release_move() {
  // @@protoc_insertion_point(field_release:rocos.SingleAxisCommand.move)
  if (_internal_has_move()) {
    clear_has_command();
      ::rocos::SingleAxisMove* temp = command_.move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SingleAxisMove& SingleAxisCommand::_internal_move() const {
  return _internal_has_move()
      ? *command_.move_
      : reinterpret_cast< ::rocos::SingleAxisMove&>(::rocos::_SingleAxisMove_default_instance_);
}
inline const ::rocos::SingleAxisMove& SingleAxisCommand::move() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisCommand.move)
  return _internal_move();
}
inline ::rocos::SingleAxisMove* SingleAxisCommand::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.SingleAxisCommand.move)
  if (_internal_has_move()) {
    clear_has_command();
    ::rocos::SingleAxisMove* temp = command_.move_;
    command_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SingleAxisCommand::unsafe_arena_set_allocated_move(::rocos::SingleAxisMove* move) {
  clear_command();
  if (move) {
    set_has_move();
    command_.move_ = move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SingleAxisCommand.move)
}
inline ::rocos::SingleAxisMove* SingleAxisCommand::_internal_mutable_move() {
  if (!_internal_has_move()) {
    clear_command();
    set_has_move();
    command_.move_ = CreateMaybeMessage< ::rocos::SingleAxisMove >(GetArenaForAllocation());
  }
  return command_.move_;
}
inline ::rocos::SingleAxisMove* SingleAxisCommand::mutable_move() {
  ::rocos::SingleAxisMove* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:rocos.SingleAxisCommand.move)
  return _msg;
}

// .rocos.SingleAxisStop stop = 5;
inline bool SingleAxisCommand::_internal_has_stop() const {
  return command_case() == kStop;
}
inline bool SingleAxisCommand::has_stop() const {
  return _internal_has_stop();
}
inline void SingleAxisCommand::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void SingleAxisCommand::clear_stop() {
  if (_internal_has_stop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.stop_;
    }
    clear_has_command();
  }
}
inline ::rocos::SingleAxisStop* SingleAxisCommand::release_stop() {
  // @@protoc_insertion_point(field_release:rocos.SingleAxisCommand.stop)
  if (_internal_has_stop()) {
    clear_has_command();
      ::rocos::SingleAxisStop* temp = command_.stop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SingleAxisStop& SingleAxisCommand::_internal_stop() const {
  return _internal_has_stop()
      ? *command_.stop_
      : reinterpret_cast< ::rocos::SingleAxisStop&>(::rocos::_SingleAxisStop_default_instance_);
}
inline const ::rocos::SingleAxisStop& SingleAxisCommand::stop() const {
  // @@protoc_insertion_point(field_get:rocos.SingleAxisCommand.stop)
  return _internal_stop();
}
inline ::rocos::SingleAxisStop* SingleAxisCommand::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.SingleAxisCommand.stop)
  if (_internal_has_stop()) {
    clear_has_command();
    ::rocos::SingleAxisStop* temp = command_.stop_;
    command_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SingleAxisCommand::unsafe_arena_set_allocated_stop(::rocos::SingleAxisStop* stop) {
  clear_command();
  if (stop) {
    set_has_stop();
    command_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SingleAxisCommand.stop)
}
inline ::rocos::SingleAxisStop* SingleAxisCommand::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    command_.stop_ = CreateMaybeMessage< ::rocos::SingleAxisStop >(GetArenaForAllocation());
  }
  return command_.stop_;
}
inline ::rocos::SingleAxisStop* SingleAxisCommand::mutable_stop() {
  ::rocos::SingleAxisStop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:rocos.SingleAxisCommand.stop)
  return _msg;
}

inline bool SingleAxisCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void SingleAxisCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline SingleAxisCommand::CommandCase SingleAxisCommand::command_case() const {
  return SingleAxisCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MultiAxisEnabled

// -------------------------------------------------------------------

// MultiAxisDisabled

// -------------------------------------------------------------------

// MultiAxisMode

// repeated .rocos.Mode value = 1;
inline int MultiAxisMode::_internal_value_size() const {
  return value_.size();
}
inline int MultiAxisMode::value_size() const {
  return _internal_value_size();
}
inline void MultiAxisMode::clear_value() {
  value_.Clear();
}
inline ::rocos::Mode MultiAxisMode::_internal_value(int index) const {
  return static_cast< ::rocos::Mode >(value_.Get(index));
}
inline ::rocos::Mode MultiAxisMode::value(int index) const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMode.value)
  return _internal_value(index);
}
inline void MultiAxisMode::set_value(int index, ::rocos::Mode value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMode.value)
}
inline void MultiAxisMode::_internal_add_value(::rocos::Mode value) {
  value_.Add(value);
}
inline void MultiAxisMode::add_value(::rocos::Mode value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:rocos.MultiAxisMode.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MultiAxisMode::value() const {
  // @@protoc_insertion_point(field_list:rocos.MultiAxisMode.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MultiAxisMode::_internal_mutable_value() {
  return &value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MultiAxisMode::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:rocos.MultiAxisMode.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// MultiAxisSync

// .rocos.Synchronization value = 1;
inline void MultiAxisSync::clear_value() {
  value_ = 0;
}
inline ::rocos::Synchronization MultiAxisSync::_internal_value() const {
  return static_cast< ::rocos::Synchronization >(value_);
}
inline ::rocos::Synchronization MultiAxisSync::value() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisSync.value)
  return _internal_value();
}
inline void MultiAxisSync::_internal_set_value(::rocos::Synchronization value) {
  
  value_ = value;
}
inline void MultiAxisSync::set_value(::rocos::Synchronization value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisSync.value)
}

// -------------------------------------------------------------------

// MultiAxisMove

// repeated double target_pos = 1;
inline int MultiAxisMove::_internal_target_pos_size() const {
  return target_pos_.size();
}
inline int MultiAxisMove::target_pos_size() const {
  return _internal_target_pos_size();
}
inline void MultiAxisMove::clear_target_pos() {
  target_pos_.Clear();
}
inline double MultiAxisMove::_internal_target_pos(int index) const {
  return target_pos_.Get(index);
}
inline double MultiAxisMove::target_pos(int index) const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.target_pos)
  return _internal_target_pos(index);
}
inline void MultiAxisMove::set_target_pos(int index, double value) {
  target_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.target_pos)
}
inline void MultiAxisMove::_internal_add_target_pos(double value) {
  target_pos_.Add(value);
}
inline void MultiAxisMove::add_target_pos(double value) {
  _internal_add_target_pos(value);
  // @@protoc_insertion_point(field_add:rocos.MultiAxisMove.target_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::_internal_target_pos() const {
  return target_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::target_pos() const {
  // @@protoc_insertion_point(field_list:rocos.MultiAxisMove.target_pos)
  return _internal_target_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::_internal_mutable_target_pos() {
  return &target_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::mutable_target_pos() {
  // @@protoc_insertion_point(field_mutable_list:rocos.MultiAxisMove.target_pos)
  return _internal_mutable_target_pos();
}

// repeated double max_vel = 3;
inline int MultiAxisMove::_internal_max_vel_size() const {
  return max_vel_.size();
}
inline int MultiAxisMove::max_vel_size() const {
  return _internal_max_vel_size();
}
inline void MultiAxisMove::clear_max_vel() {
  max_vel_.Clear();
}
inline double MultiAxisMove::_internal_max_vel(int index) const {
  return max_vel_.Get(index);
}
inline double MultiAxisMove::max_vel(int index) const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.max_vel)
  return _internal_max_vel(index);
}
inline void MultiAxisMove::set_max_vel(int index, double value) {
  max_vel_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.max_vel)
}
inline void MultiAxisMove::_internal_add_max_vel(double value) {
  max_vel_.Add(value);
}
inline void MultiAxisMove::add_max_vel(double value) {
  _internal_add_max_vel(value);
  // @@protoc_insertion_point(field_add:rocos.MultiAxisMove.max_vel)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::_internal_max_vel() const {
  return max_vel_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::max_vel() const {
  // @@protoc_insertion_point(field_list:rocos.MultiAxisMove.max_vel)
  return _internal_max_vel();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::_internal_mutable_max_vel() {
  return &max_vel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::mutable_max_vel() {
  // @@protoc_insertion_point(field_mutable_list:rocos.MultiAxisMove.max_vel)
  return _internal_mutable_max_vel();
}

// repeated double max_acc = 4;
inline int MultiAxisMove::_internal_max_acc_size() const {
  return max_acc_.size();
}
inline int MultiAxisMove::max_acc_size() const {
  return _internal_max_acc_size();
}
inline void MultiAxisMove::clear_max_acc() {
  max_acc_.Clear();
}
inline double MultiAxisMove::_internal_max_acc(int index) const {
  return max_acc_.Get(index);
}
inline double MultiAxisMove::max_acc(int index) const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.max_acc)
  return _internal_max_acc(index);
}
inline void MultiAxisMove::set_max_acc(int index, double value) {
  max_acc_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.max_acc)
}
inline void MultiAxisMove::_internal_add_max_acc(double value) {
  max_acc_.Add(value);
}
inline void MultiAxisMove::add_max_acc(double value) {
  _internal_add_max_acc(value);
  // @@protoc_insertion_point(field_add:rocos.MultiAxisMove.max_acc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::_internal_max_acc() const {
  return max_acc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::max_acc() const {
  // @@protoc_insertion_point(field_list:rocos.MultiAxisMove.max_acc)
  return _internal_max_acc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::_internal_mutable_max_acc() {
  return &max_acc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::mutable_max_acc() {
  // @@protoc_insertion_point(field_mutable_list:rocos.MultiAxisMove.max_acc)
  return _internal_mutable_max_acc();
}

// repeated double max_jerk = 5;
inline int MultiAxisMove::_internal_max_jerk_size() const {
  return max_jerk_.size();
}
inline int MultiAxisMove::max_jerk_size() const {
  return _internal_max_jerk_size();
}
inline void MultiAxisMove::clear_max_jerk() {
  max_jerk_.Clear();
}
inline double MultiAxisMove::_internal_max_jerk(int index) const {
  return max_jerk_.Get(index);
}
inline double MultiAxisMove::max_jerk(int index) const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.max_jerk)
  return _internal_max_jerk(index);
}
inline void MultiAxisMove::set_max_jerk(int index, double value) {
  max_jerk_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.max_jerk)
}
inline void MultiAxisMove::_internal_add_max_jerk(double value) {
  max_jerk_.Add(value);
}
inline void MultiAxisMove::add_max_jerk(double value) {
  _internal_add_max_jerk(value);
  // @@protoc_insertion_point(field_add:rocos.MultiAxisMove.max_jerk)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::_internal_max_jerk() const {
  return max_jerk_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
MultiAxisMove::max_jerk() const {
  // @@protoc_insertion_point(field_list:rocos.MultiAxisMove.max_jerk)
  return _internal_max_jerk();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::_internal_mutable_max_jerk() {
  return &max_jerk_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
MultiAxisMove::mutable_max_jerk() {
  // @@protoc_insertion_point(field_mutable_list:rocos.MultiAxisMove.max_jerk)
  return _internal_mutable_max_jerk();
}

// optional double least_time = 6;
inline bool MultiAxisMove::_internal_has_least_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultiAxisMove::has_least_time() const {
  return _internal_has_least_time();
}
inline void MultiAxisMove::clear_least_time() {
  least_time_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double MultiAxisMove::_internal_least_time() const {
  return least_time_;
}
inline double MultiAxisMove::least_time() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.least_time)
  return _internal_least_time();
}
inline void MultiAxisMove::_internal_set_least_time(double value) {
  _has_bits_[0] |= 0x00000001u;
  least_time_ = value;
}
inline void MultiAxisMove::set_least_time(double value) {
  _internal_set_least_time(value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.least_time)
}

// optional bool raw_data = 7;
inline bool MultiAxisMove::_internal_has_raw_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MultiAxisMove::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void MultiAxisMove::clear_raw_data() {
  raw_data_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MultiAxisMove::_internal_raw_data() const {
  return raw_data_;
}
inline bool MultiAxisMove::raw_data() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.raw_data)
  return _internal_raw_data();
}
inline void MultiAxisMove::_internal_set_raw_data(bool value) {
  _has_bits_[0] |= 0x00000002u;
  raw_data_ = value;
}
inline void MultiAxisMove::set_raw_data(bool value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.raw_data)
}

// optional .rocos.Synchronization sync = 8;
inline bool MultiAxisMove::_internal_has_sync() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MultiAxisMove::has_sync() const {
  return _internal_has_sync();
}
inline void MultiAxisMove::clear_sync() {
  sync_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::rocos::Synchronization MultiAxisMove::_internal_sync() const {
  return static_cast< ::rocos::Synchronization >(sync_);
}
inline ::rocos::Synchronization MultiAxisMove::sync() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisMove.sync)
  return _internal_sync();
}
inline void MultiAxisMove::_internal_set_sync(::rocos::Synchronization value) {
  _has_bits_[0] |= 0x00000004u;
  sync_ = value;
}
inline void MultiAxisMove::set_sync(::rocos::Synchronization value) {
  _internal_set_sync(value);
  // @@protoc_insertion_point(field_set:rocos.MultiAxisMove.sync)
}

// -------------------------------------------------------------------

// MultiAxisStop

// -------------------------------------------------------------------

// MultiAxisCommand

// .rocos.MultiAxisEnabled enabled = 1;
inline bool MultiAxisCommand::_internal_has_enabled() const {
  return command_case() == kEnabled;
}
inline bool MultiAxisCommand::has_enabled() const {
  return _internal_has_enabled();
}
inline void MultiAxisCommand::set_has_enabled() {
  _oneof_case_[0] = kEnabled;
}
inline void MultiAxisCommand::clear_enabled() {
  if (_internal_has_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.enabled_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisEnabled* MultiAxisCommand::release_enabled() {
  // @@protoc_insertion_point(field_release:rocos.MultiAxisCommand.enabled)
  if (_internal_has_enabled()) {
    clear_has_command();
      ::rocos::MultiAxisEnabled* temp = command_.enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisEnabled& MultiAxisCommand::_internal_enabled() const {
  return _internal_has_enabled()
      ? *command_.enabled_
      : reinterpret_cast< ::rocos::MultiAxisEnabled&>(::rocos::_MultiAxisEnabled_default_instance_);
}
inline const ::rocos::MultiAxisEnabled& MultiAxisCommand::enabled() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisCommand.enabled)
  return _internal_enabled();
}
inline ::rocos::MultiAxisEnabled* MultiAxisCommand::unsafe_arena_release_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MultiAxisCommand.enabled)
  if (_internal_has_enabled()) {
    clear_has_command();
    ::rocos::MultiAxisEnabled* temp = command_.enabled_;
    command_.enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiAxisCommand::unsafe_arena_set_allocated_enabled(::rocos::MultiAxisEnabled* enabled) {
  clear_command();
  if (enabled) {
    set_has_enabled();
    command_.enabled_ = enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MultiAxisCommand.enabled)
}
inline ::rocos::MultiAxisEnabled* MultiAxisCommand::_internal_mutable_enabled() {
  if (!_internal_has_enabled()) {
    clear_command();
    set_has_enabled();
    command_.enabled_ = CreateMaybeMessage< ::rocos::MultiAxisEnabled >(GetArenaForAllocation());
  }
  return command_.enabled_;
}
inline ::rocos::MultiAxisEnabled* MultiAxisCommand::mutable_enabled() {
  ::rocos::MultiAxisEnabled* _msg = _internal_mutable_enabled();
  // @@protoc_insertion_point(field_mutable:rocos.MultiAxisCommand.enabled)
  return _msg;
}

// .rocos.MultiAxisDisabled disabled = 2;
inline bool MultiAxisCommand::_internal_has_disabled() const {
  return command_case() == kDisabled;
}
inline bool MultiAxisCommand::has_disabled() const {
  return _internal_has_disabled();
}
inline void MultiAxisCommand::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
inline void MultiAxisCommand::clear_disabled() {
  if (_internal_has_disabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.disabled_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisDisabled* MultiAxisCommand::release_disabled() {
  // @@protoc_insertion_point(field_release:rocos.MultiAxisCommand.disabled)
  if (_internal_has_disabled()) {
    clear_has_command();
      ::rocos::MultiAxisDisabled* temp = command_.disabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisDisabled& MultiAxisCommand::_internal_disabled() const {
  return _internal_has_disabled()
      ? *command_.disabled_
      : reinterpret_cast< ::rocos::MultiAxisDisabled&>(::rocos::_MultiAxisDisabled_default_instance_);
}
inline const ::rocos::MultiAxisDisabled& MultiAxisCommand::disabled() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisCommand.disabled)
  return _internal_disabled();
}
inline ::rocos::MultiAxisDisabled* MultiAxisCommand::unsafe_arena_release_disabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MultiAxisCommand.disabled)
  if (_internal_has_disabled()) {
    clear_has_command();
    ::rocos::MultiAxisDisabled* temp = command_.disabled_;
    command_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiAxisCommand::unsafe_arena_set_allocated_disabled(::rocos::MultiAxisDisabled* disabled) {
  clear_command();
  if (disabled) {
    set_has_disabled();
    command_.disabled_ = disabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MultiAxisCommand.disabled)
}
inline ::rocos::MultiAxisDisabled* MultiAxisCommand::_internal_mutable_disabled() {
  if (!_internal_has_disabled()) {
    clear_command();
    set_has_disabled();
    command_.disabled_ = CreateMaybeMessage< ::rocos::MultiAxisDisabled >(GetArenaForAllocation());
  }
  return command_.disabled_;
}
inline ::rocos::MultiAxisDisabled* MultiAxisCommand::mutable_disabled() {
  ::rocos::MultiAxisDisabled* _msg = _internal_mutable_disabled();
  // @@protoc_insertion_point(field_mutable:rocos.MultiAxisCommand.disabled)
  return _msg;
}

// .rocos.MultiAxisMode mode = 3;
inline bool MultiAxisCommand::_internal_has_mode() const {
  return command_case() == kMode;
}
inline bool MultiAxisCommand::has_mode() const {
  return _internal_has_mode();
}
inline void MultiAxisCommand::set_has_mode() {
  _oneof_case_[0] = kMode;
}
inline void MultiAxisCommand::clear_mode() {
  if (_internal_has_mode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.mode_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisMode* MultiAxisCommand::release_mode() {
  // @@protoc_insertion_point(field_release:rocos.MultiAxisCommand.mode)
  if (_internal_has_mode()) {
    clear_has_command();
      ::rocos::MultiAxisMode* temp = command_.mode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisMode& MultiAxisCommand::_internal_mode() const {
  return _internal_has_mode()
      ? *command_.mode_
      : reinterpret_cast< ::rocos::MultiAxisMode&>(::rocos::_MultiAxisMode_default_instance_);
}
inline const ::rocos::MultiAxisMode& MultiAxisCommand::mode() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisCommand.mode)
  return _internal_mode();
}
inline ::rocos::MultiAxisMode* MultiAxisCommand::unsafe_arena_release_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MultiAxisCommand.mode)
  if (_internal_has_mode()) {
    clear_has_command();
    ::rocos::MultiAxisMode* temp = command_.mode_;
    command_.mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiAxisCommand::unsafe_arena_set_allocated_mode(::rocos::MultiAxisMode* mode) {
  clear_command();
  if (mode) {
    set_has_mode();
    command_.mode_ = mode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MultiAxisCommand.mode)
}
inline ::rocos::MultiAxisMode* MultiAxisCommand::_internal_mutable_mode() {
  if (!_internal_has_mode()) {
    clear_command();
    set_has_mode();
    command_.mode_ = CreateMaybeMessage< ::rocos::MultiAxisMode >(GetArenaForAllocation());
  }
  return command_.mode_;
}
inline ::rocos::MultiAxisMode* MultiAxisCommand::mutable_mode() {
  ::rocos::MultiAxisMode* _msg = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:rocos.MultiAxisCommand.mode)
  return _msg;
}

// .rocos.MultiAxisSync sync = 4;
inline bool MultiAxisCommand::_internal_has_sync() const {
  return command_case() == kSync;
}
inline bool MultiAxisCommand::has_sync() const {
  return _internal_has_sync();
}
inline void MultiAxisCommand::set_has_sync() {
  _oneof_case_[0] = kSync;
}
inline void MultiAxisCommand::clear_sync() {
  if (_internal_has_sync()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.sync_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisSync* MultiAxisCommand::release_sync() {
  // @@protoc_insertion_point(field_release:rocos.MultiAxisCommand.sync)
  if (_internal_has_sync()) {
    clear_has_command();
      ::rocos::MultiAxisSync* temp = command_.sync_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisSync& MultiAxisCommand::_internal_sync() const {
  return _internal_has_sync()
      ? *command_.sync_
      : reinterpret_cast< ::rocos::MultiAxisSync&>(::rocos::_MultiAxisSync_default_instance_);
}
inline const ::rocos::MultiAxisSync& MultiAxisCommand::sync() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisCommand.sync)
  return _internal_sync();
}
inline ::rocos::MultiAxisSync* MultiAxisCommand::unsafe_arena_release_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MultiAxisCommand.sync)
  if (_internal_has_sync()) {
    clear_has_command();
    ::rocos::MultiAxisSync* temp = command_.sync_;
    command_.sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiAxisCommand::unsafe_arena_set_allocated_sync(::rocos::MultiAxisSync* sync) {
  clear_command();
  if (sync) {
    set_has_sync();
    command_.sync_ = sync;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MultiAxisCommand.sync)
}
inline ::rocos::MultiAxisSync* MultiAxisCommand::_internal_mutable_sync() {
  if (!_internal_has_sync()) {
    clear_command();
    set_has_sync();
    command_.sync_ = CreateMaybeMessage< ::rocos::MultiAxisSync >(GetArenaForAllocation());
  }
  return command_.sync_;
}
inline ::rocos::MultiAxisSync* MultiAxisCommand::mutable_sync() {
  ::rocos::MultiAxisSync* _msg = _internal_mutable_sync();
  // @@protoc_insertion_point(field_mutable:rocos.MultiAxisCommand.sync)
  return _msg;
}

// .rocos.MultiAxisMove move = 5;
inline bool MultiAxisCommand::_internal_has_move() const {
  return command_case() == kMove;
}
inline bool MultiAxisCommand::has_move() const {
  return _internal_has_move();
}
inline void MultiAxisCommand::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void MultiAxisCommand::clear_move() {
  if (_internal_has_move()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisMove* MultiAxisCommand::release_move() {
  // @@protoc_insertion_point(field_release:rocos.MultiAxisCommand.move)
  if (_internal_has_move()) {
    clear_has_command();
      ::rocos::MultiAxisMove* temp = command_.move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisMove& MultiAxisCommand::_internal_move() const {
  return _internal_has_move()
      ? *command_.move_
      : reinterpret_cast< ::rocos::MultiAxisMove&>(::rocos::_MultiAxisMove_default_instance_);
}
inline const ::rocos::MultiAxisMove& MultiAxisCommand::move() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisCommand.move)
  return _internal_move();
}
inline ::rocos::MultiAxisMove* MultiAxisCommand::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MultiAxisCommand.move)
  if (_internal_has_move()) {
    clear_has_command();
    ::rocos::MultiAxisMove* temp = command_.move_;
    command_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiAxisCommand::unsafe_arena_set_allocated_move(::rocos::MultiAxisMove* move) {
  clear_command();
  if (move) {
    set_has_move();
    command_.move_ = move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MultiAxisCommand.move)
}
inline ::rocos::MultiAxisMove* MultiAxisCommand::_internal_mutable_move() {
  if (!_internal_has_move()) {
    clear_command();
    set_has_move();
    command_.move_ = CreateMaybeMessage< ::rocos::MultiAxisMove >(GetArenaForAllocation());
  }
  return command_.move_;
}
inline ::rocos::MultiAxisMove* MultiAxisCommand::mutable_move() {
  ::rocos::MultiAxisMove* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:rocos.MultiAxisCommand.move)
  return _msg;
}

// .rocos.MultiAxisStop stop = 6;
inline bool MultiAxisCommand::_internal_has_stop() const {
  return command_case() == kStop;
}
inline bool MultiAxisCommand::has_stop() const {
  return _internal_has_stop();
}
inline void MultiAxisCommand::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void MultiAxisCommand::clear_stop() {
  if (_internal_has_stop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.stop_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisStop* MultiAxisCommand::release_stop() {
  // @@protoc_insertion_point(field_release:rocos.MultiAxisCommand.stop)
  if (_internal_has_stop()) {
    clear_has_command();
      ::rocos::MultiAxisStop* temp = command_.stop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisStop& MultiAxisCommand::_internal_stop() const {
  return _internal_has_stop()
      ? *command_.stop_
      : reinterpret_cast< ::rocos::MultiAxisStop&>(::rocos::_MultiAxisStop_default_instance_);
}
inline const ::rocos::MultiAxisStop& MultiAxisCommand::stop() const {
  // @@protoc_insertion_point(field_get:rocos.MultiAxisCommand.stop)
  return _internal_stop();
}
inline ::rocos::MultiAxisStop* MultiAxisCommand::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MultiAxisCommand.stop)
  if (_internal_has_stop()) {
    clear_has_command();
    ::rocos::MultiAxisStop* temp = command_.stop_;
    command_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultiAxisCommand::unsafe_arena_set_allocated_stop(::rocos::MultiAxisStop* stop) {
  clear_command();
  if (stop) {
    set_has_stop();
    command_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MultiAxisCommand.stop)
}
inline ::rocos::MultiAxisStop* MultiAxisCommand::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    command_.stop_ = CreateMaybeMessage< ::rocos::MultiAxisStop >(GetArenaForAllocation());
  }
  return command_.stop_;
}
inline ::rocos::MultiAxisStop* MultiAxisCommand::mutable_stop() {
  ::rocos::MultiAxisStop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:rocos.MultiAxisCommand.stop)
  return _msg;
}

inline bool MultiAxisCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void MultiAxisCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline MultiAxisCommand::CommandCase MultiAxisCommand::command_case() const {
  return MultiAxisCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Enabled

// repeated double target_pos = 1;
inline int Enabled::_internal_target_pos_size() const {
  return target_pos_.size();
}
inline int Enabled::target_pos_size() const {
  return _internal_target_pos_size();
}
inline void Enabled::clear_target_pos() {
  target_pos_.Clear();
}
inline double Enabled::_internal_target_pos(int index) const {
  return target_pos_.Get(index);
}
inline double Enabled::target_pos(int index) const {
  // @@protoc_insertion_point(field_get:rocos.Enabled.target_pos)
  return _internal_target_pos(index);
}
inline void Enabled::set_target_pos(int index, double value) {
  target_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.Enabled.target_pos)
}
inline void Enabled::_internal_add_target_pos(double value) {
  target_pos_.Add(value);
}
inline void Enabled::add_target_pos(double value) {
  _internal_add_target_pos(value);
  // @@protoc_insertion_point(field_add:rocos.Enabled.target_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Enabled::_internal_target_pos() const {
  return target_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Enabled::target_pos() const {
  // @@protoc_insertion_point(field_list:rocos.Enabled.target_pos)
  return _internal_target_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Enabled::_internal_mutable_target_pos() {
  return &target_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Enabled::mutable_target_pos() {
  // @@protoc_insertion_point(field_mutable_list:rocos.Enabled.target_pos)
  return _internal_mutable_target_pos();
}

// repeated double target_vel = 2;
inline int Enabled::_internal_target_vel_size() const {
  return target_vel_.size();
}
inline int Enabled::target_vel_size() const {
  return _internal_target_vel_size();
}
inline void Enabled::clear_target_vel() {
  target_vel_.Clear();
}
inline double Enabled::_internal_target_vel(int index) const {
  return target_vel_.Get(index);
}
inline double Enabled::target_vel(int index) const {
  // @@protoc_insertion_point(field_get:rocos.Enabled.target_vel)
  return _internal_target_vel(index);
}
inline void Enabled::set_target_vel(int index, double value) {
  target_vel_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.Enabled.target_vel)
}
inline void Enabled::_internal_add_target_vel(double value) {
  target_vel_.Add(value);
}
inline void Enabled::add_target_vel(double value) {
  _internal_add_target_vel(value);
  // @@protoc_insertion_point(field_add:rocos.Enabled.target_vel)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Enabled::_internal_target_vel() const {
  return target_vel_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Enabled::target_vel() const {
  // @@protoc_insertion_point(field_list:rocos.Enabled.target_vel)
  return _internal_target_vel();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Enabled::_internal_mutable_target_vel() {
  return &target_vel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Enabled::mutable_target_vel() {
  // @@protoc_insertion_point(field_mutable_list:rocos.Enabled.target_vel)
  return _internal_mutable_target_vel();
}

// -------------------------------------------------------------------

// Disabled

// -------------------------------------------------------------------

// ZeroOffset

// repeated .google.protobuf.Int32Value value = 1;
inline int ZeroOffset::_internal_value_size() const {
  return value_.size();
}
inline int ZeroOffset::value_size() const {
  return _internal_value_size();
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ZeroOffset::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.ZeroOffset.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Int32Value >*
ZeroOffset::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:rocos.ZeroOffset.value)
  return &value_;
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& ZeroOffset::_internal_value(int index) const {
  return value_.Get(index);
}
inline const PROTOBUF_NAMESPACE_ID::Int32Value& ZeroOffset::value(int index) const {
  // @@protoc_insertion_point(field_get:rocos.ZeroOffset.value)
  return _internal_value(index);
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ZeroOffset::_internal_add_value() {
  return value_.Add();
}
inline PROTOBUF_NAMESPACE_ID::Int32Value* ZeroOffset::add_value() {
  PROTOBUF_NAMESPACE_ID::Int32Value* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:rocos.ZeroOffset.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::Int32Value >&
ZeroOffset::value() const {
  // @@protoc_insertion_point(field_list:rocos.ZeroOffset.value)
  return value_;
}

// -------------------------------------------------------------------

// CntPerUnit

// repeated .google.protobuf.DoubleValue value = 1;
inline int CntPerUnit::_internal_value_size() const {
  return value_.size();
}
inline int CntPerUnit::value_size() const {
  return _internal_value_size();
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* CntPerUnit::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.CntPerUnit.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::DoubleValue >*
CntPerUnit::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:rocos.CntPerUnit.value)
  return &value_;
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& CntPerUnit::_internal_value(int index) const {
  return value_.Get(index);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& CntPerUnit::value(int index) const {
  // @@protoc_insertion_point(field_get:rocos.CntPerUnit.value)
  return _internal_value(index);
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* CntPerUnit::_internal_add_value() {
  return value_.Add();
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* CntPerUnit::add_value() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:rocos.CntPerUnit.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< PROTOBUF_NAMESPACE_ID::DoubleValue >&
CntPerUnit::value() const {
  // @@protoc_insertion_point(field_list:rocos.CntPerUnit.value)
  return value_;
}

// -------------------------------------------------------------------

// MoveJ

// .rocos.JointArray q = 1;
inline bool MoveJ::_internal_has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline bool MoveJ::has_q() const {
  return _internal_has_q();
}
inline const ::rocos::JointArray& MoveJ::_internal_q() const {
  const ::rocos::JointArray* p = q_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::JointArray&>(
      ::rocos::_JointArray_default_instance_);
}
inline const ::rocos::JointArray& MoveJ::q() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ.q)
  return _internal_q();
}
inline void MoveJ::unsafe_arena_set_allocated_q(
    ::rocos::JointArray* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(q_);
  }
  q_ = q;
  if (q) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveJ.q)
}
inline ::rocos::JointArray* MoveJ::release_q() {
  
  ::rocos::JointArray* temp = q_;
  q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::JointArray* MoveJ::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:rocos.MoveJ.q)
  
  ::rocos::JointArray* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::rocos::JointArray* MoveJ::_internal_mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::JointArray>(GetArenaForAllocation());
    q_ = p;
  }
  return q_;
}
inline ::rocos::JointArray* MoveJ::mutable_q() {
  ::rocos::JointArray* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:rocos.MoveJ.q)
  return _msg;
}
inline void MoveJ::set_allocated_q(::rocos::JointArray* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(q_);
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(q));
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveJ.q)
}

// double speed = 2;
inline void MoveJ::clear_speed() {
  speed_ = 0;
}
inline double MoveJ::_internal_speed() const {
  return speed_;
}
inline double MoveJ::speed() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ.speed)
  return _internal_speed();
}
inline void MoveJ::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MoveJ::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ.speed)
}

// double acceleration = 3;
inline void MoveJ::clear_acceleration() {
  acceleration_ = 0;
}
inline double MoveJ::_internal_acceleration() const {
  return acceleration_;
}
inline double MoveJ::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ.acceleration)
  return _internal_acceleration();
}
inline void MoveJ::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void MoveJ::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ.acceleration)
}

// double time = 4;
inline void MoveJ::clear_time() {
  time_ = 0;
}
inline double MoveJ::_internal_time() const {
  return time_;
}
inline double MoveJ::time() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ.time)
  return _internal_time();
}
inline void MoveJ::_internal_set_time(double value) {
  
  time_ = value;
}
inline void MoveJ::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ.time)
}

// double radius = 5;
inline void MoveJ::clear_radius() {
  radius_ = 0;
}
inline double MoveJ::_internal_radius() const {
  return radius_;
}
inline double MoveJ::radius() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ.radius)
  return _internal_radius();
}
inline void MoveJ::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void MoveJ::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ.radius)
}

// bool asynchronous = 6;
inline void MoveJ::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MoveJ::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MoveJ::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ.asynchronous)
  return _internal_asynchronous();
}
inline void MoveJ::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MoveJ::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ.asynchronous)
}

// -------------------------------------------------------------------

// MoveJ_IK

// .rocos.SE3Pose pose = 1;
inline bool MoveJ_IK::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool MoveJ_IK::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& MoveJ_IK::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& MoveJ_IK::pose() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ_IK.pose)
  return _internal_pose();
}
inline void MoveJ_IK::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveJ_IK.pose)
}
inline ::rocos::SE3Pose* MoveJ_IK::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* MoveJ_IK::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.MoveJ_IK.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* MoveJ_IK::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* MoveJ_IK::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.MoveJ_IK.pose)
  return _msg;
}
inline void MoveJ_IK::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveJ_IK.pose)
}

// double speed = 2;
inline void MoveJ_IK::clear_speed() {
  speed_ = 0;
}
inline double MoveJ_IK::_internal_speed() const {
  return speed_;
}
inline double MoveJ_IK::speed() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ_IK.speed)
  return _internal_speed();
}
inline void MoveJ_IK::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MoveJ_IK::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ_IK.speed)
}

// double acceleration = 3;
inline void MoveJ_IK::clear_acceleration() {
  acceleration_ = 0;
}
inline double MoveJ_IK::_internal_acceleration() const {
  return acceleration_;
}
inline double MoveJ_IK::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ_IK.acceleration)
  return _internal_acceleration();
}
inline void MoveJ_IK::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void MoveJ_IK::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ_IK.acceleration)
}

// double time = 4;
inline void MoveJ_IK::clear_time() {
  time_ = 0;
}
inline double MoveJ_IK::_internal_time() const {
  return time_;
}
inline double MoveJ_IK::time() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ_IK.time)
  return _internal_time();
}
inline void MoveJ_IK::_internal_set_time(double value) {
  
  time_ = value;
}
inline void MoveJ_IK::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ_IK.time)
}

// double radius = 5;
inline void MoveJ_IK::clear_radius() {
  radius_ = 0;
}
inline double MoveJ_IK::_internal_radius() const {
  return radius_;
}
inline double MoveJ_IK::radius() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ_IK.radius)
  return _internal_radius();
}
inline void MoveJ_IK::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void MoveJ_IK::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ_IK.radius)
}

// bool asynchronous = 6;
inline void MoveJ_IK::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MoveJ_IK::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MoveJ_IK::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MoveJ_IK.asynchronous)
  return _internal_asynchronous();
}
inline void MoveJ_IK::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MoveJ_IK::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MoveJ_IK.asynchronous)
}

// -------------------------------------------------------------------

// MoveL

// .rocos.SE3Pose pose = 1;
inline bool MoveL::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool MoveL::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& MoveL::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& MoveL::pose() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL.pose)
  return _internal_pose();
}
inline void MoveL::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveL.pose)
}
inline ::rocos::SE3Pose* MoveL::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* MoveL::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.MoveL.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* MoveL::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* MoveL::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.MoveL.pose)
  return _msg;
}
inline void MoveL::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveL.pose)
}

// double speed = 2;
inline void MoveL::clear_speed() {
  speed_ = 0;
}
inline double MoveL::_internal_speed() const {
  return speed_;
}
inline double MoveL::speed() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL.speed)
  return _internal_speed();
}
inline void MoveL::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MoveL::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL.speed)
}

// double acceleration = 3;
inline void MoveL::clear_acceleration() {
  acceleration_ = 0;
}
inline double MoveL::_internal_acceleration() const {
  return acceleration_;
}
inline double MoveL::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL.acceleration)
  return _internal_acceleration();
}
inline void MoveL::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void MoveL::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL.acceleration)
}

// double time = 4;
inline void MoveL::clear_time() {
  time_ = 0;
}
inline double MoveL::_internal_time() const {
  return time_;
}
inline double MoveL::time() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL.time)
  return _internal_time();
}
inline void MoveL::_internal_set_time(double value) {
  
  time_ = value;
}
inline void MoveL::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL.time)
}

// double radius = 5;
inline void MoveL::clear_radius() {
  radius_ = 0;
}
inline double MoveL::_internal_radius() const {
  return radius_;
}
inline double MoveL::radius() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL.radius)
  return _internal_radius();
}
inline void MoveL::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void MoveL::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL.radius)
}

// bool asynchronous = 6;
inline void MoveL::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MoveL::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MoveL::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL.asynchronous)
  return _internal_asynchronous();
}
inline void MoveL::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MoveL::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL.asynchronous)
}

// -------------------------------------------------------------------

// MoveL_FK

// .rocos.JointArray q = 1;
inline bool MoveL_FK::_internal_has_q() const {
  return this != internal_default_instance() && q_ != nullptr;
}
inline bool MoveL_FK::has_q() const {
  return _internal_has_q();
}
inline const ::rocos::JointArray& MoveL_FK::_internal_q() const {
  const ::rocos::JointArray* p = q_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::JointArray&>(
      ::rocos::_JointArray_default_instance_);
}
inline const ::rocos::JointArray& MoveL_FK::q() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL_FK.q)
  return _internal_q();
}
inline void MoveL_FK::unsafe_arena_set_allocated_q(
    ::rocos::JointArray* q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(q_);
  }
  q_ = q;
  if (q) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveL_FK.q)
}
inline ::rocos::JointArray* MoveL_FK::release_q() {
  
  ::rocos::JointArray* temp = q_;
  q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::JointArray* MoveL_FK::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_release:rocos.MoveL_FK.q)
  
  ::rocos::JointArray* temp = q_;
  q_ = nullptr;
  return temp;
}
inline ::rocos::JointArray* MoveL_FK::_internal_mutable_q() {
  
  if (q_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::JointArray>(GetArenaForAllocation());
    q_ = p;
  }
  return q_;
}
inline ::rocos::JointArray* MoveL_FK::mutable_q() {
  ::rocos::JointArray* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:rocos.MoveL_FK.q)
  return _msg;
}
inline void MoveL_FK::set_allocated_q(::rocos::JointArray* q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(q_);
  }
  if (q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(q));
    if (message_arena != submessage_arena) {
      q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, q, submessage_arena);
    }
    
  } else {
    
  }
  q_ = q;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveL_FK.q)
}

// double speed = 2;
inline void MoveL_FK::clear_speed() {
  speed_ = 0;
}
inline double MoveL_FK::_internal_speed() const {
  return speed_;
}
inline double MoveL_FK::speed() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL_FK.speed)
  return _internal_speed();
}
inline void MoveL_FK::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MoveL_FK::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL_FK.speed)
}

// double acceleration = 3;
inline void MoveL_FK::clear_acceleration() {
  acceleration_ = 0;
}
inline double MoveL_FK::_internal_acceleration() const {
  return acceleration_;
}
inline double MoveL_FK::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL_FK.acceleration)
  return _internal_acceleration();
}
inline void MoveL_FK::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void MoveL_FK::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL_FK.acceleration)
}

// double time = 4;
inline void MoveL_FK::clear_time() {
  time_ = 0;
}
inline double MoveL_FK::_internal_time() const {
  return time_;
}
inline double MoveL_FK::time() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL_FK.time)
  return _internal_time();
}
inline void MoveL_FK::_internal_set_time(double value) {
  
  time_ = value;
}
inline void MoveL_FK::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL_FK.time)
}

// double radius = 5;
inline void MoveL_FK::clear_radius() {
  radius_ = 0;
}
inline double MoveL_FK::_internal_radius() const {
  return radius_;
}
inline double MoveL_FK::radius() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL_FK.radius)
  return _internal_radius();
}
inline void MoveL_FK::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void MoveL_FK::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL_FK.radius)
}

// bool asynchronous = 6;
inline void MoveL_FK::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MoveL_FK::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MoveL_FK::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MoveL_FK.asynchronous)
  return _internal_asynchronous();
}
inline void MoveL_FK::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MoveL_FK::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MoveL_FK.asynchronous)
}

// -------------------------------------------------------------------

// MoveC

// .rocos.SE3Pose pose_via = 1;
inline bool MoveC::_internal_has_pose_via() const {
  return this != internal_default_instance() && pose_via_ != nullptr;
}
inline bool MoveC::has_pose_via() const {
  return _internal_has_pose_via();
}
inline const ::rocos::SE3Pose& MoveC::_internal_pose_via() const {
  const ::rocos::SE3Pose* p = pose_via_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& MoveC::pose_via() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.pose_via)
  return _internal_pose_via();
}
inline void MoveC::unsafe_arena_set_allocated_pose_via(
    ::rocos::SE3Pose* pose_via) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_via_);
  }
  pose_via_ = pose_via;
  if (pose_via) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveC.pose_via)
}
inline ::rocos::SE3Pose* MoveC::release_pose_via() {
  
  ::rocos::SE3Pose* temp = pose_via_;
  pose_via_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* MoveC::unsafe_arena_release_pose_via() {
  // @@protoc_insertion_point(field_release:rocos.MoveC.pose_via)
  
  ::rocos::SE3Pose* temp = pose_via_;
  pose_via_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* MoveC::_internal_mutable_pose_via() {
  
  if (pose_via_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_via_ = p;
  }
  return pose_via_;
}
inline ::rocos::SE3Pose* MoveC::mutable_pose_via() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose_via();
  // @@protoc_insertion_point(field_mutable:rocos.MoveC.pose_via)
  return _msg;
}
inline void MoveC::set_allocated_pose_via(::rocos::SE3Pose* pose_via) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_via_);
  }
  if (pose_via) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_via));
    if (message_arena != submessage_arena) {
      pose_via = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose_via, submessage_arena);
    }
    
  } else {
    
  }
  pose_via_ = pose_via;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveC.pose_via)
}

// .rocos.SE3Pose pose_to = 2;
inline bool MoveC::_internal_has_pose_to() const {
  return this != internal_default_instance() && pose_to_ != nullptr;
}
inline bool MoveC::has_pose_to() const {
  return _internal_has_pose_to();
}
inline const ::rocos::SE3Pose& MoveC::_internal_pose_to() const {
  const ::rocos::SE3Pose* p = pose_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& MoveC::pose_to() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.pose_to)
  return _internal_pose_to();
}
inline void MoveC::unsafe_arena_set_allocated_pose_to(
    ::rocos::SE3Pose* pose_to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_to_);
  }
  pose_to_ = pose_to;
  if (pose_to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveC.pose_to)
}
inline ::rocos::SE3Pose* MoveC::release_pose_to() {
  
  ::rocos::SE3Pose* temp = pose_to_;
  pose_to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* MoveC::unsafe_arena_release_pose_to() {
  // @@protoc_insertion_point(field_release:rocos.MoveC.pose_to)
  
  ::rocos::SE3Pose* temp = pose_to_;
  pose_to_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* MoveC::_internal_mutable_pose_to() {
  
  if (pose_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_to_ = p;
  }
  return pose_to_;
}
inline ::rocos::SE3Pose* MoveC::mutable_pose_to() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose_to();
  // @@protoc_insertion_point(field_mutable:rocos.MoveC.pose_to)
  return _msg;
}
inline void MoveC::set_allocated_pose_to(::rocos::SE3Pose* pose_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_to_);
  }
  if (pose_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_to));
    if (message_arena != submessage_arena) {
      pose_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose_to, submessage_arena);
    }
    
  } else {
    
  }
  pose_to_ = pose_to;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveC.pose_to)
}

// double speed = 3;
inline void MoveC::clear_speed() {
  speed_ = 0;
}
inline double MoveC::_internal_speed() const {
  return speed_;
}
inline double MoveC::speed() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.speed)
  return _internal_speed();
}
inline void MoveC::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MoveC::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rocos.MoveC.speed)
}

// double acceleration = 4;
inline void MoveC::clear_acceleration() {
  acceleration_ = 0;
}
inline double MoveC::_internal_acceleration() const {
  return acceleration_;
}
inline double MoveC::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.acceleration)
  return _internal_acceleration();
}
inline void MoveC::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void MoveC::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.MoveC.acceleration)
}

// double time = 5;
inline void MoveC::clear_time() {
  time_ = 0;
}
inline double MoveC::_internal_time() const {
  return time_;
}
inline double MoveC::time() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.time)
  return _internal_time();
}
inline void MoveC::_internal_set_time(double value) {
  
  time_ = value;
}
inline void MoveC::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:rocos.MoveC.time)
}

// double radius = 6;
inline void MoveC::clear_radius() {
  radius_ = 0;
}
inline double MoveC::_internal_radius() const {
  return radius_;
}
inline double MoveC::radius() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.radius)
  return _internal_radius();
}
inline void MoveC::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void MoveC::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.MoveC.radius)
}

// .rocos.MoveC.OrientationMode mode = 7;
inline void MoveC::clear_mode() {
  mode_ = 0;
}
inline ::rocos::MoveC_OrientationMode MoveC::_internal_mode() const {
  return static_cast< ::rocos::MoveC_OrientationMode >(mode_);
}
inline ::rocos::MoveC_OrientationMode MoveC::mode() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.mode)
  return _internal_mode();
}
inline void MoveC::_internal_set_mode(::rocos::MoveC_OrientationMode value) {
  
  mode_ = value;
}
inline void MoveC::set_mode(::rocos::MoveC_OrientationMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:rocos.MoveC.mode)
}

// bool asynchronous = 8;
inline void MoveC::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MoveC::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MoveC::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MoveC.asynchronous)
  return _internal_asynchronous();
}
inline void MoveC::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MoveC::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MoveC.asynchronous)
}

// -------------------------------------------------------------------

// MoveP

// .rocos.SE3Pose pose = 1;
inline bool MoveP::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool MoveP::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& MoveP::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& MoveP::pose() const {
  // @@protoc_insertion_point(field_get:rocos.MoveP.pose)
  return _internal_pose();
}
inline void MoveP::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MoveP.pose)
}
inline ::rocos::SE3Pose* MoveP::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* MoveP::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.MoveP.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* MoveP::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* MoveP::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.MoveP.pose)
  return _msg;
}
inline void MoveP::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.MoveP.pose)
}

// double speed = 2;
inline void MoveP::clear_speed() {
  speed_ = 0;
}
inline double MoveP::_internal_speed() const {
  return speed_;
}
inline double MoveP::speed() const {
  // @@protoc_insertion_point(field_get:rocos.MoveP.speed)
  return _internal_speed();
}
inline void MoveP::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MoveP::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:rocos.MoveP.speed)
}

// double acceleration = 3;
inline void MoveP::clear_acceleration() {
  acceleration_ = 0;
}
inline double MoveP::_internal_acceleration() const {
  return acceleration_;
}
inline double MoveP::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.MoveP.acceleration)
  return _internal_acceleration();
}
inline void MoveP::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void MoveP::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.MoveP.acceleration)
}

// double time = 4;
inline void MoveP::clear_time() {
  time_ = 0;
}
inline double MoveP::_internal_time() const {
  return time_;
}
inline double MoveP::time() const {
  // @@protoc_insertion_point(field_get:rocos.MoveP.time)
  return _internal_time();
}
inline void MoveP::_internal_set_time(double value) {
  
  time_ = value;
}
inline void MoveP::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:rocos.MoveP.time)
}

// double radius = 5;
inline void MoveP::clear_radius() {
  radius_ = 0;
}
inline double MoveP::_internal_radius() const {
  return radius_;
}
inline double MoveP::radius() const {
  // @@protoc_insertion_point(field_get:rocos.MoveP.radius)
  return _internal_radius();
}
inline void MoveP::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void MoveP::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.MoveP.radius)
}

// bool asynchronous = 6;
inline void MoveP::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MoveP::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MoveP::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MoveP.asynchronous)
  return _internal_asynchronous();
}
inline void MoveP::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MoveP::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MoveP.asynchronous)
}

// -------------------------------------------------------------------

// Path_PathEntry

// .rocos.Path.PathEntry.MoveType type = 1;
inline void Path_PathEntry::clear_type() {
  type_ = 0;
}
inline ::rocos::Path_PathEntry_MoveType Path_PathEntry::_internal_type() const {
  return static_cast< ::rocos::Path_PathEntry_MoveType >(type_);
}
inline ::rocos::Path_PathEntry_MoveType Path_PathEntry::type() const {
  // @@protoc_insertion_point(field_get:rocos.Path.PathEntry.type)
  return _internal_type();
}
inline void Path_PathEntry::_internal_set_type(::rocos::Path_PathEntry_MoveType value) {
  
  type_ = value;
}
inline void Path_PathEntry::set_type(::rocos::Path_PathEntry_MoveType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:rocos.Path.PathEntry.type)
}

// .rocos.JointArray q = 2;
inline bool Path_PathEntry::_internal_has_q() const {
  return param_case() == kQ;
}
inline bool Path_PathEntry::has_q() const {
  return _internal_has_q();
}
inline void Path_PathEntry::set_has_q() {
  _oneof_case_[0] = kQ;
}
inline ::rocos::JointArray* Path_PathEntry::release_q() {
  // @@protoc_insertion_point(field_release:rocos.Path.PathEntry.q)
  if (_internal_has_q()) {
    clear_has_param();
      ::rocos::JointArray* temp = param_.q_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    param_.q_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::JointArray& Path_PathEntry::_internal_q() const {
  return _internal_has_q()
      ? *param_.q_
      : reinterpret_cast< ::rocos::JointArray&>(::rocos::_JointArray_default_instance_);
}
inline const ::rocos::JointArray& Path_PathEntry::q() const {
  // @@protoc_insertion_point(field_get:rocos.Path.PathEntry.q)
  return _internal_q();
}
inline ::rocos::JointArray* Path_PathEntry::unsafe_arena_release_q() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.Path.PathEntry.q)
  if (_internal_has_q()) {
    clear_has_param();
    ::rocos::JointArray* temp = param_.q_;
    param_.q_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Path_PathEntry::unsafe_arena_set_allocated_q(::rocos::JointArray* q) {
  clear_param();
  if (q) {
    set_has_q();
    param_.q_ = q;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Path.PathEntry.q)
}
inline ::rocos::JointArray* Path_PathEntry::_internal_mutable_q() {
  if (!_internal_has_q()) {
    clear_param();
    set_has_q();
    param_.q_ = CreateMaybeMessage< ::rocos::JointArray >(GetArenaForAllocation());
  }
  return param_.q_;
}
inline ::rocos::JointArray* Path_PathEntry::mutable_q() {
  ::rocos::JointArray* _msg = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:rocos.Path.PathEntry.q)
  return _msg;
}

// .rocos.SE3Pose pose = 3;
inline bool Path_PathEntry::_internal_has_pose() const {
  return param_case() == kPose;
}
inline bool Path_PathEntry::has_pose() const {
  return _internal_has_pose();
}
inline void Path_PathEntry::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline ::rocos::SE3Pose* Path_PathEntry::release_pose() {
  // @@protoc_insertion_point(field_release:rocos.Path.PathEntry.pose)
  if (_internal_has_pose()) {
    clear_has_param();
      ::rocos::SE3Pose* temp = param_.pose_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    param_.pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SE3Pose& Path_PathEntry::_internal_pose() const {
  return _internal_has_pose()
      ? *param_.pose_
      : reinterpret_cast< ::rocos::SE3Pose&>(::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& Path_PathEntry::pose() const {
  // @@protoc_insertion_point(field_get:rocos.Path.PathEntry.pose)
  return _internal_pose();
}
inline ::rocos::SE3Pose* Path_PathEntry::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.Path.PathEntry.pose)
  if (_internal_has_pose()) {
    clear_has_param();
    ::rocos::SE3Pose* temp = param_.pose_;
    param_.pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Path_PathEntry::unsafe_arena_set_allocated_pose(::rocos::SE3Pose* pose) {
  clear_param();
  if (pose) {
    set_has_pose();
    param_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Path.PathEntry.pose)
}
inline ::rocos::SE3Pose* Path_PathEntry::_internal_mutable_pose() {
  if (!_internal_has_pose()) {
    clear_param();
    set_has_pose();
    param_.pose_ = CreateMaybeMessage< ::rocos::SE3Pose >(GetArenaForAllocation());
  }
  return param_.pose_;
}
inline ::rocos::SE3Pose* Path_PathEntry::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.Path.PathEntry.pose)
  return _msg;
}

inline bool Path_PathEntry::has_param() const {
  return param_case() != PARAM_NOT_SET;
}
inline void Path_PathEntry::clear_has_param() {
  _oneof_case_[0] = PARAM_NOT_SET;
}
inline Path_PathEntry::ParamCase Path_PathEntry::param_case() const {
  return Path_PathEntry::ParamCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Path

// repeated .rocos.Path.PathEntry waypoints = 1;
inline int Path::_internal_waypoints_size() const {
  return waypoints_.size();
}
inline int Path::waypoints_size() const {
  return _internal_waypoints_size();
}
inline void Path::clear_waypoints() {
  waypoints_.Clear();
}
inline ::rocos::Path_PathEntry* Path::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.Path.waypoints)
  return waypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Path_PathEntry >*
Path::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:rocos.Path.waypoints)
  return &waypoints_;
}
inline const ::rocos::Path_PathEntry& Path::_internal_waypoints(int index) const {
  return waypoints_.Get(index);
}
inline const ::rocos::Path_PathEntry& Path::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:rocos.Path.waypoints)
  return _internal_waypoints(index);
}
inline ::rocos::Path_PathEntry* Path::_internal_add_waypoints() {
  return waypoints_.Add();
}
inline ::rocos::Path_PathEntry* Path::add_waypoints() {
  ::rocos::Path_PathEntry* _add = _internal_add_waypoints();
  // @@protoc_insertion_point(field_add:rocos.Path.waypoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Path_PathEntry >&
Path::waypoints() const {
  // @@protoc_insertion_point(field_list:rocos.Path.waypoints)
  return waypoints_;
}

// -------------------------------------------------------------------

// MovePath

// .rocos.Path path = 1;
inline bool MovePath::_internal_has_path() const {
  return this != internal_default_instance() && path_ != nullptr;
}
inline bool MovePath::has_path() const {
  return _internal_has_path();
}
inline void MovePath::clear_path() {
  if (GetArenaForAllocation() == nullptr && path_ != nullptr) {
    delete path_;
  }
  path_ = nullptr;
}
inline const ::rocos::Path& MovePath::_internal_path() const {
  const ::rocos::Path* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Path&>(
      ::rocos::_Path_default_instance_);
}
inline const ::rocos::Path& MovePath::path() const {
  // @@protoc_insertion_point(field_get:rocos.MovePath.path)
  return _internal_path();
}
inline void MovePath::unsafe_arena_set_allocated_path(
    ::rocos::Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MovePath.path)
}
inline ::rocos::Path* MovePath::release_path() {
  
  ::rocos::Path* temp = path_;
  path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Path* MovePath::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:rocos.MovePath.path)
  
  ::rocos::Path* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::rocos::Path* MovePath::_internal_mutable_path() {
  
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Path>(GetArenaForAllocation());
    path_ = p;
  }
  return path_;
}
inline ::rocos::Path* MovePath::mutable_path() {
  ::rocos::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:rocos.MovePath.path)
  return _msg;
}
inline void MovePath::set_allocated_path(::rocos::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Path>::GetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:rocos.MovePath.path)
}

// bool asynchronous = 2;
inline void MovePath::clear_asynchronous() {
  asynchronous_ = false;
}
inline bool MovePath::_internal_asynchronous() const {
  return asynchronous_;
}
inline bool MovePath::asynchronous() const {
  // @@protoc_insertion_point(field_get:rocos.MovePath.asynchronous)
  return _internal_asynchronous();
}
inline void MovePath::_internal_set_asynchronous(bool value) {
  
  asynchronous_ = value;
}
inline void MovePath::set_asynchronous(bool value) {
  _internal_set_asynchronous(value);
  // @@protoc_insertion_point(field_set:rocos.MovePath.asynchronous)
}

// -------------------------------------------------------------------

// MotionCommand

// .rocos.MoveJ move_j = 1;
inline bool MotionCommand::_internal_has_move_j() const {
  return command_case() == kMoveJ;
}
inline bool MotionCommand::has_move_j() const {
  return _internal_has_move_j();
}
inline void MotionCommand::set_has_move_j() {
  _oneof_case_[0] = kMoveJ;
}
inline void MotionCommand::clear_move_j() {
  if (_internal_has_move_j()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_j_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveJ* MotionCommand::release_move_j() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_j)
  if (_internal_has_move_j()) {
    clear_has_command();
      ::rocos::MoveJ* temp = command_.move_j_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_j_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveJ& MotionCommand::_internal_move_j() const {
  return _internal_has_move_j()
      ? *command_.move_j_
      : reinterpret_cast< ::rocos::MoveJ&>(::rocos::_MoveJ_default_instance_);
}
inline const ::rocos::MoveJ& MotionCommand::move_j() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_j)
  return _internal_move_j();
}
inline ::rocos::MoveJ* MotionCommand::unsafe_arena_release_move_j() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_j)
  if (_internal_has_move_j()) {
    clear_has_command();
    ::rocos::MoveJ* temp = command_.move_j_;
    command_.move_j_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_j(::rocos::MoveJ* move_j) {
  clear_command();
  if (move_j) {
    set_has_move_j();
    command_.move_j_ = move_j;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_j)
}
inline ::rocos::MoveJ* MotionCommand::_internal_mutable_move_j() {
  if (!_internal_has_move_j()) {
    clear_command();
    set_has_move_j();
    command_.move_j_ = CreateMaybeMessage< ::rocos::MoveJ >(GetArenaForAllocation());
  }
  return command_.move_j_;
}
inline ::rocos::MoveJ* MotionCommand::mutable_move_j() {
  ::rocos::MoveJ* _msg = _internal_mutable_move_j();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_j)
  return _msg;
}

// .rocos.MoveJ_IK move_j_ik = 2;
inline bool MotionCommand::_internal_has_move_j_ik() const {
  return command_case() == kMoveJIk;
}
inline bool MotionCommand::has_move_j_ik() const {
  return _internal_has_move_j_ik();
}
inline void MotionCommand::set_has_move_j_ik() {
  _oneof_case_[0] = kMoveJIk;
}
inline void MotionCommand::clear_move_j_ik() {
  if (_internal_has_move_j_ik()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_j_ik_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveJ_IK* MotionCommand::release_move_j_ik() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_j_ik)
  if (_internal_has_move_j_ik()) {
    clear_has_command();
      ::rocos::MoveJ_IK* temp = command_.move_j_ik_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_j_ik_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveJ_IK& MotionCommand::_internal_move_j_ik() const {
  return _internal_has_move_j_ik()
      ? *command_.move_j_ik_
      : reinterpret_cast< ::rocos::MoveJ_IK&>(::rocos::_MoveJ_IK_default_instance_);
}
inline const ::rocos::MoveJ_IK& MotionCommand::move_j_ik() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_j_ik)
  return _internal_move_j_ik();
}
inline ::rocos::MoveJ_IK* MotionCommand::unsafe_arena_release_move_j_ik() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_j_ik)
  if (_internal_has_move_j_ik()) {
    clear_has_command();
    ::rocos::MoveJ_IK* temp = command_.move_j_ik_;
    command_.move_j_ik_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_j_ik(::rocos::MoveJ_IK* move_j_ik) {
  clear_command();
  if (move_j_ik) {
    set_has_move_j_ik();
    command_.move_j_ik_ = move_j_ik;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_j_ik)
}
inline ::rocos::MoveJ_IK* MotionCommand::_internal_mutable_move_j_ik() {
  if (!_internal_has_move_j_ik()) {
    clear_command();
    set_has_move_j_ik();
    command_.move_j_ik_ = CreateMaybeMessage< ::rocos::MoveJ_IK >(GetArenaForAllocation());
  }
  return command_.move_j_ik_;
}
inline ::rocos::MoveJ_IK* MotionCommand::mutable_move_j_ik() {
  ::rocos::MoveJ_IK* _msg = _internal_mutable_move_j_ik();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_j_ik)
  return _msg;
}

// .rocos.MoveL move_l = 3;
inline bool MotionCommand::_internal_has_move_l() const {
  return command_case() == kMoveL;
}
inline bool MotionCommand::has_move_l() const {
  return _internal_has_move_l();
}
inline void MotionCommand::set_has_move_l() {
  _oneof_case_[0] = kMoveL;
}
inline void MotionCommand::clear_move_l() {
  if (_internal_has_move_l()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_l_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveL* MotionCommand::release_move_l() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_l)
  if (_internal_has_move_l()) {
    clear_has_command();
      ::rocos::MoveL* temp = command_.move_l_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_l_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveL& MotionCommand::_internal_move_l() const {
  return _internal_has_move_l()
      ? *command_.move_l_
      : reinterpret_cast< ::rocos::MoveL&>(::rocos::_MoveL_default_instance_);
}
inline const ::rocos::MoveL& MotionCommand::move_l() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_l)
  return _internal_move_l();
}
inline ::rocos::MoveL* MotionCommand::unsafe_arena_release_move_l() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_l)
  if (_internal_has_move_l()) {
    clear_has_command();
    ::rocos::MoveL* temp = command_.move_l_;
    command_.move_l_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_l(::rocos::MoveL* move_l) {
  clear_command();
  if (move_l) {
    set_has_move_l();
    command_.move_l_ = move_l;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_l)
}
inline ::rocos::MoveL* MotionCommand::_internal_mutable_move_l() {
  if (!_internal_has_move_l()) {
    clear_command();
    set_has_move_l();
    command_.move_l_ = CreateMaybeMessage< ::rocos::MoveL >(GetArenaForAllocation());
  }
  return command_.move_l_;
}
inline ::rocos::MoveL* MotionCommand::mutable_move_l() {
  ::rocos::MoveL* _msg = _internal_mutable_move_l();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_l)
  return _msg;
}

// .rocos.MoveL_FK move_l_fk = 4;
inline bool MotionCommand::_internal_has_move_l_fk() const {
  return command_case() == kMoveLFk;
}
inline bool MotionCommand::has_move_l_fk() const {
  return _internal_has_move_l_fk();
}
inline void MotionCommand::set_has_move_l_fk() {
  _oneof_case_[0] = kMoveLFk;
}
inline void MotionCommand::clear_move_l_fk() {
  if (_internal_has_move_l_fk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_l_fk_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveL_FK* MotionCommand::release_move_l_fk() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_l_fk)
  if (_internal_has_move_l_fk()) {
    clear_has_command();
      ::rocos::MoveL_FK* temp = command_.move_l_fk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_l_fk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveL_FK& MotionCommand::_internal_move_l_fk() const {
  return _internal_has_move_l_fk()
      ? *command_.move_l_fk_
      : reinterpret_cast< ::rocos::MoveL_FK&>(::rocos::_MoveL_FK_default_instance_);
}
inline const ::rocos::MoveL_FK& MotionCommand::move_l_fk() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_l_fk)
  return _internal_move_l_fk();
}
inline ::rocos::MoveL_FK* MotionCommand::unsafe_arena_release_move_l_fk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_l_fk)
  if (_internal_has_move_l_fk()) {
    clear_has_command();
    ::rocos::MoveL_FK* temp = command_.move_l_fk_;
    command_.move_l_fk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_l_fk(::rocos::MoveL_FK* move_l_fk) {
  clear_command();
  if (move_l_fk) {
    set_has_move_l_fk();
    command_.move_l_fk_ = move_l_fk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_l_fk)
}
inline ::rocos::MoveL_FK* MotionCommand::_internal_mutable_move_l_fk() {
  if (!_internal_has_move_l_fk()) {
    clear_command();
    set_has_move_l_fk();
    command_.move_l_fk_ = CreateMaybeMessage< ::rocos::MoveL_FK >(GetArenaForAllocation());
  }
  return command_.move_l_fk_;
}
inline ::rocos::MoveL_FK* MotionCommand::mutable_move_l_fk() {
  ::rocos::MoveL_FK* _msg = _internal_mutable_move_l_fk();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_l_fk)
  return _msg;
}

// .rocos.MoveC move_c = 5;
inline bool MotionCommand::_internal_has_move_c() const {
  return command_case() == kMoveC;
}
inline bool MotionCommand::has_move_c() const {
  return _internal_has_move_c();
}
inline void MotionCommand::set_has_move_c() {
  _oneof_case_[0] = kMoveC;
}
inline void MotionCommand::clear_move_c() {
  if (_internal_has_move_c()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_c_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveC* MotionCommand::release_move_c() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_c)
  if (_internal_has_move_c()) {
    clear_has_command();
      ::rocos::MoveC* temp = command_.move_c_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_c_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveC& MotionCommand::_internal_move_c() const {
  return _internal_has_move_c()
      ? *command_.move_c_
      : reinterpret_cast< ::rocos::MoveC&>(::rocos::_MoveC_default_instance_);
}
inline const ::rocos::MoveC& MotionCommand::move_c() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_c)
  return _internal_move_c();
}
inline ::rocos::MoveC* MotionCommand::unsafe_arena_release_move_c() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_c)
  if (_internal_has_move_c()) {
    clear_has_command();
    ::rocos::MoveC* temp = command_.move_c_;
    command_.move_c_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_c(::rocos::MoveC* move_c) {
  clear_command();
  if (move_c) {
    set_has_move_c();
    command_.move_c_ = move_c;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_c)
}
inline ::rocos::MoveC* MotionCommand::_internal_mutable_move_c() {
  if (!_internal_has_move_c()) {
    clear_command();
    set_has_move_c();
    command_.move_c_ = CreateMaybeMessage< ::rocos::MoveC >(GetArenaForAllocation());
  }
  return command_.move_c_;
}
inline ::rocos::MoveC* MotionCommand::mutable_move_c() {
  ::rocos::MoveC* _msg = _internal_mutable_move_c();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_c)
  return _msg;
}

// .rocos.MoveP move_p = 6;
inline bool MotionCommand::_internal_has_move_p() const {
  return command_case() == kMoveP;
}
inline bool MotionCommand::has_move_p() const {
  return _internal_has_move_p();
}
inline void MotionCommand::set_has_move_p() {
  _oneof_case_[0] = kMoveP;
}
inline void MotionCommand::clear_move_p() {
  if (_internal_has_move_p()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_p_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveP* MotionCommand::release_move_p() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_p)
  if (_internal_has_move_p()) {
    clear_has_command();
      ::rocos::MoveP* temp = command_.move_p_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_p_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveP& MotionCommand::_internal_move_p() const {
  return _internal_has_move_p()
      ? *command_.move_p_
      : reinterpret_cast< ::rocos::MoveP&>(::rocos::_MoveP_default_instance_);
}
inline const ::rocos::MoveP& MotionCommand::move_p() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_p)
  return _internal_move_p();
}
inline ::rocos::MoveP* MotionCommand::unsafe_arena_release_move_p() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_p)
  if (_internal_has_move_p()) {
    clear_has_command();
    ::rocos::MoveP* temp = command_.move_p_;
    command_.move_p_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_p(::rocos::MoveP* move_p) {
  clear_command();
  if (move_p) {
    set_has_move_p();
    command_.move_p_ = move_p;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_p)
}
inline ::rocos::MoveP* MotionCommand::_internal_mutable_move_p() {
  if (!_internal_has_move_p()) {
    clear_command();
    set_has_move_p();
    command_.move_p_ = CreateMaybeMessage< ::rocos::MoveP >(GetArenaForAllocation());
  }
  return command_.move_p_;
}
inline ::rocos::MoveP* MotionCommand::mutable_move_p() {
  ::rocos::MoveP* _msg = _internal_mutable_move_p();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_p)
  return _msg;
}

// .rocos.MovePath move_path = 7;
inline bool MotionCommand::_internal_has_move_path() const {
  return command_case() == kMovePath;
}
inline bool MotionCommand::has_move_path() const {
  return _internal_has_move_path();
}
inline void MotionCommand::set_has_move_path() {
  _oneof_case_[0] = kMovePath;
}
inline void MotionCommand::clear_move_path() {
  if (_internal_has_move_path()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_path_;
    }
    clear_has_command();
  }
}
inline ::rocos::MovePath* MotionCommand::release_move_path() {
  // @@protoc_insertion_point(field_release:rocos.MotionCommand.move_path)
  if (_internal_has_move_path()) {
    clear_has_command();
      ::rocos::MovePath* temp = command_.move_path_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MovePath& MotionCommand::_internal_move_path() const {
  return _internal_has_move_path()
      ? *command_.move_path_
      : reinterpret_cast< ::rocos::MovePath&>(::rocos::_MovePath_default_instance_);
}
inline const ::rocos::MovePath& MotionCommand::move_path() const {
  // @@protoc_insertion_point(field_get:rocos.MotionCommand.move_path)
  return _internal_move_path();
}
inline ::rocos::MovePath* MotionCommand::unsafe_arena_release_move_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.MotionCommand.move_path)
  if (_internal_has_move_path()) {
    clear_has_command();
    ::rocos::MovePath* temp = command_.move_path_;
    command_.move_path_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotionCommand::unsafe_arena_set_allocated_move_path(::rocos::MovePath* move_path) {
  clear_command();
  if (move_path) {
    set_has_move_path();
    command_.move_path_ = move_path;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.MotionCommand.move_path)
}
inline ::rocos::MovePath* MotionCommand::_internal_mutable_move_path() {
  if (!_internal_has_move_path()) {
    clear_command();
    set_has_move_path();
    command_.move_path_ = CreateMaybeMessage< ::rocos::MovePath >(GetArenaForAllocation());
  }
  return command_.move_path_;
}
inline ::rocos::MovePath* MotionCommand::mutable_move_path() {
  ::rocos::MovePath* _msg = _internal_mutable_move_path();
  // @@protoc_insertion_point(field_mutable:rocos.MotionCommand.move_path)
  return _msg;
}

inline bool MotionCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void MotionCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline MotionCommand::CommandCase MotionCommand::command_case() const {
  return MotionCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DraggingCommand

// .rocos.DraggingFlag flag = 1;
inline void DraggingCommand::clear_flag() {
  flag_ = 0;
}
inline ::rocos::DraggingFlag DraggingCommand::_internal_flag() const {
  return static_cast< ::rocos::DraggingFlag >(flag_);
}
inline ::rocos::DraggingFlag DraggingCommand::flag() const {
  // @@protoc_insertion_point(field_get:rocos.DraggingCommand.flag)
  return _internal_flag();
}
inline void DraggingCommand::_internal_set_flag(::rocos::DraggingFlag value) {
  
  flag_ = value;
}
inline void DraggingCommand::set_flag(::rocos::DraggingFlag value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:rocos.DraggingCommand.flag)
}

// .rocos.DraggingDirection dir = 2;
inline void DraggingCommand::clear_dir() {
  dir_ = 0;
}
inline ::rocos::DraggingDirection DraggingCommand::_internal_dir() const {
  return static_cast< ::rocos::DraggingDirection >(dir_);
}
inline ::rocos::DraggingDirection DraggingCommand::dir() const {
  // @@protoc_insertion_point(field_get:rocos.DraggingCommand.dir)
  return _internal_dir();
}
inline void DraggingCommand::_internal_set_dir(::rocos::DraggingDirection value) {
  
  dir_ = value;
}
inline void DraggingCommand::set_dir(::rocos::DraggingDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:rocos.DraggingCommand.dir)
}

// double max_speed = 3;
inline void DraggingCommand::clear_max_speed() {
  max_speed_ = 0;
}
inline double DraggingCommand::_internal_max_speed() const {
  return max_speed_;
}
inline double DraggingCommand::max_speed() const {
  // @@protoc_insertion_point(field_get:rocos.DraggingCommand.max_speed)
  return _internal_max_speed();
}
inline void DraggingCommand::_internal_set_max_speed(double value) {
  
  max_speed_ = value;
}
inline void DraggingCommand::set_max_speed(double value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:rocos.DraggingCommand.max_speed)
}

// double max_acceleration = 4;
inline void DraggingCommand::clear_max_acceleration() {
  max_acceleration_ = 0;
}
inline double DraggingCommand::_internal_max_acceleration() const {
  return max_acceleration_;
}
inline double DraggingCommand::max_acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.DraggingCommand.max_acceleration)
  return _internal_max_acceleration();
}
inline void DraggingCommand::_internal_set_max_acceleration(double value) {
  
  max_acceleration_ = value;
}
inline void DraggingCommand::set_max_acceleration(double value) {
  _internal_set_max_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.DraggingCommand.max_acceleration)
}

// -------------------------------------------------------------------

// RobotCommand

// .rocos.Enabled enabled = 1;
inline bool RobotCommand::_internal_has_enabled() const {
  return command_case() == kEnabled;
}
inline bool RobotCommand::has_enabled() const {
  return _internal_has_enabled();
}
inline void RobotCommand::set_has_enabled() {
  _oneof_case_[0] = kEnabled;
}
inline void RobotCommand::clear_enabled() {
  if (_internal_has_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.enabled_;
    }
    clear_has_command();
  }
}
inline ::rocos::Enabled* RobotCommand::release_enabled() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.enabled)
  if (_internal_has_enabled()) {
    clear_has_command();
      ::rocos::Enabled* temp = command_.enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::Enabled& RobotCommand::_internal_enabled() const {
  return _internal_has_enabled()
      ? *command_.enabled_
      : reinterpret_cast< ::rocos::Enabled&>(::rocos::_Enabled_default_instance_);
}
inline const ::rocos::Enabled& RobotCommand::enabled() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.enabled)
  return _internal_enabled();
}
inline ::rocos::Enabled* RobotCommand::unsafe_arena_release_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.enabled)
  if (_internal_has_enabled()) {
    clear_has_command();
    ::rocos::Enabled* temp = command_.enabled_;
    command_.enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_enabled(::rocos::Enabled* enabled) {
  clear_command();
  if (enabled) {
    set_has_enabled();
    command_.enabled_ = enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.enabled)
}
inline ::rocos::Enabled* RobotCommand::_internal_mutable_enabled() {
  if (!_internal_has_enabled()) {
    clear_command();
    set_has_enabled();
    command_.enabled_ = CreateMaybeMessage< ::rocos::Enabled >(GetArenaForAllocation());
  }
  return command_.enabled_;
}
inline ::rocos::Enabled* RobotCommand::mutable_enabled() {
  ::rocos::Enabled* _msg = _internal_mutable_enabled();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.enabled)
  return _msg;
}

// .rocos.Disabled disabled = 2;
inline bool RobotCommand::_internal_has_disabled() const {
  return command_case() == kDisabled;
}
inline bool RobotCommand::has_disabled() const {
  return _internal_has_disabled();
}
inline void RobotCommand::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
inline void RobotCommand::clear_disabled() {
  if (_internal_has_disabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.disabled_;
    }
    clear_has_command();
  }
}
inline ::rocos::Disabled* RobotCommand::release_disabled() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.disabled)
  if (_internal_has_disabled()) {
    clear_has_command();
      ::rocos::Disabled* temp = command_.disabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::Disabled& RobotCommand::_internal_disabled() const {
  return _internal_has_disabled()
      ? *command_.disabled_
      : reinterpret_cast< ::rocos::Disabled&>(::rocos::_Disabled_default_instance_);
}
inline const ::rocos::Disabled& RobotCommand::disabled() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.disabled)
  return _internal_disabled();
}
inline ::rocos::Disabled* RobotCommand::unsafe_arena_release_disabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.disabled)
  if (_internal_has_disabled()) {
    clear_has_command();
    ::rocos::Disabled* temp = command_.disabled_;
    command_.disabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_disabled(::rocos::Disabled* disabled) {
  clear_command();
  if (disabled) {
    set_has_disabled();
    command_.disabled_ = disabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.disabled)
}
inline ::rocos::Disabled* RobotCommand::_internal_mutable_disabled() {
  if (!_internal_has_disabled()) {
    clear_command();
    set_has_disabled();
    command_.disabled_ = CreateMaybeMessage< ::rocos::Disabled >(GetArenaForAllocation());
  }
  return command_.disabled_;
}
inline ::rocos::Disabled* RobotCommand::mutable_disabled() {
  ::rocos::Disabled* _msg = _internal_mutable_disabled();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.disabled)
  return _msg;
}

// .rocos.MoveJ move_j = 3;
inline bool RobotCommand::_internal_has_move_j() const {
  return command_case() == kMoveJ;
}
inline bool RobotCommand::has_move_j() const {
  return _internal_has_move_j();
}
inline void RobotCommand::set_has_move_j() {
  _oneof_case_[0] = kMoveJ;
}
inline void RobotCommand::clear_move_j() {
  if (_internal_has_move_j()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.move_j_;
    }
    clear_has_command();
  }
}
inline ::rocos::MoveJ* RobotCommand::release_move_j() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.move_j)
  if (_internal_has_move_j()) {
    clear_has_command();
      ::rocos::MoveJ* temp = command_.move_j_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.move_j_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MoveJ& RobotCommand::_internal_move_j() const {
  return _internal_has_move_j()
      ? *command_.move_j_
      : reinterpret_cast< ::rocos::MoveJ&>(::rocos::_MoveJ_default_instance_);
}
inline const ::rocos::MoveJ& RobotCommand::move_j() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.move_j)
  return _internal_move_j();
}
inline ::rocos::MoveJ* RobotCommand::unsafe_arena_release_move_j() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.move_j)
  if (_internal_has_move_j()) {
    clear_has_command();
    ::rocos::MoveJ* temp = command_.move_j_;
    command_.move_j_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_move_j(::rocos::MoveJ* move_j) {
  clear_command();
  if (move_j) {
    set_has_move_j();
    command_.move_j_ = move_j;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.move_j)
}
inline ::rocos::MoveJ* RobotCommand::_internal_mutable_move_j() {
  if (!_internal_has_move_j()) {
    clear_command();
    set_has_move_j();
    command_.move_j_ = CreateMaybeMessage< ::rocos::MoveJ >(GetArenaForAllocation());
  }
  return command_.move_j_;
}
inline ::rocos::MoveJ* RobotCommand::mutable_move_j() {
  ::rocos::MoveJ* _msg = _internal_mutable_move_j();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.move_j)
  return _msg;
}

// .rocos.SingleAxisCommand single_axis_command = 4;
inline bool RobotCommand::_internal_has_single_axis_command() const {
  return command_case() == kSingleAxisCommand;
}
inline bool RobotCommand::has_single_axis_command() const {
  return _internal_has_single_axis_command();
}
inline void RobotCommand::set_has_single_axis_command() {
  _oneof_case_[0] = kSingleAxisCommand;
}
inline void RobotCommand::clear_single_axis_command() {
  if (_internal_has_single_axis_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.single_axis_command_;
    }
    clear_has_command();
  }
}
inline ::rocos::SingleAxisCommand* RobotCommand::release_single_axis_command() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.single_axis_command)
  if (_internal_has_single_axis_command()) {
    clear_has_command();
      ::rocos::SingleAxisCommand* temp = command_.single_axis_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.single_axis_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::SingleAxisCommand& RobotCommand::_internal_single_axis_command() const {
  return _internal_has_single_axis_command()
      ? *command_.single_axis_command_
      : reinterpret_cast< ::rocos::SingleAxisCommand&>(::rocos::_SingleAxisCommand_default_instance_);
}
inline const ::rocos::SingleAxisCommand& RobotCommand::single_axis_command() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.single_axis_command)
  return _internal_single_axis_command();
}
inline ::rocos::SingleAxisCommand* RobotCommand::unsafe_arena_release_single_axis_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.single_axis_command)
  if (_internal_has_single_axis_command()) {
    clear_has_command();
    ::rocos::SingleAxisCommand* temp = command_.single_axis_command_;
    command_.single_axis_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_single_axis_command(::rocos::SingleAxisCommand* single_axis_command) {
  clear_command();
  if (single_axis_command) {
    set_has_single_axis_command();
    command_.single_axis_command_ = single_axis_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.single_axis_command)
}
inline ::rocos::SingleAxisCommand* RobotCommand::_internal_mutable_single_axis_command() {
  if (!_internal_has_single_axis_command()) {
    clear_command();
    set_has_single_axis_command();
    command_.single_axis_command_ = CreateMaybeMessage< ::rocos::SingleAxisCommand >(GetArenaForAllocation());
  }
  return command_.single_axis_command_;
}
inline ::rocos::SingleAxisCommand* RobotCommand::mutable_single_axis_command() {
  ::rocos::SingleAxisCommand* _msg = _internal_mutable_single_axis_command();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.single_axis_command)
  return _msg;
}

// .rocos.MultiAxisCommand multi_axis_command = 5;
inline bool RobotCommand::_internal_has_multi_axis_command() const {
  return command_case() == kMultiAxisCommand;
}
inline bool RobotCommand::has_multi_axis_command() const {
  return _internal_has_multi_axis_command();
}
inline void RobotCommand::set_has_multi_axis_command() {
  _oneof_case_[0] = kMultiAxisCommand;
}
inline void RobotCommand::clear_multi_axis_command() {
  if (_internal_has_multi_axis_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.multi_axis_command_;
    }
    clear_has_command();
  }
}
inline ::rocos::MultiAxisCommand* RobotCommand::release_multi_axis_command() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.multi_axis_command)
  if (_internal_has_multi_axis_command()) {
    clear_has_command();
      ::rocos::MultiAxisCommand* temp = command_.multi_axis_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.multi_axis_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MultiAxisCommand& RobotCommand::_internal_multi_axis_command() const {
  return _internal_has_multi_axis_command()
      ? *command_.multi_axis_command_
      : reinterpret_cast< ::rocos::MultiAxisCommand&>(::rocos::_MultiAxisCommand_default_instance_);
}
inline const ::rocos::MultiAxisCommand& RobotCommand::multi_axis_command() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.multi_axis_command)
  return _internal_multi_axis_command();
}
inline ::rocos::MultiAxisCommand* RobotCommand::unsafe_arena_release_multi_axis_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.multi_axis_command)
  if (_internal_has_multi_axis_command()) {
    clear_has_command();
    ::rocos::MultiAxisCommand* temp = command_.multi_axis_command_;
    command_.multi_axis_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_multi_axis_command(::rocos::MultiAxisCommand* multi_axis_command) {
  clear_command();
  if (multi_axis_command) {
    set_has_multi_axis_command();
    command_.multi_axis_command_ = multi_axis_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.multi_axis_command)
}
inline ::rocos::MultiAxisCommand* RobotCommand::_internal_mutable_multi_axis_command() {
  if (!_internal_has_multi_axis_command()) {
    clear_command();
    set_has_multi_axis_command();
    command_.multi_axis_command_ = CreateMaybeMessage< ::rocos::MultiAxisCommand >(GetArenaForAllocation());
  }
  return command_.multi_axis_command_;
}
inline ::rocos::MultiAxisCommand* RobotCommand::mutable_multi_axis_command() {
  ::rocos::MultiAxisCommand* _msg = _internal_mutable_multi_axis_command();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.multi_axis_command)
  return _msg;
}

// .rocos.MotionCommand motion_command = 6;
inline bool RobotCommand::_internal_has_motion_command() const {
  return command_case() == kMotionCommand;
}
inline bool RobotCommand::has_motion_command() const {
  return _internal_has_motion_command();
}
inline void RobotCommand::set_has_motion_command() {
  _oneof_case_[0] = kMotionCommand;
}
inline void RobotCommand::clear_motion_command() {
  if (_internal_has_motion_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.motion_command_;
    }
    clear_has_command();
  }
}
inline ::rocos::MotionCommand* RobotCommand::release_motion_command() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.motion_command)
  if (_internal_has_motion_command()) {
    clear_has_command();
      ::rocos::MotionCommand* temp = command_.motion_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.motion_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::MotionCommand& RobotCommand::_internal_motion_command() const {
  return _internal_has_motion_command()
      ? *command_.motion_command_
      : reinterpret_cast< ::rocos::MotionCommand&>(::rocos::_MotionCommand_default_instance_);
}
inline const ::rocos::MotionCommand& RobotCommand::motion_command() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.motion_command)
  return _internal_motion_command();
}
inline ::rocos::MotionCommand* RobotCommand::unsafe_arena_release_motion_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.motion_command)
  if (_internal_has_motion_command()) {
    clear_has_command();
    ::rocos::MotionCommand* temp = command_.motion_command_;
    command_.motion_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_motion_command(::rocos::MotionCommand* motion_command) {
  clear_command();
  if (motion_command) {
    set_has_motion_command();
    command_.motion_command_ = motion_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.motion_command)
}
inline ::rocos::MotionCommand* RobotCommand::_internal_mutable_motion_command() {
  if (!_internal_has_motion_command()) {
    clear_command();
    set_has_motion_command();
    command_.motion_command_ = CreateMaybeMessage< ::rocos::MotionCommand >(GetArenaForAllocation());
  }
  return command_.motion_command_;
}
inline ::rocos::MotionCommand* RobotCommand::mutable_motion_command() {
  ::rocos::MotionCommand* _msg = _internal_mutable_motion_command();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.motion_command)
  return _msg;
}

// .rocos.DraggingCommand dragging_command = 7;
inline bool RobotCommand::_internal_has_dragging_command() const {
  return command_case() == kDraggingCommand;
}
inline bool RobotCommand::has_dragging_command() const {
  return _internal_has_dragging_command();
}
inline void RobotCommand::set_has_dragging_command() {
  _oneof_case_[0] = kDraggingCommand;
}
inline void RobotCommand::clear_dragging_command() {
  if (_internal_has_dragging_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.dragging_command_;
    }
    clear_has_command();
  }
}
inline ::rocos::DraggingCommand* RobotCommand::release_dragging_command() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommand.dragging_command)
  if (_internal_has_dragging_command()) {
    clear_has_command();
      ::rocos::DraggingCommand* temp = command_.dragging_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.dragging_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::DraggingCommand& RobotCommand::_internal_dragging_command() const {
  return _internal_has_dragging_command()
      ? *command_.dragging_command_
      : reinterpret_cast< ::rocos::DraggingCommand&>(::rocos::_DraggingCommand_default_instance_);
}
inline const ::rocos::DraggingCommand& RobotCommand::dragging_command() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommand.dragging_command)
  return _internal_dragging_command();
}
inline ::rocos::DraggingCommand* RobotCommand::unsafe_arena_release_dragging_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.RobotCommand.dragging_command)
  if (_internal_has_dragging_command()) {
    clear_has_command();
    ::rocos::DraggingCommand* temp = command_.dragging_command_;
    command_.dragging_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_dragging_command(::rocos::DraggingCommand* dragging_command) {
  clear_command();
  if (dragging_command) {
    set_has_dragging_command();
    command_.dragging_command_ = dragging_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommand.dragging_command)
}
inline ::rocos::DraggingCommand* RobotCommand::_internal_mutable_dragging_command() {
  if (!_internal_has_dragging_command()) {
    clear_command();
    set_has_dragging_command();
    command_.dragging_command_ = CreateMaybeMessage< ::rocos::DraggingCommand >(GetArenaForAllocation());
  }
  return command_.dragging_command_;
}
inline ::rocos::DraggingCommand* RobotCommand::mutable_dragging_command() {
  ::rocos::DraggingCommand* _msg = _internal_mutable_dragging_command();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommand.dragging_command)
  return _msg;
}

inline bool RobotCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void RobotCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline RobotCommand::CommandCase RobotCommand::command_case() const {
  return RobotCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RobotCommandRequest

// .rocos.RequestHeader header = 1;
inline bool RobotCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::rocos::RequestHeader& RobotCommandRequest::_internal_header() const {
  const ::rocos::RequestHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::RequestHeader&>(
      ::rocos::_RequestHeader_default_instance_);
}
inline const ::rocos::RequestHeader& RobotCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommandRequest.header)
  return _internal_header();
}
inline void RobotCommandRequest::unsafe_arena_set_allocated_header(
    ::rocos::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommandRequest.header)
}
inline ::rocos::RequestHeader* RobotCommandRequest::release_header() {
  
  ::rocos::RequestHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::RequestHeader* RobotCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommandRequest.header)
  
  ::rocos::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::rocos::RequestHeader* RobotCommandRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::RequestHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::rocos::RequestHeader* RobotCommandRequest::mutable_header() {
  ::rocos::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommandRequest.header)
  return _msg;
}
inline void RobotCommandRequest::set_allocated_header(::rocos::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotCommandRequest.header)
}

// .rocos.RobotCommand command = 2;
inline bool RobotCommandRequest::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool RobotCommandRequest::has_command() const {
  return _internal_has_command();
}
inline void RobotCommandRequest::clear_command() {
  if (GetArenaForAllocation() == nullptr && command_ != nullptr) {
    delete command_;
  }
  command_ = nullptr;
}
inline const ::rocos::RobotCommand& RobotCommandRequest::_internal_command() const {
  const ::rocos::RobotCommand* p = command_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::RobotCommand&>(
      ::rocos::_RobotCommand_default_instance_);
}
inline const ::rocos::RobotCommand& RobotCommandRequest::command() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommandRequest.command)
  return _internal_command();
}
inline void RobotCommandRequest::unsafe_arena_set_allocated_command(
    ::rocos::RobotCommand* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommandRequest.command)
}
inline ::rocos::RobotCommand* RobotCommandRequest::release_command() {
  
  ::rocos::RobotCommand* temp = command_;
  command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::RobotCommand* RobotCommandRequest::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommandRequest.command)
  
  ::rocos::RobotCommand* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::rocos::RobotCommand* RobotCommandRequest::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::RobotCommand>(GetArenaForAllocation());
    command_ = p;
  }
  return command_;
}
inline ::rocos::RobotCommand* RobotCommandRequest::mutable_command() {
  ::rocos::RobotCommand* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommandRequest.command)
  return _msg;
}
inline void RobotCommandRequest::set_allocated_command(::rocos::RobotCommand* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::RobotCommand>::GetOwningArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotCommandRequest.command)
}

// -------------------------------------------------------------------

// RobotCommandResponse

// .rocos.ResponseHeader header = 1;
inline bool RobotCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::rocos::ResponseHeader& RobotCommandResponse::_internal_header() const {
  const ::rocos::ResponseHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::ResponseHeader&>(
      ::rocos::_ResponseHeader_default_instance_);
}
inline const ::rocos::ResponseHeader& RobotCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:rocos.RobotCommandResponse.header)
  return _internal_header();
}
inline void RobotCommandResponse::unsafe_arena_set_allocated_header(
    ::rocos::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotCommandResponse.header)
}
inline ::rocos::ResponseHeader* RobotCommandResponse::release_header() {
  
  ::rocos::ResponseHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::ResponseHeader* RobotCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:rocos.RobotCommandResponse.header)
  
  ::rocos::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::rocos::ResponseHeader* RobotCommandResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::ResponseHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::rocos::ResponseHeader* RobotCommandResponse::mutable_header() {
  ::rocos::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:rocos.RobotCommandResponse.header)
  return _msg;
}
inline void RobotCommandResponse::set_allocated_header(::rocos::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotCommandResponse.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rocos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rocos::MoveC_OrientationMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::MoveC_OrientationMode>() {
  return ::rocos::MoveC_OrientationMode_descriptor();
}
template <> struct is_proto_enum< ::rocos::Path_PathEntry_MoveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::Path_PathEntry_MoveType>() {
  return ::rocos::Path_PathEntry_MoveType_descriptor();
}
template <> struct is_proto_enum< ::rocos::Synchronization> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::Synchronization>() {
  return ::rocos::Synchronization_descriptor();
}
template <> struct is_proto_enum< ::rocos::Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::Mode>() {
  return ::rocos::Mode_descriptor();
}
template <> struct is_proto_enum< ::rocos::DraggingFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::DraggingFlag>() {
  return ::rocos::DraggingFlag_descriptor();
}
template <> struct is_proto_enum< ::rocos::DraggingDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::DraggingDirection>() {
  return ::rocos::DraggingDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_5fcommand_2eproto
