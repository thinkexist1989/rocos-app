// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_state.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_5fstate_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_5fstate_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
#include "geometry.pb.h"
#include <google/protobuf/wrappers.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_5fstate_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_5fstate_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_5fstate_2eproto;
namespace rocos {
class BaseState;
struct BaseStateDefaultTypeInternal;
extern BaseStateDefaultTypeInternal _BaseState_default_instance_;
class FlangeState;
struct FlangeStateDefaultTypeInternal;
extern FlangeStateDefaultTypeInternal _FlangeState_default_instance_;
class HardwareState;
struct HardwareStateDefaultTypeInternal;
extern HardwareStateDefaultTypeInternal _HardwareState_default_instance_;
class JointState;
struct JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class ObjectState;
struct ObjectStateDefaultTypeInternal;
extern ObjectStateDefaultTypeInternal _ObjectState_default_instance_;
class RobotState;
struct RobotStateDefaultTypeInternal;
extern RobotStateDefaultTypeInternal _RobotState_default_instance_;
class RobotStateRequest;
struct RobotStateRequestDefaultTypeInternal;
extern RobotStateRequestDefaultTypeInternal _RobotStateRequest_default_instance_;
class RobotStateResponse;
struct RobotStateResponseDefaultTypeInternal;
extern RobotStateResponseDefaultTypeInternal _RobotStateResponse_default_instance_;
class ToolState;
struct ToolStateDefaultTypeInternal;
extern ToolStateDefaultTypeInternal _ToolState_default_instance_;
}  // namespace rocos
PROTOBUF_NAMESPACE_OPEN
template<> ::rocos::BaseState* Arena::CreateMaybeMessage<::rocos::BaseState>(Arena*);
template<> ::rocos::FlangeState* Arena::CreateMaybeMessage<::rocos::FlangeState>(Arena*);
template<> ::rocos::HardwareState* Arena::CreateMaybeMessage<::rocos::HardwareState>(Arena*);
template<> ::rocos::JointState* Arena::CreateMaybeMessage<::rocos::JointState>(Arena*);
template<> ::rocos::ObjectState* Arena::CreateMaybeMessage<::rocos::ObjectState>(Arena*);
template<> ::rocos::RobotState* Arena::CreateMaybeMessage<::rocos::RobotState>(Arena*);
template<> ::rocos::RobotStateRequest* Arena::CreateMaybeMessage<::rocos::RobotStateRequest>(Arena*);
template<> ::rocos::RobotStateResponse* Arena::CreateMaybeMessage<::rocos::RobotStateResponse>(Arena*);
template<> ::rocos::ToolState* Arena::CreateMaybeMessage<::rocos::ToolState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rocos {

enum JointState_Status : int {
  JointState_Status_STATUS_UNSPECIFIED = 0,
  JointState_Status_STATUS_DISABLED = 1,
  JointState_Status_STATUS_ENABLED = 2,
  JointState_Status_STATUS_FAULT = 3,
  JointState_Status_JointState_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JointState_Status_JointState_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JointState_Status_IsValid(int value);
constexpr JointState_Status JointState_Status_Status_MIN = JointState_Status_STATUS_UNSPECIFIED;
constexpr JointState_Status JointState_Status_Status_MAX = JointState_Status_STATUS_FAULT;
constexpr int JointState_Status_Status_ARRAYSIZE = JointState_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JointState_Status_descriptor();
template<typename T>
inline const std::string& JointState_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JointState_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JointState_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JointState_Status_descriptor(), enum_t_value);
}
inline bool JointState_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JointState_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JointState_Status>(
    JointState_Status_descriptor(), name, value);
}
enum HardwareState_HardwareType : int {
  HardwareState_HardwareType_HW_TYPE_UNKNOWN = 0,
  HardwareState_HardwareType_HW_TYPE_SIM = 1,
  HardwareState_HardwareType_HW_TYPE_ETHERCAT = 2,
  HardwareState_HardwareType_HW_TYPE_CAN = 3,
  HardwareState_HardwareType_HW_TYPE_PROFINET = 4,
  HardwareState_HardwareType_HardwareState_HardwareType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HardwareState_HardwareType_HardwareState_HardwareType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HardwareState_HardwareType_IsValid(int value);
constexpr HardwareState_HardwareType HardwareState_HardwareType_HardwareType_MIN = HardwareState_HardwareType_HW_TYPE_UNKNOWN;
constexpr HardwareState_HardwareType HardwareState_HardwareType_HardwareType_MAX = HardwareState_HardwareType_HW_TYPE_PROFINET;
constexpr int HardwareState_HardwareType_HardwareType_ARRAYSIZE = HardwareState_HardwareType_HardwareType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HardwareState_HardwareType_descriptor();
template<typename T>
inline const std::string& HardwareState_HardwareType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HardwareState_HardwareType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HardwareState_HardwareType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HardwareState_HardwareType_descriptor(), enum_t_value);
}
inline bool HardwareState_HardwareType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HardwareState_HardwareType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HardwareState_HardwareType>(
    HardwareState_HardwareType_descriptor(), name, value);
}
// ===================================================================

class JointState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.JointState) */ {
 public:
  inline JointState() : JointState(nullptr) {}
  ~JointState() override;
  explicit constexpr JointState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointState(const JointState& from);
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointState& operator=(JointState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointState& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }
  inline void Swap(JointState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointState* New() const final {
    return new JointState();
  }

  JointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JointState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.JointState";
  }
  protected:
  explicit JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef JointState_Status Status;
  static constexpr Status STATUS_UNSPECIFIED =
    JointState_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_DISABLED =
    JointState_Status_STATUS_DISABLED;
  static constexpr Status STATUS_ENABLED =
    JointState_Status_STATUS_ENABLED;
  static constexpr Status STATUS_FAULT =
    JointState_Status_STATUS_FAULT;
  static inline bool Status_IsValid(int value) {
    return JointState_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    JointState_Status_Status_MIN;
  static constexpr Status Status_MAX =
    JointState_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    JointState_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return JointState_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return JointState_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return JointState_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kLoadFieldNumber = 5,
    kStatusFieldNumber = 6,
    kRawDataFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double position = 2;
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // double velocity = 3;
  void clear_velocity();
  double velocity() const;
  void set_velocity(double value);
  private:
  double _internal_velocity() const;
  void _internal_set_velocity(double value);
  public:

  // double acceleration = 4;
  void clear_acceleration();
  double acceleration() const;
  void set_acceleration(double value);
  private:
  double _internal_acceleration() const;
  void _internal_set_acceleration(double value);
  public:

  // double load = 5;
  void clear_load();
  double load() const;
  void set_load(double value);
  private:
  double _internal_load() const;
  void _internal_set_load(double value);
  public:

  // .rocos.JointState.Status status = 6;
  void clear_status();
  ::rocos::JointState_Status status() const;
  void set_status(::rocos::JointState_Status value);
  private:
  ::rocos::JointState_Status _internal_status() const;
  void _internal_set_status(::rocos::JointState_Status value);
  public:

  // bool raw_data = 7;
  void clear_raw_data();
  bool raw_data() const;
  void set_raw_data(bool value);
  private:
  bool _internal_raw_data() const;
  void _internal_set_raw_data(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.JointState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double position_;
  double velocity_;
  double acceleration_;
  double load_;
  int status_;
  bool raw_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class FlangeState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.FlangeState) */ {
 public:
  inline FlangeState() : FlangeState(nullptr) {}
  ~FlangeState() override;
  explicit constexpr FlangeState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlangeState(const FlangeState& from);
  FlangeState(FlangeState&& from) noexcept
    : FlangeState() {
    *this = ::std::move(from);
  }

  inline FlangeState& operator=(const FlangeState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlangeState& operator=(FlangeState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlangeState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlangeState* internal_default_instance() {
    return reinterpret_cast<const FlangeState*>(
               &_FlangeState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FlangeState& a, FlangeState& b) {
    a.Swap(&b);
  }
  inline void Swap(FlangeState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlangeState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlangeState* New() const final {
    return new FlangeState();
  }

  FlangeState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlangeState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlangeState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlangeState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlangeState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.FlangeState";
  }
  protected:
  explicit FlangeState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:rocos.FlangeState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ToolState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.ToolState) */ {
 public:
  inline ToolState() : ToolState(nullptr) {}
  ~ToolState() override;
  explicit constexpr ToolState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolState(const ToolState& from);
  ToolState(ToolState&& from) noexcept
    : ToolState() {
    *this = ::std::move(from);
  }

  inline ToolState& operator=(const ToolState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolState& operator=(ToolState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolState* internal_default_instance() {
    return reinterpret_cast<const ToolState*>(
               &_ToolState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ToolState& a, ToolState& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ToolState* New() const final {
    return new ToolState();
  }

  ToolState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ToolState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ToolState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.ToolState";
  }
  protected:
  explicit ToolState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:rocos.ToolState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BaseState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.BaseState) */ {
 public:
  inline BaseState() : BaseState(nullptr) {}
  ~BaseState() override;
  explicit constexpr BaseState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseState(const BaseState& from);
  BaseState(BaseState&& from) noexcept
    : BaseState() {
    *this = ::std::move(from);
  }

  inline BaseState& operator=(const BaseState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseState& operator=(BaseState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseState* internal_default_instance() {
    return reinterpret_cast<const BaseState*>(
               &_BaseState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BaseState& a, BaseState& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseState* New() const final {
    return new BaseState();
  }

  BaseState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaseState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.BaseState";
  }
  protected:
  explicit BaseState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:rocos.BaseState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class ObjectState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.ObjectState) */ {
 public:
  inline ObjectState() : ObjectState(nullptr) {}
  ~ObjectState() override;
  explicit constexpr ObjectState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectState(const ObjectState& from);
  ObjectState(ObjectState&& from) noexcept
    : ObjectState() {
    *this = ::std::move(from);
  }

  inline ObjectState& operator=(const ObjectState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectState& operator=(ObjectState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectState* internal_default_instance() {
    return reinterpret_cast<const ObjectState*>(
               &_ObjectState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ObjectState& a, ObjectState& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectState* New() const final {
    return new ObjectState();
  }

  ObjectState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObjectState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.ObjectState";
  }
  protected:
  explicit ObjectState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:rocos.ObjectState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.RobotState) */ {
 public:
  inline RobotState() : RobotState(nullptr) {}
  ~RobotState() override;
  explicit constexpr RobotState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotState(const RobotState& from);
  RobotState(RobotState&& from) noexcept
    : RobotState() {
    *this = ::std::move(from);
  }

  inline RobotState& operator=(const RobotState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotState& operator=(RobotState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotState* internal_default_instance() {
    return reinterpret_cast<const RobotState*>(
               &_RobotState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RobotState& a, RobotState& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotState* New() const final {
    return new RobotState();
  }

  RobotState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.RobotState";
  }
  protected:
  explicit RobotState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointStatesFieldNumber = 1,
    kHwStateFieldNumber = 2,
    kFlangeStateFieldNumber = 3,
    kToolStateFieldNumber = 4,
    kBaseStateFieldNumber = 5,
    kObjStateFieldNumber = 6,
  };
  // repeated .rocos.JointState joint_states = 1;
  int joint_states_size() const;
  private:
  int _internal_joint_states_size() const;
  public:
  void clear_joint_states();
  ::rocos::JointState* mutable_joint_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::JointState >*
      mutable_joint_states();
  private:
  const ::rocos::JointState& _internal_joint_states(int index) const;
  ::rocos::JointState* _internal_add_joint_states();
  public:
  const ::rocos::JointState& joint_states(int index) const;
  ::rocos::JointState* add_joint_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::JointState >&
      joint_states() const;

  // .rocos.HardwareState hw_state = 2;
  bool has_hw_state() const;
  private:
  bool _internal_has_hw_state() const;
  public:
  void clear_hw_state();
  const ::rocos::HardwareState& hw_state() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::HardwareState* release_hw_state();
  ::rocos::HardwareState* mutable_hw_state();
  void set_allocated_hw_state(::rocos::HardwareState* hw_state);
  private:
  const ::rocos::HardwareState& _internal_hw_state() const;
  ::rocos::HardwareState* _internal_mutable_hw_state();
  public:
  void unsafe_arena_set_allocated_hw_state(
      ::rocos::HardwareState* hw_state);
  ::rocos::HardwareState* unsafe_arena_release_hw_state();

  // .rocos.FlangeState flange_state = 3;
  bool has_flange_state() const;
  private:
  bool _internal_has_flange_state() const;
  public:
  void clear_flange_state();
  const ::rocos::FlangeState& flange_state() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::FlangeState* release_flange_state();
  ::rocos::FlangeState* mutable_flange_state();
  void set_allocated_flange_state(::rocos::FlangeState* flange_state);
  private:
  const ::rocos::FlangeState& _internal_flange_state() const;
  ::rocos::FlangeState* _internal_mutable_flange_state();
  public:
  void unsafe_arena_set_allocated_flange_state(
      ::rocos::FlangeState* flange_state);
  ::rocos::FlangeState* unsafe_arena_release_flange_state();

  // .rocos.ToolState tool_state = 4;
  bool has_tool_state() const;
  private:
  bool _internal_has_tool_state() const;
  public:
  void clear_tool_state();
  const ::rocos::ToolState& tool_state() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::ToolState* release_tool_state();
  ::rocos::ToolState* mutable_tool_state();
  void set_allocated_tool_state(::rocos::ToolState* tool_state);
  private:
  const ::rocos::ToolState& _internal_tool_state() const;
  ::rocos::ToolState* _internal_mutable_tool_state();
  public:
  void unsafe_arena_set_allocated_tool_state(
      ::rocos::ToolState* tool_state);
  ::rocos::ToolState* unsafe_arena_release_tool_state();

  // .rocos.BaseState base_state = 5;
  bool has_base_state() const;
  private:
  bool _internal_has_base_state() const;
  public:
  void clear_base_state();
  const ::rocos::BaseState& base_state() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::BaseState* release_base_state();
  ::rocos::BaseState* mutable_base_state();
  void set_allocated_base_state(::rocos::BaseState* base_state);
  private:
  const ::rocos::BaseState& _internal_base_state() const;
  ::rocos::BaseState* _internal_mutable_base_state();
  public:
  void unsafe_arena_set_allocated_base_state(
      ::rocos::BaseState* base_state);
  ::rocos::BaseState* unsafe_arena_release_base_state();

  // .rocos.ObjectState obj_state = 6;
  bool has_obj_state() const;
  private:
  bool _internal_has_obj_state() const;
  public:
  void clear_obj_state();
  const ::rocos::ObjectState& obj_state() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::ObjectState* release_obj_state();
  ::rocos::ObjectState* mutable_obj_state();
  void set_allocated_obj_state(::rocos::ObjectState* obj_state);
  private:
  const ::rocos::ObjectState& _internal_obj_state() const;
  ::rocos::ObjectState* _internal_mutable_obj_state();
  public:
  void unsafe_arena_set_allocated_obj_state(
      ::rocos::ObjectState* obj_state);
  ::rocos::ObjectState* unsafe_arena_release_obj_state();

  // @@protoc_insertion_point(class_scope:rocos.RobotState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::JointState > joint_states_;
  ::rocos::HardwareState* hw_state_;
  ::rocos::FlangeState* flange_state_;
  ::rocos::ToolState* tool_state_;
  ::rocos::BaseState* base_state_;
  ::rocos::ObjectState* obj_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class HardwareState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.HardwareState) */ {
 public:
  inline HardwareState() : HardwareState(nullptr) {}
  ~HardwareState() override;
  explicit constexpr HardwareState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HardwareState(const HardwareState& from);
  HardwareState(HardwareState&& from) noexcept
    : HardwareState() {
    *this = ::std::move(from);
  }

  inline HardwareState& operator=(const HardwareState& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareState& operator=(HardwareState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareState& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareState* internal_default_instance() {
    return reinterpret_cast<const HardwareState*>(
               &_HardwareState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HardwareState& a, HardwareState& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HardwareState* New() const final {
    return new HardwareState();
  }

  HardwareState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HardwareState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HardwareState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HardwareState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.HardwareState";
  }
  protected:
  explicit HardwareState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HardwareState_HardwareType HardwareType;
  static constexpr HardwareType HW_TYPE_UNKNOWN =
    HardwareState_HardwareType_HW_TYPE_UNKNOWN;
  static constexpr HardwareType HW_TYPE_SIM =
    HardwareState_HardwareType_HW_TYPE_SIM;
  static constexpr HardwareType HW_TYPE_ETHERCAT =
    HardwareState_HardwareType_HW_TYPE_ETHERCAT;
  static constexpr HardwareType HW_TYPE_CAN =
    HardwareState_HardwareType_HW_TYPE_CAN;
  static constexpr HardwareType HW_TYPE_PROFINET =
    HardwareState_HardwareType_HW_TYPE_PROFINET;
  static inline bool HardwareType_IsValid(int value) {
    return HardwareState_HardwareType_IsValid(value);
  }
  static constexpr HardwareType HardwareType_MIN =
    HardwareState_HardwareType_HardwareType_MIN;
  static constexpr HardwareType HardwareType_MAX =
    HardwareState_HardwareType_HardwareType_MAX;
  static constexpr int HardwareType_ARRAYSIZE =
    HardwareState_HardwareType_HardwareType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HardwareType_descriptor() {
    return HardwareState_HardwareType_descriptor();
  }
  template<typename T>
  static inline const std::string& HardwareType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HardwareType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HardwareType_Name.");
    return HardwareState_HardwareType_Name(enum_t_value);
  }
  static inline bool HardwareType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HardwareType* value) {
    return HardwareState_HardwareType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kMinCycleTimeFieldNumber = 3,
    kHwTypeFieldNumber = 1,
    kSlaveNumFieldNumber = 6,
    kMaxCycleTimeFieldNumber = 4,
    kCurrentCycleTimeFieldNumber = 5,
  };
  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double min_cycle_time = 3;
  void clear_min_cycle_time();
  double min_cycle_time() const;
  void set_min_cycle_time(double value);
  private:
  double _internal_min_cycle_time() const;
  void _internal_set_min_cycle_time(double value);
  public:

  // .rocos.HardwareState.HardwareType hw_type = 1;
  void clear_hw_type();
  ::rocos::HardwareState_HardwareType hw_type() const;
  void set_hw_type(::rocos::HardwareState_HardwareType value);
  private:
  ::rocos::HardwareState_HardwareType _internal_hw_type() const;
  void _internal_set_hw_type(::rocos::HardwareState_HardwareType value);
  public:

  // int32 slave_num = 6;
  void clear_slave_num();
  ::PROTOBUF_NAMESPACE_ID::int32 slave_num() const;
  void set_slave_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_slave_num() const;
  void _internal_set_slave_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double max_cycle_time = 4;
  void clear_max_cycle_time();
  double max_cycle_time() const;
  void set_max_cycle_time(double value);
  private:
  double _internal_max_cycle_time() const;
  void _internal_set_max_cycle_time(double value);
  public:

  // double current_cycle_time = 5;
  void clear_current_cycle_time();
  double current_cycle_time() const;
  void set_current_cycle_time(double value);
  private:
  double _internal_current_cycle_time() const;
  void _internal_set_current_cycle_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.HardwareState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  double min_cycle_time_;
  int hw_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 slave_num_;
  double max_cycle_time_;
  double current_cycle_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.RobotStateRequest) */ {
 public:
  inline RobotStateRequest() : RobotStateRequest(nullptr) {}
  ~RobotStateRequest() override;
  explicit constexpr RobotStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotStateRequest(const RobotStateRequest& from);
  RobotStateRequest(RobotStateRequest&& from) noexcept
    : RobotStateRequest() {
    *this = ::std::move(from);
  }

  inline RobotStateRequest& operator=(const RobotStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStateRequest& operator=(RobotStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotStateRequest* internal_default_instance() {
    return reinterpret_cast<const RobotStateRequest*>(
               &_RobotStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RobotStateRequest& a, RobotStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotStateRequest* New() const final {
    return new RobotStateRequest();
  }

  RobotStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.RobotStateRequest";
  }
  protected:
  explicit RobotStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRawDataFieldNumber = 2,
  };
  // .rocos.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::rocos::RequestHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::RequestHeader* release_header();
  ::rocos::RequestHeader* mutable_header();
  void set_allocated_header(::rocos::RequestHeader* header);
  private:
  const ::rocos::RequestHeader& _internal_header() const;
  ::rocos::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::rocos::RequestHeader* header);
  ::rocos::RequestHeader* unsafe_arena_release_header();

  // optional bool raw_data = 2;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  bool raw_data() const;
  void set_raw_data(bool value);
  private:
  bool _internal_raw_data() const;
  void _internal_set_raw_data(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.RobotStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rocos::RequestHeader* header_;
  bool raw_data_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.RobotStateResponse) */ {
 public:
  inline RobotStateResponse() : RobotStateResponse(nullptr) {}
  ~RobotStateResponse() override;
  explicit constexpr RobotStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotStateResponse(const RobotStateResponse& from);
  RobotStateResponse(RobotStateResponse&& from) noexcept
    : RobotStateResponse() {
    *this = ::std::move(from);
  }

  inline RobotStateResponse& operator=(const RobotStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStateResponse& operator=(RobotStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotStateResponse* internal_default_instance() {
    return reinterpret_cast<const RobotStateResponse*>(
               &_RobotStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RobotStateResponse& a, RobotStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotStateResponse* New() const final {
    return new RobotStateResponse();
  }

  RobotStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotStateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.RobotStateResponse";
  }
  protected:
  explicit RobotStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRobotStateFieldNumber = 2,
  };
  // .rocos.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::rocos::ResponseHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::ResponseHeader* release_header();
  ::rocos::ResponseHeader* mutable_header();
  void set_allocated_header(::rocos::ResponseHeader* header);
  private:
  const ::rocos::ResponseHeader& _internal_header() const;
  ::rocos::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::rocos::ResponseHeader* header);
  ::rocos::ResponseHeader* unsafe_arena_release_header();

  // .rocos.RobotState robot_state = 2;
  bool has_robot_state() const;
  private:
  bool _internal_has_robot_state() const;
  public:
  void clear_robot_state();
  const ::rocos::RobotState& robot_state() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::RobotState* release_robot_state();
  ::rocos::RobotState* mutable_robot_state();
  void set_allocated_robot_state(::rocos::RobotState* robot_state);
  private:
  const ::rocos::RobotState& _internal_robot_state() const;
  ::rocos::RobotState* _internal_mutable_robot_state();
  public:
  void unsafe_arena_set_allocated_robot_state(
      ::rocos::RobotState* robot_state);
  ::rocos::RobotState* unsafe_arena_release_robot_state();

  // @@protoc_insertion_point(class_scope:rocos.RobotStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::ResponseHeader* header_;
  ::rocos::RobotState* robot_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_5fstate_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JointState

// string name = 1;
inline void JointState::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& JointState::name() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JointState::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocos.JointState.name)
}
inline std::string* JointState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rocos.JointState.name)
  return _s;
}
inline const std::string& JointState::_internal_name() const {
  return name_.Get();
}
inline void JointState::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JointState::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JointState::release_name() {
  // @@protoc_insertion_point(field_release:rocos.JointState.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JointState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rocos.JointState.name)
}

// double position = 2;
inline void JointState::clear_position() {
  position_ = 0;
}
inline double JointState::_internal_position() const {
  return position_;
}
inline double JointState::position() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.position)
  return _internal_position();
}
inline void JointState::_internal_set_position(double value) {
  
  position_ = value;
}
inline void JointState::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:rocos.JointState.position)
}

// double velocity = 3;
inline void JointState::clear_velocity() {
  velocity_ = 0;
}
inline double JointState::_internal_velocity() const {
  return velocity_;
}
inline double JointState::velocity() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.velocity)
  return _internal_velocity();
}
inline void JointState::_internal_set_velocity(double value) {
  
  velocity_ = value;
}
inline void JointState::set_velocity(double value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:rocos.JointState.velocity)
}

// double acceleration = 4;
inline void JointState::clear_acceleration() {
  acceleration_ = 0;
}
inline double JointState::_internal_acceleration() const {
  return acceleration_;
}
inline double JointState::acceleration() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.acceleration)
  return _internal_acceleration();
}
inline void JointState::_internal_set_acceleration(double value) {
  
  acceleration_ = value;
}
inline void JointState::set_acceleration(double value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:rocos.JointState.acceleration)
}

// double load = 5;
inline void JointState::clear_load() {
  load_ = 0;
}
inline double JointState::_internal_load() const {
  return load_;
}
inline double JointState::load() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.load)
  return _internal_load();
}
inline void JointState::_internal_set_load(double value) {
  
  load_ = value;
}
inline void JointState::set_load(double value) {
  _internal_set_load(value);
  // @@protoc_insertion_point(field_set:rocos.JointState.load)
}

// .rocos.JointState.Status status = 6;
inline void JointState::clear_status() {
  status_ = 0;
}
inline ::rocos::JointState_Status JointState::_internal_status() const {
  return static_cast< ::rocos::JointState_Status >(status_);
}
inline ::rocos::JointState_Status JointState::status() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.status)
  return _internal_status();
}
inline void JointState::_internal_set_status(::rocos::JointState_Status value) {
  
  status_ = value;
}
inline void JointState::set_status(::rocos::JointState_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:rocos.JointState.status)
}

// bool raw_data = 7;
inline void JointState::clear_raw_data() {
  raw_data_ = false;
}
inline bool JointState::_internal_raw_data() const {
  return raw_data_;
}
inline bool JointState::raw_data() const {
  // @@protoc_insertion_point(field_get:rocos.JointState.raw_data)
  return _internal_raw_data();
}
inline void JointState::_internal_set_raw_data(bool value) {
  
  raw_data_ = value;
}
inline void JointState::set_raw_data(bool value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:rocos.JointState.raw_data)
}

// -------------------------------------------------------------------

// FlangeState

// .rocos.SE3Pose pose = 1;
inline bool FlangeState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool FlangeState::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& FlangeState::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& FlangeState::pose() const {
  // @@protoc_insertion_point(field_get:rocos.FlangeState.pose)
  return _internal_pose();
}
inline void FlangeState::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.FlangeState.pose)
}
inline ::rocos::SE3Pose* FlangeState::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* FlangeState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.FlangeState.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* FlangeState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* FlangeState::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.FlangeState.pose)
  return _msg;
}
inline void FlangeState::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.FlangeState.pose)
}

// -------------------------------------------------------------------

// ToolState

// .rocos.SE3Pose pose = 1;
inline bool ToolState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool ToolState::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& ToolState::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& ToolState::pose() const {
  // @@protoc_insertion_point(field_get:rocos.ToolState.pose)
  return _internal_pose();
}
inline void ToolState::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.ToolState.pose)
}
inline ::rocos::SE3Pose* ToolState::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* ToolState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.ToolState.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* ToolState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* ToolState::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.ToolState.pose)
  return _msg;
}
inline void ToolState::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.ToolState.pose)
}

// -------------------------------------------------------------------

// BaseState

// .rocos.SE3Pose pose = 1;
inline bool BaseState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool BaseState::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& BaseState::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& BaseState::pose() const {
  // @@protoc_insertion_point(field_get:rocos.BaseState.pose)
  return _internal_pose();
}
inline void BaseState::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.BaseState.pose)
}
inline ::rocos::SE3Pose* BaseState::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* BaseState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.BaseState.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* BaseState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* BaseState::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.BaseState.pose)
  return _msg;
}
inline void BaseState::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.BaseState.pose)
}

// -------------------------------------------------------------------

// ObjectState

// .rocos.SE3Pose pose = 1;
inline bool ObjectState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool ObjectState::has_pose() const {
  return _internal_has_pose();
}
inline const ::rocos::SE3Pose& ObjectState::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& ObjectState::pose() const {
  // @@protoc_insertion_point(field_get:rocos.ObjectState.pose)
  return _internal_pose();
}
inline void ObjectState::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.ObjectState.pose)
}
inline ::rocos::SE3Pose* ObjectState::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* ObjectState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.ObjectState.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* ObjectState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* ObjectState::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.ObjectState.pose)
  return _msg;
}
inline void ObjectState::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.ObjectState.pose)
}

// -------------------------------------------------------------------

// RobotState

// repeated .rocos.JointState joint_states = 1;
inline int RobotState::_internal_joint_states_size() const {
  return joint_states_.size();
}
inline int RobotState::joint_states_size() const {
  return _internal_joint_states_size();
}
inline void RobotState::clear_joint_states() {
  joint_states_.Clear();
}
inline ::rocos::JointState* RobotState::mutable_joint_states(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.RobotState.joint_states)
  return joint_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::JointState >*
RobotState::mutable_joint_states() {
  // @@protoc_insertion_point(field_mutable_list:rocos.RobotState.joint_states)
  return &joint_states_;
}
inline const ::rocos::JointState& RobotState::_internal_joint_states(int index) const {
  return joint_states_.Get(index);
}
inline const ::rocos::JointState& RobotState::joint_states(int index) const {
  // @@protoc_insertion_point(field_get:rocos.RobotState.joint_states)
  return _internal_joint_states(index);
}
inline ::rocos::JointState* RobotState::_internal_add_joint_states() {
  return joint_states_.Add();
}
inline ::rocos::JointState* RobotState::add_joint_states() {
  ::rocos::JointState* _add = _internal_add_joint_states();
  // @@protoc_insertion_point(field_add:rocos.RobotState.joint_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::JointState >&
RobotState::joint_states() const {
  // @@protoc_insertion_point(field_list:rocos.RobotState.joint_states)
  return joint_states_;
}

// .rocos.HardwareState hw_state = 2;
inline bool RobotState::_internal_has_hw_state() const {
  return this != internal_default_instance() && hw_state_ != nullptr;
}
inline bool RobotState::has_hw_state() const {
  return _internal_has_hw_state();
}
inline void RobotState::clear_hw_state() {
  if (GetArenaForAllocation() == nullptr && hw_state_ != nullptr) {
    delete hw_state_;
  }
  hw_state_ = nullptr;
}
inline const ::rocos::HardwareState& RobotState::_internal_hw_state() const {
  const ::rocos::HardwareState* p = hw_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::HardwareState&>(
      ::rocos::_HardwareState_default_instance_);
}
inline const ::rocos::HardwareState& RobotState::hw_state() const {
  // @@protoc_insertion_point(field_get:rocos.RobotState.hw_state)
  return _internal_hw_state();
}
inline void RobotState::unsafe_arena_set_allocated_hw_state(
    ::rocos::HardwareState* hw_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hw_state_);
  }
  hw_state_ = hw_state;
  if (hw_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotState.hw_state)
}
inline ::rocos::HardwareState* RobotState::release_hw_state() {
  
  ::rocos::HardwareState* temp = hw_state_;
  hw_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::HardwareState* RobotState::unsafe_arena_release_hw_state() {
  // @@protoc_insertion_point(field_release:rocos.RobotState.hw_state)
  
  ::rocos::HardwareState* temp = hw_state_;
  hw_state_ = nullptr;
  return temp;
}
inline ::rocos::HardwareState* RobotState::_internal_mutable_hw_state() {
  
  if (hw_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::HardwareState>(GetArenaForAllocation());
    hw_state_ = p;
  }
  return hw_state_;
}
inline ::rocos::HardwareState* RobotState::mutable_hw_state() {
  ::rocos::HardwareState* _msg = _internal_mutable_hw_state();
  // @@protoc_insertion_point(field_mutable:rocos.RobotState.hw_state)
  return _msg;
}
inline void RobotState::set_allocated_hw_state(::rocos::HardwareState* hw_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hw_state_;
  }
  if (hw_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::HardwareState>::GetOwningArena(hw_state);
    if (message_arena != submessage_arena) {
      hw_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hw_state, submessage_arena);
    }
    
  } else {
    
  }
  hw_state_ = hw_state;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotState.hw_state)
}

// .rocos.FlangeState flange_state = 3;
inline bool RobotState::_internal_has_flange_state() const {
  return this != internal_default_instance() && flange_state_ != nullptr;
}
inline bool RobotState::has_flange_state() const {
  return _internal_has_flange_state();
}
inline void RobotState::clear_flange_state() {
  if (GetArenaForAllocation() == nullptr && flange_state_ != nullptr) {
    delete flange_state_;
  }
  flange_state_ = nullptr;
}
inline const ::rocos::FlangeState& RobotState::_internal_flange_state() const {
  const ::rocos::FlangeState* p = flange_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::FlangeState&>(
      ::rocos::_FlangeState_default_instance_);
}
inline const ::rocos::FlangeState& RobotState::flange_state() const {
  // @@protoc_insertion_point(field_get:rocos.RobotState.flange_state)
  return _internal_flange_state();
}
inline void RobotState::unsafe_arena_set_allocated_flange_state(
    ::rocos::FlangeState* flange_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flange_state_);
  }
  flange_state_ = flange_state;
  if (flange_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotState.flange_state)
}
inline ::rocos::FlangeState* RobotState::release_flange_state() {
  
  ::rocos::FlangeState* temp = flange_state_;
  flange_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::FlangeState* RobotState::unsafe_arena_release_flange_state() {
  // @@protoc_insertion_point(field_release:rocos.RobotState.flange_state)
  
  ::rocos::FlangeState* temp = flange_state_;
  flange_state_ = nullptr;
  return temp;
}
inline ::rocos::FlangeState* RobotState::_internal_mutable_flange_state() {
  
  if (flange_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::FlangeState>(GetArenaForAllocation());
    flange_state_ = p;
  }
  return flange_state_;
}
inline ::rocos::FlangeState* RobotState::mutable_flange_state() {
  ::rocos::FlangeState* _msg = _internal_mutable_flange_state();
  // @@protoc_insertion_point(field_mutable:rocos.RobotState.flange_state)
  return _msg;
}
inline void RobotState::set_allocated_flange_state(::rocos::FlangeState* flange_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete flange_state_;
  }
  if (flange_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::FlangeState>::GetOwningArena(flange_state);
    if (message_arena != submessage_arena) {
      flange_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flange_state, submessage_arena);
    }
    
  } else {
    
  }
  flange_state_ = flange_state;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotState.flange_state)
}

// .rocos.ToolState tool_state = 4;
inline bool RobotState::_internal_has_tool_state() const {
  return this != internal_default_instance() && tool_state_ != nullptr;
}
inline bool RobotState::has_tool_state() const {
  return _internal_has_tool_state();
}
inline void RobotState::clear_tool_state() {
  if (GetArenaForAllocation() == nullptr && tool_state_ != nullptr) {
    delete tool_state_;
  }
  tool_state_ = nullptr;
}
inline const ::rocos::ToolState& RobotState::_internal_tool_state() const {
  const ::rocos::ToolState* p = tool_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::ToolState&>(
      ::rocos::_ToolState_default_instance_);
}
inline const ::rocos::ToolState& RobotState::tool_state() const {
  // @@protoc_insertion_point(field_get:rocos.RobotState.tool_state)
  return _internal_tool_state();
}
inline void RobotState::unsafe_arena_set_allocated_tool_state(
    ::rocos::ToolState* tool_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tool_state_);
  }
  tool_state_ = tool_state;
  if (tool_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotState.tool_state)
}
inline ::rocos::ToolState* RobotState::release_tool_state() {
  
  ::rocos::ToolState* temp = tool_state_;
  tool_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::ToolState* RobotState::unsafe_arena_release_tool_state() {
  // @@protoc_insertion_point(field_release:rocos.RobotState.tool_state)
  
  ::rocos::ToolState* temp = tool_state_;
  tool_state_ = nullptr;
  return temp;
}
inline ::rocos::ToolState* RobotState::_internal_mutable_tool_state() {
  
  if (tool_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::ToolState>(GetArenaForAllocation());
    tool_state_ = p;
  }
  return tool_state_;
}
inline ::rocos::ToolState* RobotState::mutable_tool_state() {
  ::rocos::ToolState* _msg = _internal_mutable_tool_state();
  // @@protoc_insertion_point(field_mutable:rocos.RobotState.tool_state)
  return _msg;
}
inline void RobotState::set_allocated_tool_state(::rocos::ToolState* tool_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tool_state_;
  }
  if (tool_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::ToolState>::GetOwningArena(tool_state);
    if (message_arena != submessage_arena) {
      tool_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool_state, submessage_arena);
    }
    
  } else {
    
  }
  tool_state_ = tool_state;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotState.tool_state)
}

// .rocos.BaseState base_state = 5;
inline bool RobotState::_internal_has_base_state() const {
  return this != internal_default_instance() && base_state_ != nullptr;
}
inline bool RobotState::has_base_state() const {
  return _internal_has_base_state();
}
inline void RobotState::clear_base_state() {
  if (GetArenaForAllocation() == nullptr && base_state_ != nullptr) {
    delete base_state_;
  }
  base_state_ = nullptr;
}
inline const ::rocos::BaseState& RobotState::_internal_base_state() const {
  const ::rocos::BaseState* p = base_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::BaseState&>(
      ::rocos::_BaseState_default_instance_);
}
inline const ::rocos::BaseState& RobotState::base_state() const {
  // @@protoc_insertion_point(field_get:rocos.RobotState.base_state)
  return _internal_base_state();
}
inline void RobotState::unsafe_arena_set_allocated_base_state(
    ::rocos::BaseState* base_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_state_);
  }
  base_state_ = base_state;
  if (base_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotState.base_state)
}
inline ::rocos::BaseState* RobotState::release_base_state() {
  
  ::rocos::BaseState* temp = base_state_;
  base_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::BaseState* RobotState::unsafe_arena_release_base_state() {
  // @@protoc_insertion_point(field_release:rocos.RobotState.base_state)
  
  ::rocos::BaseState* temp = base_state_;
  base_state_ = nullptr;
  return temp;
}
inline ::rocos::BaseState* RobotState::_internal_mutable_base_state() {
  
  if (base_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::BaseState>(GetArenaForAllocation());
    base_state_ = p;
  }
  return base_state_;
}
inline ::rocos::BaseState* RobotState::mutable_base_state() {
  ::rocos::BaseState* _msg = _internal_mutable_base_state();
  // @@protoc_insertion_point(field_mutable:rocos.RobotState.base_state)
  return _msg;
}
inline void RobotState::set_allocated_base_state(::rocos::BaseState* base_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete base_state_;
  }
  if (base_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::BaseState>::GetOwningArena(base_state);
    if (message_arena != submessage_arena) {
      base_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_state, submessage_arena);
    }
    
  } else {
    
  }
  base_state_ = base_state;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotState.base_state)
}

// .rocos.ObjectState obj_state = 6;
inline bool RobotState::_internal_has_obj_state() const {
  return this != internal_default_instance() && obj_state_ != nullptr;
}
inline bool RobotState::has_obj_state() const {
  return _internal_has_obj_state();
}
inline void RobotState::clear_obj_state() {
  if (GetArenaForAllocation() == nullptr && obj_state_ != nullptr) {
    delete obj_state_;
  }
  obj_state_ = nullptr;
}
inline const ::rocos::ObjectState& RobotState::_internal_obj_state() const {
  const ::rocos::ObjectState* p = obj_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::ObjectState&>(
      ::rocos::_ObjectState_default_instance_);
}
inline const ::rocos::ObjectState& RobotState::obj_state() const {
  // @@protoc_insertion_point(field_get:rocos.RobotState.obj_state)
  return _internal_obj_state();
}
inline void RobotState::unsafe_arena_set_allocated_obj_state(
    ::rocos::ObjectState* obj_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obj_state_);
  }
  obj_state_ = obj_state;
  if (obj_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotState.obj_state)
}
inline ::rocos::ObjectState* RobotState::release_obj_state() {
  
  ::rocos::ObjectState* temp = obj_state_;
  obj_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::ObjectState* RobotState::unsafe_arena_release_obj_state() {
  // @@protoc_insertion_point(field_release:rocos.RobotState.obj_state)
  
  ::rocos::ObjectState* temp = obj_state_;
  obj_state_ = nullptr;
  return temp;
}
inline ::rocos::ObjectState* RobotState::_internal_mutable_obj_state() {
  
  if (obj_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::ObjectState>(GetArenaForAllocation());
    obj_state_ = p;
  }
  return obj_state_;
}
inline ::rocos::ObjectState* RobotState::mutable_obj_state() {
  ::rocos::ObjectState* _msg = _internal_mutable_obj_state();
  // @@protoc_insertion_point(field_mutable:rocos.RobotState.obj_state)
  return _msg;
}
inline void RobotState::set_allocated_obj_state(::rocos::ObjectState* obj_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete obj_state_;
  }
  if (obj_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::ObjectState>::GetOwningArena(obj_state);
    if (message_arena != submessage_arena) {
      obj_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obj_state, submessage_arena);
    }
    
  } else {
    
  }
  obj_state_ = obj_state;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotState.obj_state)
}

// -------------------------------------------------------------------

// HardwareState

// .rocos.HardwareState.HardwareType hw_type = 1;
inline void HardwareState::clear_hw_type() {
  hw_type_ = 0;
}
inline ::rocos::HardwareState_HardwareType HardwareState::_internal_hw_type() const {
  return static_cast< ::rocos::HardwareState_HardwareType >(hw_type_);
}
inline ::rocos::HardwareState_HardwareType HardwareState::hw_type() const {
  // @@protoc_insertion_point(field_get:rocos.HardwareState.hw_type)
  return _internal_hw_type();
}
inline void HardwareState::_internal_set_hw_type(::rocos::HardwareState_HardwareType value) {
  
  hw_type_ = value;
}
inline void HardwareState::set_hw_type(::rocos::HardwareState_HardwareType value) {
  _internal_set_hw_type(value);
  // @@protoc_insertion_point(field_set:rocos.HardwareState.hw_type)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool HardwareState::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool HardwareState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& HardwareState::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& HardwareState::timestamp() const {
  // @@protoc_insertion_point(field_get:rocos.HardwareState.timestamp)
  return _internal_timestamp();
}
inline void HardwareState::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.HardwareState.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* HardwareState::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* HardwareState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:rocos.HardwareState.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* HardwareState::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* HardwareState::mutable_timestamp() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:rocos.HardwareState.timestamp)
  return _msg;
}
inline void HardwareState::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:rocos.HardwareState.timestamp)
}

// double min_cycle_time = 3;
inline void HardwareState::clear_min_cycle_time() {
  min_cycle_time_ = 0;
}
inline double HardwareState::_internal_min_cycle_time() const {
  return min_cycle_time_;
}
inline double HardwareState::min_cycle_time() const {
  // @@protoc_insertion_point(field_get:rocos.HardwareState.min_cycle_time)
  return _internal_min_cycle_time();
}
inline void HardwareState::_internal_set_min_cycle_time(double value) {
  
  min_cycle_time_ = value;
}
inline void HardwareState::set_min_cycle_time(double value) {
  _internal_set_min_cycle_time(value);
  // @@protoc_insertion_point(field_set:rocos.HardwareState.min_cycle_time)
}

// double max_cycle_time = 4;
inline void HardwareState::clear_max_cycle_time() {
  max_cycle_time_ = 0;
}
inline double HardwareState::_internal_max_cycle_time() const {
  return max_cycle_time_;
}
inline double HardwareState::max_cycle_time() const {
  // @@protoc_insertion_point(field_get:rocos.HardwareState.max_cycle_time)
  return _internal_max_cycle_time();
}
inline void HardwareState::_internal_set_max_cycle_time(double value) {
  
  max_cycle_time_ = value;
}
inline void HardwareState::set_max_cycle_time(double value) {
  _internal_set_max_cycle_time(value);
  // @@protoc_insertion_point(field_set:rocos.HardwareState.max_cycle_time)
}

// double current_cycle_time = 5;
inline void HardwareState::clear_current_cycle_time() {
  current_cycle_time_ = 0;
}
inline double HardwareState::_internal_current_cycle_time() const {
  return current_cycle_time_;
}
inline double HardwareState::current_cycle_time() const {
  // @@protoc_insertion_point(field_get:rocos.HardwareState.current_cycle_time)
  return _internal_current_cycle_time();
}
inline void HardwareState::_internal_set_current_cycle_time(double value) {
  
  current_cycle_time_ = value;
}
inline void HardwareState::set_current_cycle_time(double value) {
  _internal_set_current_cycle_time(value);
  // @@protoc_insertion_point(field_set:rocos.HardwareState.current_cycle_time)
}

// int32 slave_num = 6;
inline void HardwareState::clear_slave_num() {
  slave_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HardwareState::_internal_slave_num() const {
  return slave_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HardwareState::slave_num() const {
  // @@protoc_insertion_point(field_get:rocos.HardwareState.slave_num)
  return _internal_slave_num();
}
inline void HardwareState::_internal_set_slave_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  slave_num_ = value;
}
inline void HardwareState::set_slave_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_slave_num(value);
  // @@protoc_insertion_point(field_set:rocos.HardwareState.slave_num)
}

// -------------------------------------------------------------------

// RobotStateRequest

// .rocos.RequestHeader header = 1;
inline bool RobotStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::rocos::RequestHeader& RobotStateRequest::_internal_header() const {
  const ::rocos::RequestHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::RequestHeader&>(
      ::rocos::_RequestHeader_default_instance_);
}
inline const ::rocos::RequestHeader& RobotStateRequest::header() const {
  // @@protoc_insertion_point(field_get:rocos.RobotStateRequest.header)
  return _internal_header();
}
inline void RobotStateRequest::unsafe_arena_set_allocated_header(
    ::rocos::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotStateRequest.header)
}
inline ::rocos::RequestHeader* RobotStateRequest::release_header() {
  
  ::rocos::RequestHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::RequestHeader* RobotStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:rocos.RobotStateRequest.header)
  
  ::rocos::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::rocos::RequestHeader* RobotStateRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::RequestHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::rocos::RequestHeader* RobotStateRequest::mutable_header() {
  ::rocos::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:rocos.RobotStateRequest.header)
  return _msg;
}
inline void RobotStateRequest::set_allocated_header(::rocos::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotStateRequest.header)
}

// optional bool raw_data = 2;
inline bool RobotStateRequest::_internal_has_raw_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotStateRequest::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void RobotStateRequest::clear_raw_data() {
  raw_data_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RobotStateRequest::_internal_raw_data() const {
  return raw_data_;
}
inline bool RobotStateRequest::raw_data() const {
  // @@protoc_insertion_point(field_get:rocos.RobotStateRequest.raw_data)
  return _internal_raw_data();
}
inline void RobotStateRequest::_internal_set_raw_data(bool value) {
  _has_bits_[0] |= 0x00000001u;
  raw_data_ = value;
}
inline void RobotStateRequest::set_raw_data(bool value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:rocos.RobotStateRequest.raw_data)
}

// -------------------------------------------------------------------

// RobotStateResponse

// .rocos.ResponseHeader header = 1;
inline bool RobotStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::rocos::ResponseHeader& RobotStateResponse::_internal_header() const {
  const ::rocos::ResponseHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::ResponseHeader&>(
      ::rocos::_ResponseHeader_default_instance_);
}
inline const ::rocos::ResponseHeader& RobotStateResponse::header() const {
  // @@protoc_insertion_point(field_get:rocos.RobotStateResponse.header)
  return _internal_header();
}
inline void RobotStateResponse::unsafe_arena_set_allocated_header(
    ::rocos::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotStateResponse.header)
}
inline ::rocos::ResponseHeader* RobotStateResponse::release_header() {
  
  ::rocos::ResponseHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::ResponseHeader* RobotStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:rocos.RobotStateResponse.header)
  
  ::rocos::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::rocos::ResponseHeader* RobotStateResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::ResponseHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::rocos::ResponseHeader* RobotStateResponse::mutable_header() {
  ::rocos::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:rocos.RobotStateResponse.header)
  return _msg;
}
inline void RobotStateResponse::set_allocated_header(::rocos::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotStateResponse.header)
}

// .rocos.RobotState robot_state = 2;
inline bool RobotStateResponse::_internal_has_robot_state() const {
  return this != internal_default_instance() && robot_state_ != nullptr;
}
inline bool RobotStateResponse::has_robot_state() const {
  return _internal_has_robot_state();
}
inline void RobotStateResponse::clear_robot_state() {
  if (GetArenaForAllocation() == nullptr && robot_state_ != nullptr) {
    delete robot_state_;
  }
  robot_state_ = nullptr;
}
inline const ::rocos::RobotState& RobotStateResponse::_internal_robot_state() const {
  const ::rocos::RobotState* p = robot_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::RobotState&>(
      ::rocos::_RobotState_default_instance_);
}
inline const ::rocos::RobotState& RobotStateResponse::robot_state() const {
  // @@protoc_insertion_point(field_get:rocos.RobotStateResponse.robot_state)
  return _internal_robot_state();
}
inline void RobotStateResponse::unsafe_arena_set_allocated_robot_state(
    ::rocos::RobotState* robot_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_state_);
  }
  robot_state_ = robot_state;
  if (robot_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.RobotStateResponse.robot_state)
}
inline ::rocos::RobotState* RobotStateResponse::release_robot_state() {
  
  ::rocos::RobotState* temp = robot_state_;
  robot_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::RobotState* RobotStateResponse::unsafe_arena_release_robot_state() {
  // @@protoc_insertion_point(field_release:rocos.RobotStateResponse.robot_state)
  
  ::rocos::RobotState* temp = robot_state_;
  robot_state_ = nullptr;
  return temp;
}
inline ::rocos::RobotState* RobotStateResponse::_internal_mutable_robot_state() {
  
  if (robot_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::RobotState>(GetArenaForAllocation());
    robot_state_ = p;
  }
  return robot_state_;
}
inline ::rocos::RobotState* RobotStateResponse::mutable_robot_state() {
  ::rocos::RobotState* _msg = _internal_mutable_robot_state();
  // @@protoc_insertion_point(field_mutable:rocos.RobotStateResponse.robot_state)
  return _msg;
}
inline void RobotStateResponse::set_allocated_robot_state(::rocos::RobotState* robot_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete robot_state_;
  }
  if (robot_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::RobotState>::GetOwningArena(robot_state);
    if (message_arena != submessage_arena) {
      robot_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_state, submessage_arena);
    }
    
  } else {
    
  }
  robot_state_ = robot_state;
  // @@protoc_insertion_point(field_set_allocated:rocos.RobotStateResponse.robot_state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rocos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rocos::JointState_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::JointState_Status>() {
  return ::rocos::JointState_Status_descriptor();
}
template <> struct is_proto_enum< ::rocos::HardwareState_HardwareType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rocos::HardwareState_HardwareType>() {
  return ::rocos::HardwareState_HardwareType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_5fstate_2eproto
