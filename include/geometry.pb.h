// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_geometry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_geometry_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[32]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_geometry_2eproto;
namespace rocos {
class Area;
struct AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class Bounds;
struct BoundsDefaultTypeInternal;
extern BoundsDefaultTypeInternal _Bounds_default_instance_;
class Box2;
struct Box2DefaultTypeInternal;
extern Box2DefaultTypeInternal _Box2_default_instance_;
class Box2WithFrame;
struct Box2WithFrameDefaultTypeInternal;
extern Box2WithFrameDefaultTypeInternal _Box2WithFrame_default_instance_;
class Box3;
struct Box3DefaultTypeInternal;
extern Box3DefaultTypeInternal _Box3_default_instance_;
class Box3WithFrame;
struct Box3WithFrameDefaultTypeInternal;
extern Box3WithFrameDefaultTypeInternal _Box3WithFrame_default_instance_;
class Circle;
struct CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class CylindricalCoordinate;
struct CylindricalCoordinateDefaultTypeInternal;
extern CylindricalCoordinateDefaultTypeInternal _CylindricalCoordinate_default_instance_;
class FrameTreeSnapshot;
struct FrameTreeSnapshotDefaultTypeInternal;
extern FrameTreeSnapshotDefaultTypeInternal _FrameTreeSnapshot_default_instance_;
class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse;
struct FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUseDefaultTypeInternal;
extern FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUseDefaultTypeInternal _FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse_default_instance_;
class FrameTreeSnapshot_ParentEdge;
struct FrameTreeSnapshot_ParentEdgeDefaultTypeInternal;
extern FrameTreeSnapshot_ParentEdgeDefaultTypeInternal _FrameTreeSnapshot_ParentEdge_default_instance_;
class JointArray;
struct JointArrayDefaultTypeInternal;
extern JointArrayDefaultTypeInternal _JointArray_default_instance_;
class Matrix;
struct MatrixDefaultTypeInternal;
extern MatrixDefaultTypeInternal _Matrix_default_instance_;
class Plane;
struct PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class PolyLine;
struct PolyLineDefaultTypeInternal;
extern PolyLineDefaultTypeInternal _PolyLine_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class PolygonWithExclusions;
struct PolygonWithExclusionsDefaultTypeInternal;
extern PolygonWithExclusionsDefaultTypeInternal _PolygonWithExclusions_default_instance_;
class Quad;
struct QuadDefaultTypeInternal;
extern QuadDefaultTypeInternal _Quad_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Ray;
struct RayDefaultTypeInternal;
extern RayDefaultTypeInternal _Ray_default_instance_;
class SE2Pose;
struct SE2PoseDefaultTypeInternal;
extern SE2PoseDefaultTypeInternal _SE2Pose_default_instance_;
class SE2Velocity;
struct SE2VelocityDefaultTypeInternal;
extern SE2VelocityDefaultTypeInternal _SE2Velocity_default_instance_;
class SE2VelocityLimit;
struct SE2VelocityLimitDefaultTypeInternal;
extern SE2VelocityLimitDefaultTypeInternal _SE2VelocityLimit_default_instance_;
class SE3Covariance;
struct SE3CovarianceDefaultTypeInternal;
extern SE3CovarianceDefaultTypeInternal _SE3Covariance_default_instance_;
class SE3Pose;
struct SE3PoseDefaultTypeInternal;
extern SE3PoseDefaultTypeInternal _SE3Pose_default_instance_;
class SE3Velocity;
struct SE3VelocityDefaultTypeInternal;
extern SE3VelocityDefaultTypeInternal _SE3Velocity_default_instance_;
class Vec2;
struct Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec2Value;
struct Vec2ValueDefaultTypeInternal;
extern Vec2ValueDefaultTypeInternal _Vec2Value_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec3Value;
struct Vec3ValueDefaultTypeInternal;
extern Vec3ValueDefaultTypeInternal _Vec3Value_default_instance_;
class Volume;
struct VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class Wrench;
struct WrenchDefaultTypeInternal;
extern WrenchDefaultTypeInternal _Wrench_default_instance_;
}  // namespace rocos
PROTOBUF_NAMESPACE_OPEN
template<> ::rocos::Area* Arena::CreateMaybeMessage<::rocos::Area>(Arena*);
template<> ::rocos::Bounds* Arena::CreateMaybeMessage<::rocos::Bounds>(Arena*);
template<> ::rocos::Box2* Arena::CreateMaybeMessage<::rocos::Box2>(Arena*);
template<> ::rocos::Box2WithFrame* Arena::CreateMaybeMessage<::rocos::Box2WithFrame>(Arena*);
template<> ::rocos::Box3* Arena::CreateMaybeMessage<::rocos::Box3>(Arena*);
template<> ::rocos::Box3WithFrame* Arena::CreateMaybeMessage<::rocos::Box3WithFrame>(Arena*);
template<> ::rocos::Circle* Arena::CreateMaybeMessage<::rocos::Circle>(Arena*);
template<> ::rocos::CylindricalCoordinate* Arena::CreateMaybeMessage<::rocos::CylindricalCoordinate>(Arena*);
template<> ::rocos::FrameTreeSnapshot* Arena::CreateMaybeMessage<::rocos::FrameTreeSnapshot>(Arena*);
template<> ::rocos::FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse* Arena::CreateMaybeMessage<::rocos::FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse>(Arena*);
template<> ::rocos::FrameTreeSnapshot_ParentEdge* Arena::CreateMaybeMessage<::rocos::FrameTreeSnapshot_ParentEdge>(Arena*);
template<> ::rocos::JointArray* Arena::CreateMaybeMessage<::rocos::JointArray>(Arena*);
template<> ::rocos::Matrix* Arena::CreateMaybeMessage<::rocos::Matrix>(Arena*);
template<> ::rocos::Plane* Arena::CreateMaybeMessage<::rocos::Plane>(Arena*);
template<> ::rocos::PolyLine* Arena::CreateMaybeMessage<::rocos::PolyLine>(Arena*);
template<> ::rocos::Polygon* Arena::CreateMaybeMessage<::rocos::Polygon>(Arena*);
template<> ::rocos::PolygonWithExclusions* Arena::CreateMaybeMessage<::rocos::PolygonWithExclusions>(Arena*);
template<> ::rocos::Quad* Arena::CreateMaybeMessage<::rocos::Quad>(Arena*);
template<> ::rocos::Quaternion* Arena::CreateMaybeMessage<::rocos::Quaternion>(Arena*);
template<> ::rocos::Ray* Arena::CreateMaybeMessage<::rocos::Ray>(Arena*);
template<> ::rocos::SE2Pose* Arena::CreateMaybeMessage<::rocos::SE2Pose>(Arena*);
template<> ::rocos::SE2Velocity* Arena::CreateMaybeMessage<::rocos::SE2Velocity>(Arena*);
template<> ::rocos::SE2VelocityLimit* Arena::CreateMaybeMessage<::rocos::SE2VelocityLimit>(Arena*);
template<> ::rocos::SE3Covariance* Arena::CreateMaybeMessage<::rocos::SE3Covariance>(Arena*);
template<> ::rocos::SE3Pose* Arena::CreateMaybeMessage<::rocos::SE3Pose>(Arena*);
template<> ::rocos::SE3Velocity* Arena::CreateMaybeMessage<::rocos::SE3Velocity>(Arena*);
template<> ::rocos::Vec2* Arena::CreateMaybeMessage<::rocos::Vec2>(Arena*);
template<> ::rocos::Vec2Value* Arena::CreateMaybeMessage<::rocos::Vec2Value>(Arena*);
template<> ::rocos::Vec3* Arena::CreateMaybeMessage<::rocos::Vec3>(Arena*);
template<> ::rocos::Vec3Value* Arena::CreateMaybeMessage<::rocos::Vec3Value>(Arena*);
template<> ::rocos::Volume* Arena::CreateMaybeMessage<::rocos::Volume>(Arena*);
template<> ::rocos::Wrench* Arena::CreateMaybeMessage<::rocos::Wrench>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rocos {

// ===================================================================

class Vec2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Vec2) */ {
 public:
  inline Vec2() : Vec2(nullptr) {}
  ~Vec2() override;
  explicit constexpr Vec2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2(const Vec2& from);
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2* New() const final {
    return new Vec2();
  }

  Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Vec2";
  }
  protected:
  explicit Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Vec2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Vec3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  explicit constexpr Vec3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const final {
    return new Vec3();
  }

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Vec3";
  }
  protected:
  explicit Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class CylindricalCoordinate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.CylindricalCoordinate) */ {
 public:
  inline CylindricalCoordinate() : CylindricalCoordinate(nullptr) {}
  ~CylindricalCoordinate() override;
  explicit constexpr CylindricalCoordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CylindricalCoordinate(const CylindricalCoordinate& from);
  CylindricalCoordinate(CylindricalCoordinate&& from) noexcept
    : CylindricalCoordinate() {
    *this = ::std::move(from);
  }

  inline CylindricalCoordinate& operator=(const CylindricalCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CylindricalCoordinate& operator=(CylindricalCoordinate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CylindricalCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CylindricalCoordinate* internal_default_instance() {
    return reinterpret_cast<const CylindricalCoordinate*>(
               &_CylindricalCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CylindricalCoordinate& a, CylindricalCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(CylindricalCoordinate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CylindricalCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CylindricalCoordinate* New() const final {
    return new CylindricalCoordinate();
  }

  CylindricalCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CylindricalCoordinate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CylindricalCoordinate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CylindricalCoordinate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CylindricalCoordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.CylindricalCoordinate";
  }
  protected:
  explicit CylindricalCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kThetaFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double r = 1;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double theta = 2;
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.CylindricalCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double r_;
  double theta_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  explicit constexpr Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return new Quaternion();
  }

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Quaternion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double w = 4;
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  double w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Plane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Plane) */ {
 public:
  inline Plane() : Plane(nullptr) {}
  ~Plane() override;
  explicit constexpr Plane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plane(const Plane& from);
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plane& operator=(Plane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }
  inline void Swap(Plane* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Plane* New() const final {
    return new Plane();
  }

  Plane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Plane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Plane";
  }
  protected:
  explicit Plane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kNormalFieldNumber = 2,
  };
  // .rocos.Vec3 point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::rocos::Vec3& point() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_point();
  ::rocos::Vec3* mutable_point();
  void set_allocated_point(::rocos::Vec3* point);
  private:
  const ::rocos::Vec3& _internal_point() const;
  ::rocos::Vec3* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::rocos::Vec3* point);
  ::rocos::Vec3* unsafe_arena_release_point();

  // .rocos.Vec3 normal = 2;
  bool has_normal() const;
  private:
  bool _internal_has_normal() const;
  public:
  void clear_normal();
  const ::rocos::Vec3& normal() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_normal();
  ::rocos::Vec3* mutable_normal();
  void set_allocated_normal(::rocos::Vec3* normal);
  private:
  const ::rocos::Vec3& _internal_normal() const;
  ::rocos::Vec3* _internal_mutable_normal();
  public:
  void unsafe_arena_set_allocated_normal(
      ::rocos::Vec3* normal);
  ::rocos::Vec3* unsafe_arena_release_normal();

  // @@protoc_insertion_point(class_scope:rocos.Plane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec3* point_;
  ::rocos::Vec3* normal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Quad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Quad) */ {
 public:
  inline Quad() : Quad(nullptr) {}
  ~Quad() override;
  explicit constexpr Quad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quad(const Quad& from);
  Quad(Quad&& from) noexcept
    : Quad() {
    *this = ::std::move(from);
  }

  inline Quad& operator=(const Quad& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quad& operator=(Quad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quad& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quad* internal_default_instance() {
    return reinterpret_cast<const Quad*>(
               &_Quad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Quad& a, Quad& b) {
    a.Swap(&b);
  }
  inline void Swap(Quad* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quad* New() const final {
    return new Quad();
  }

  Quad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Quad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Quad";
  }
  protected:
  explicit Quad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .rocos.SE3Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::rocos::SE3Pose& pose() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_pose();
  ::rocos::SE3Pose* mutable_pose();
  void set_allocated_pose(::rocos::SE3Pose* pose);
  private:
  const ::rocos::SE3Pose& _internal_pose() const;
  ::rocos::SE3Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::rocos::SE3Pose* pose);
  ::rocos::SE3Pose* unsafe_arena_release_pose();

  // double size = 2;
  void clear_size();
  double size() const;
  void set_size(double value);
  private:
  double _internal_size() const;
  void _internal_set_size(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Quad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE3Pose* pose_;
  double size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Ray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Ray) */ {
 public:
  inline Ray() : Ray(nullptr) {}
  ~Ray() override;
  explicit constexpr Ray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ray(const Ray& from);
  Ray(Ray&& from) noexcept
    : Ray() {
    *this = ::std::move(from);
  }

  inline Ray& operator=(const Ray& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ray& operator=(Ray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ray& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ray* internal_default_instance() {
    return reinterpret_cast<const Ray*>(
               &_Ray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Ray& a, Ray& b) {
    a.Swap(&b);
  }
  inline void Swap(Ray* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ray* New() const final {
    return new Ray();
  }

  Ray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ray& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Ray";
  }
  protected:
  explicit Ray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // .rocos.Vec3 origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::rocos::Vec3& origin() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_origin();
  ::rocos::Vec3* mutable_origin();
  void set_allocated_origin(::rocos::Vec3* origin);
  private:
  const ::rocos::Vec3& _internal_origin() const;
  ::rocos::Vec3* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::rocos::Vec3* origin);
  ::rocos::Vec3* unsafe_arena_release_origin();

  // .rocos.Vec3 direction = 2;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::rocos::Vec3& direction() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_direction();
  ::rocos::Vec3* mutable_direction();
  void set_allocated_direction(::rocos::Vec3* direction);
  private:
  const ::rocos::Vec3& _internal_direction() const;
  ::rocos::Vec3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::rocos::Vec3* direction);
  ::rocos::Vec3* unsafe_arena_release_direction();

  // @@protoc_insertion_point(class_scope:rocos.Ray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec3* origin_;
  ::rocos::Vec3* direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class SE2Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SE2Pose) */ {
 public:
  inline SE2Pose() : SE2Pose(nullptr) {}
  ~SE2Pose() override;
  explicit constexpr SE2Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2Pose(const SE2Pose& from);
  SE2Pose(SE2Pose&& from) noexcept
    : SE2Pose() {
    *this = ::std::move(from);
  }

  inline SE2Pose& operator=(const SE2Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2Pose& operator=(SE2Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2Pose* internal_default_instance() {
    return reinterpret_cast<const SE2Pose*>(
               &_SE2Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SE2Pose& a, SE2Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2Pose* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2Pose* New() const final {
    return new SE2Pose();
  }

  SE2Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SE2Pose& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SE2Pose";
  }
  protected:
  explicit SE2Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // .rocos.Vec2 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::rocos::Vec2& position() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec2* release_position();
  ::rocos::Vec2* mutable_position();
  void set_allocated_position(::rocos::Vec2* position);
  private:
  const ::rocos::Vec2& _internal_position() const;
  ::rocos::Vec2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::rocos::Vec2* position);
  ::rocos::Vec2* unsafe_arena_release_position();

  // double angle = 2;
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SE2Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec2* position_;
  double angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class SE2Velocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SE2Velocity) */ {
 public:
  inline SE2Velocity() : SE2Velocity(nullptr) {}
  ~SE2Velocity() override;
  explicit constexpr SE2Velocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2Velocity(const SE2Velocity& from);
  SE2Velocity(SE2Velocity&& from) noexcept
    : SE2Velocity() {
    *this = ::std::move(from);
  }

  inline SE2Velocity& operator=(const SE2Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2Velocity& operator=(SE2Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2Velocity* internal_default_instance() {
    return reinterpret_cast<const SE2Velocity*>(
               &_SE2Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SE2Velocity& a, SE2Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2Velocity* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2Velocity* New() const final {
    return new SE2Velocity();
  }

  SE2Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2Velocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2Velocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SE2Velocity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2Velocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SE2Velocity";
  }
  protected:
  explicit SE2Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .rocos.Vec2 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::rocos::Vec2& linear() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec2* release_linear();
  ::rocos::Vec2* mutable_linear();
  void set_allocated_linear(::rocos::Vec2* linear);
  private:
  const ::rocos::Vec2& _internal_linear() const;
  ::rocos::Vec2* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::rocos::Vec2* linear);
  ::rocos::Vec2* unsafe_arena_release_linear();

  // double angular = 2;
  void clear_angular();
  double angular() const;
  void set_angular(double value);
  private:
  double _internal_angular() const;
  void _internal_set_angular(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SE2Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec2* linear_;
  double angular_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class SE2VelocityLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SE2VelocityLimit) */ {
 public:
  inline SE2VelocityLimit() : SE2VelocityLimit(nullptr) {}
  ~SE2VelocityLimit() override;
  explicit constexpr SE2VelocityLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE2VelocityLimit(const SE2VelocityLimit& from);
  SE2VelocityLimit(SE2VelocityLimit&& from) noexcept
    : SE2VelocityLimit() {
    *this = ::std::move(from);
  }

  inline SE2VelocityLimit& operator=(const SE2VelocityLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2VelocityLimit& operator=(SE2VelocityLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE2VelocityLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE2VelocityLimit* internal_default_instance() {
    return reinterpret_cast<const SE2VelocityLimit*>(
               &_SE2VelocityLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SE2VelocityLimit& a, SE2VelocityLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2VelocityLimit* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2VelocityLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2VelocityLimit* New() const final {
    return new SE2VelocityLimit();
  }

  SE2VelocityLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2VelocityLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE2VelocityLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SE2VelocityLimit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2VelocityLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SE2VelocityLimit";
  }
  protected:
  explicit SE2VelocityLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxVelFieldNumber = 1,
    kMinVelFieldNumber = 2,
  };
  // .rocos.SE2Velocity max_vel = 1;
  bool has_max_vel() const;
  private:
  bool _internal_has_max_vel() const;
  public:
  void clear_max_vel();
  const ::rocos::SE2Velocity& max_vel() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE2Velocity* release_max_vel();
  ::rocos::SE2Velocity* mutable_max_vel();
  void set_allocated_max_vel(::rocos::SE2Velocity* max_vel);
  private:
  const ::rocos::SE2Velocity& _internal_max_vel() const;
  ::rocos::SE2Velocity* _internal_mutable_max_vel();
  public:
  void unsafe_arena_set_allocated_max_vel(
      ::rocos::SE2Velocity* max_vel);
  ::rocos::SE2Velocity* unsafe_arena_release_max_vel();

  // .rocos.SE2Velocity min_vel = 2;
  bool has_min_vel() const;
  private:
  bool _internal_has_min_vel() const;
  public:
  void clear_min_vel();
  const ::rocos::SE2Velocity& min_vel() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE2Velocity* release_min_vel();
  ::rocos::SE2Velocity* mutable_min_vel();
  void set_allocated_min_vel(::rocos::SE2Velocity* min_vel);
  private:
  const ::rocos::SE2Velocity& _internal_min_vel() const;
  ::rocos::SE2Velocity* _internal_mutable_min_vel();
  public:
  void unsafe_arena_set_allocated_min_vel(
      ::rocos::SE2Velocity* min_vel);
  ::rocos::SE2Velocity* unsafe_arena_release_min_vel();

  // @@protoc_insertion_point(class_scope:rocos.SE2VelocityLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::SE2Velocity* max_vel_;
  ::rocos::SE2Velocity* min_vel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Pose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SE3Pose) */ {
 public:
  inline SE3Pose() : SE3Pose(nullptr) {}
  ~SE3Pose() override;
  explicit constexpr SE3Pose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE3Pose(const SE3Pose& from);
  SE3Pose(SE3Pose&& from) noexcept
    : SE3Pose() {
    *this = ::std::move(from);
  }

  inline SE3Pose& operator=(const SE3Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Pose& operator=(SE3Pose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE3Pose& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE3Pose* internal_default_instance() {
    return reinterpret_cast<const SE3Pose*>(
               &_SE3Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SE3Pose& a, SE3Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Pose* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE3Pose* New() const final {
    return new SE3Pose();
  }

  SE3Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE3Pose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE3Pose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SE3Pose& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SE3Pose";
  }
  protected:
  explicit SE3Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .rocos.Vec3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::rocos::Vec3& position() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_position();
  ::rocos::Vec3* mutable_position();
  void set_allocated_position(::rocos::Vec3* position);
  private:
  const ::rocos::Vec3& _internal_position() const;
  ::rocos::Vec3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::rocos::Vec3* position);
  ::rocos::Vec3* unsafe_arena_release_position();

  // .rocos.Quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::rocos::Quaternion& rotation() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Quaternion* release_rotation();
  ::rocos::Quaternion* mutable_rotation();
  void set_allocated_rotation(::rocos::Quaternion* rotation);
  private:
  const ::rocos::Quaternion& _internal_rotation() const;
  ::rocos::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::rocos::Quaternion* rotation);
  ::rocos::Quaternion* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:rocos.SE3Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec3* position_;
  ::rocos::Quaternion* rotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Velocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SE3Velocity) */ {
 public:
  inline SE3Velocity() : SE3Velocity(nullptr) {}
  ~SE3Velocity() override;
  explicit constexpr SE3Velocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE3Velocity(const SE3Velocity& from);
  SE3Velocity(SE3Velocity&& from) noexcept
    : SE3Velocity() {
    *this = ::std::move(from);
  }

  inline SE3Velocity& operator=(const SE3Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Velocity& operator=(SE3Velocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE3Velocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE3Velocity* internal_default_instance() {
    return reinterpret_cast<const SE3Velocity*>(
               &_SE3Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SE3Velocity& a, SE3Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Velocity* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE3Velocity* New() const final {
    return new SE3Velocity();
  }

  SE3Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE3Velocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE3Velocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SE3Velocity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Velocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SE3Velocity";
  }
  protected:
  explicit SE3Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .rocos.Vec3 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::rocos::Vec3& linear() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_linear();
  ::rocos::Vec3* mutable_linear();
  void set_allocated_linear(::rocos::Vec3* linear);
  private:
  const ::rocos::Vec3& _internal_linear() const;
  ::rocos::Vec3* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::rocos::Vec3* linear);
  ::rocos::Vec3* unsafe_arena_release_linear();

  // .rocos.Vec3 angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::rocos::Vec3& angular() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_angular();
  ::rocos::Vec3* mutable_angular();
  void set_allocated_angular(::rocos::Vec3* angular);
  private:
  const ::rocos::Vec3& _internal_angular() const;
  ::rocos::Vec3* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::rocos::Vec3* angular);
  ::rocos::Vec3* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:rocos.SE3Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec3* linear_;
  ::rocos::Vec3* angular_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Wrench final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Wrench) */ {
 public:
  inline Wrench() : Wrench(nullptr) {}
  ~Wrench() override;
  explicit constexpr Wrench(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Wrench(const Wrench& from);
  Wrench(Wrench&& from) noexcept
    : Wrench() {
    *this = ::std::move(from);
  }

  inline Wrench& operator=(const Wrench& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrench& operator=(Wrench&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Wrench& default_instance() {
    return *internal_default_instance();
  }
  static inline const Wrench* internal_default_instance() {
    return reinterpret_cast<const Wrench*>(
               &_Wrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Wrench& a, Wrench& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrench* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrench* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wrench* New() const final {
    return new Wrench();
  }

  Wrench* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wrench>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Wrench& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Wrench& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrench* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Wrench";
  }
  protected:
  explicit Wrench(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 1,
    kTorqueFieldNumber = 2,
  };
  // .rocos.Vec3 force = 1;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  const ::rocos::Vec3& force() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_force();
  ::rocos::Vec3* mutable_force();
  void set_allocated_force(::rocos::Vec3* force);
  private:
  const ::rocos::Vec3& _internal_force() const;
  ::rocos::Vec3* _internal_mutable_force();
  public:
  void unsafe_arena_set_allocated_force(
      ::rocos::Vec3* force);
  ::rocos::Vec3* unsafe_arena_release_force();

  // .rocos.Vec3 torque = 2;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  const ::rocos::Vec3& torque() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_torque();
  ::rocos::Vec3* mutable_torque();
  void set_allocated_torque(::rocos::Vec3* torque);
  private:
  const ::rocos::Vec3& _internal_torque() const;
  ::rocos::Vec3* _internal_mutable_torque();
  public:
  void unsafe_arena_set_allocated_torque(
      ::rocos::Vec3* torque);
  ::rocos::Vec3* unsafe_arena_release_torque();

  // @@protoc_insertion_point(class_scope:rocos.Wrench)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec3* force_;
  ::rocos::Vec3* torque_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class FrameTreeSnapshot_ParentEdge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.FrameTreeSnapshot.ParentEdge) */ {
 public:
  inline FrameTreeSnapshot_ParentEdge() : FrameTreeSnapshot_ParentEdge(nullptr) {}
  ~FrameTreeSnapshot_ParentEdge() override;
  explicit constexpr FrameTreeSnapshot_ParentEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameTreeSnapshot_ParentEdge(const FrameTreeSnapshot_ParentEdge& from);
  FrameTreeSnapshot_ParentEdge(FrameTreeSnapshot_ParentEdge&& from) noexcept
    : FrameTreeSnapshot_ParentEdge() {
    *this = ::std::move(from);
  }

  inline FrameTreeSnapshot_ParentEdge& operator=(const FrameTreeSnapshot_ParentEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameTreeSnapshot_ParentEdge& operator=(FrameTreeSnapshot_ParentEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameTreeSnapshot_ParentEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameTreeSnapshot_ParentEdge* internal_default_instance() {
    return reinterpret_cast<const FrameTreeSnapshot_ParentEdge*>(
               &_FrameTreeSnapshot_ParentEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FrameTreeSnapshot_ParentEdge& a, FrameTreeSnapshot_ParentEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameTreeSnapshot_ParentEdge* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameTreeSnapshot_ParentEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameTreeSnapshot_ParentEdge* New() const final {
    return new FrameTreeSnapshot_ParentEdge();
  }

  FrameTreeSnapshot_ParentEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameTreeSnapshot_ParentEdge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameTreeSnapshot_ParentEdge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FrameTreeSnapshot_ParentEdge& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameTreeSnapshot_ParentEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.FrameTreeSnapshot.ParentEdge";
  }
  protected:
  explicit FrameTreeSnapshot_ParentEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFrameNameFieldNumber = 1,
    kParentTformChildFieldNumber = 2,
  };
  // string parent_frame_name = 1;
  void clear_parent_frame_name();
  const std::string& parent_frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_frame_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_frame_name();
  void set_allocated_parent_frame_name(std::string* parent_frame_name);
  private:
  const std::string& _internal_parent_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_frame_name(const std::string& value);
  std::string* _internal_mutable_parent_frame_name();
  public:

  // .rocos.SE3Pose parent_tform_child = 2;
  bool has_parent_tform_child() const;
  private:
  bool _internal_has_parent_tform_child() const;
  public:
  void clear_parent_tform_child();
  const ::rocos::SE3Pose& parent_tform_child() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_parent_tform_child();
  ::rocos::SE3Pose* mutable_parent_tform_child();
  void set_allocated_parent_tform_child(::rocos::SE3Pose* parent_tform_child);
  private:
  const ::rocos::SE3Pose& _internal_parent_tform_child() const;
  ::rocos::SE3Pose* _internal_mutable_parent_tform_child();
  public:
  void unsafe_arena_set_allocated_parent_tform_child(
      ::rocos::SE3Pose* parent_tform_child);
  ::rocos::SE3Pose* unsafe_arena_release_parent_tform_child();

  // @@protoc_insertion_point(class_scope:rocos.FrameTreeSnapshot.ParentEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_frame_name_;
  ::rocos::SE3Pose* parent_tform_child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse, 
    std::string, ::rocos::FrameTreeSnapshot_ParentEdge,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse, 
    std::string, ::rocos::FrameTreeSnapshot_ParentEdge,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse();
  explicit constexpr FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse& other);
  static const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse*>(&_FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "rocos.FrameTreeSnapshot.ChildToParentEdgeMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class FrameTreeSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.FrameTreeSnapshot) */ {
 public:
  inline FrameTreeSnapshot() : FrameTreeSnapshot(nullptr) {}
  ~FrameTreeSnapshot() override;
  explicit constexpr FrameTreeSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameTreeSnapshot(const FrameTreeSnapshot& from);
  FrameTreeSnapshot(FrameTreeSnapshot&& from) noexcept
    : FrameTreeSnapshot() {
    *this = ::std::move(from);
  }

  inline FrameTreeSnapshot& operator=(const FrameTreeSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameTreeSnapshot& operator=(FrameTreeSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameTreeSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameTreeSnapshot* internal_default_instance() {
    return reinterpret_cast<const FrameTreeSnapshot*>(
               &_FrameTreeSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FrameTreeSnapshot& a, FrameTreeSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameTreeSnapshot* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameTreeSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameTreeSnapshot* New() const final {
    return new FrameTreeSnapshot();
  }

  FrameTreeSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameTreeSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameTreeSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FrameTreeSnapshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameTreeSnapshot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.FrameTreeSnapshot";
  }
  protected:
  explicit FrameTreeSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FrameTreeSnapshot_ParentEdge ParentEdge;

  // accessors -------------------------------------------------------

  enum : int {
    kChildToParentEdgeMapFieldNumber = 1,
  };
  // map<string, .rocos.FrameTreeSnapshot.ParentEdge> child_to_parent_edge_map = 1;
  int child_to_parent_edge_map_size() const;
  private:
  int _internal_child_to_parent_edge_map_size() const;
  public:
  void clear_child_to_parent_edge_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >&
      _internal_child_to_parent_edge_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >*
      _internal_mutable_child_to_parent_edge_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >&
      child_to_parent_edge_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >*
      mutable_child_to_parent_edge_map();

  // @@protoc_insertion_point(class_scope:rocos.FrameTreeSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse,
      std::string, ::rocos::FrameTreeSnapshot_ParentEdge,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> child_to_parent_edge_map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Box2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Box2) */ {
 public:
  inline Box2() : Box2(nullptr) {}
  ~Box2() override;
  explicit constexpr Box2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box2(const Box2& from);
  Box2(Box2&& from) noexcept
    : Box2() {
    *this = ::std::move(from);
  }

  inline Box2& operator=(const Box2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2& operator=(Box2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box2* internal_default_instance() {
    return reinterpret_cast<const Box2*>(
               &_Box2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Box2& a, Box2& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box2* New() const final {
    return new Box2();
  }

  Box2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Box2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Box2";
  }
  protected:
  explicit Box2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .rocos.Vec2 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::rocos::Vec2& size() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec2* release_size();
  ::rocos::Vec2* mutable_size();
  void set_allocated_size(::rocos::Vec2* size);
  private:
  const ::rocos::Vec2& _internal_size() const;
  ::rocos::Vec2* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::rocos::Vec2* size);
  ::rocos::Vec2* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:rocos.Box2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec2* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Box2WithFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Box2WithFrame) */ {
 public:
  inline Box2WithFrame() : Box2WithFrame(nullptr) {}
  ~Box2WithFrame() override;
  explicit constexpr Box2WithFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box2WithFrame(const Box2WithFrame& from);
  Box2WithFrame(Box2WithFrame&& from) noexcept
    : Box2WithFrame() {
    *this = ::std::move(from);
  }

  inline Box2WithFrame& operator=(const Box2WithFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2WithFrame& operator=(Box2WithFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box2WithFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box2WithFrame* internal_default_instance() {
    return reinterpret_cast<const Box2WithFrame*>(
               &_Box2WithFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Box2WithFrame& a, Box2WithFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2WithFrame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2WithFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box2WithFrame* New() const final {
    return new Box2WithFrame();
  }

  Box2WithFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box2WithFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box2WithFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Box2WithFrame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2WithFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Box2WithFrame";
  }
  protected:
  explicit Box2WithFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kBoxFieldNumber = 1,
    kFrameNameTformBoxFieldNumber = 3,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .rocos.Box2 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::rocos::Box2& box() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Box2* release_box();
  ::rocos::Box2* mutable_box();
  void set_allocated_box(::rocos::Box2* box);
  private:
  const ::rocos::Box2& _internal_box() const;
  ::rocos::Box2* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::rocos::Box2* box);
  ::rocos::Box2* unsafe_arena_release_box();

  // .rocos.SE3Pose frame_name_tform_box = 3;
  bool has_frame_name_tform_box() const;
  private:
  bool _internal_has_frame_name_tform_box() const;
  public:
  void clear_frame_name_tform_box();
  const ::rocos::SE3Pose& frame_name_tform_box() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_frame_name_tform_box();
  ::rocos::SE3Pose* mutable_frame_name_tform_box();
  void set_allocated_frame_name_tform_box(::rocos::SE3Pose* frame_name_tform_box);
  private:
  const ::rocos::SE3Pose& _internal_frame_name_tform_box() const;
  ::rocos::SE3Pose* _internal_mutable_frame_name_tform_box();
  public:
  void unsafe_arena_set_allocated_frame_name_tform_box(
      ::rocos::SE3Pose* frame_name_tform_box);
  ::rocos::SE3Pose* unsafe_arena_release_frame_name_tform_box();

  // @@protoc_insertion_point(class_scope:rocos.Box2WithFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
  ::rocos::Box2* box_;
  ::rocos::SE3Pose* frame_name_tform_box_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Box3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Box3) */ {
 public:
  inline Box3() : Box3(nullptr) {}
  ~Box3() override;
  explicit constexpr Box3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box3(const Box3& from);
  Box3(Box3&& from) noexcept
    : Box3() {
    *this = ::std::move(from);
  }

  inline Box3& operator=(const Box3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box3& operator=(Box3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box3* internal_default_instance() {
    return reinterpret_cast<const Box3*>(
               &_Box3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Box3& a, Box3& b) {
    a.Swap(&b);
  }
  inline void Swap(Box3* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box3* New() const final {
    return new Box3();
  }

  Box3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Box3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Box3";
  }
  protected:
  explicit Box3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .rocos.Vec3 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::rocos::Vec3& size() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_size();
  ::rocos::Vec3* mutable_size();
  void set_allocated_size(::rocos::Vec3* size);
  private:
  const ::rocos::Vec3& _internal_size() const;
  ::rocos::Vec3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::rocos::Vec3* size);
  ::rocos::Vec3* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:rocos.Box3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec3* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Box3WithFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Box3WithFrame) */ {
 public:
  inline Box3WithFrame() : Box3WithFrame(nullptr) {}
  ~Box3WithFrame() override;
  explicit constexpr Box3WithFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box3WithFrame(const Box3WithFrame& from);
  Box3WithFrame(Box3WithFrame&& from) noexcept
    : Box3WithFrame() {
    *this = ::std::move(from);
  }

  inline Box3WithFrame& operator=(const Box3WithFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box3WithFrame& operator=(Box3WithFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box3WithFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box3WithFrame* internal_default_instance() {
    return reinterpret_cast<const Box3WithFrame*>(
               &_Box3WithFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Box3WithFrame& a, Box3WithFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(Box3WithFrame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box3WithFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box3WithFrame* New() const final {
    return new Box3WithFrame();
  }

  Box3WithFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box3WithFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box3WithFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Box3WithFrame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3WithFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Box3WithFrame";
  }
  protected:
  explicit Box3WithFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kBoxFieldNumber = 1,
    kFrameNameTformBoxFieldNumber = 3,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .rocos.Box3 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::rocos::Box3& box() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Box3* release_box();
  ::rocos::Box3* mutable_box();
  void set_allocated_box(::rocos::Box3* box);
  private:
  const ::rocos::Box3& _internal_box() const;
  ::rocos::Box3* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::rocos::Box3* box);
  ::rocos::Box3* unsafe_arena_release_box();

  // .rocos.SE3Pose frame_name_tform_box = 3;
  bool has_frame_name_tform_box() const;
  private:
  bool _internal_has_frame_name_tform_box() const;
  public:
  void clear_frame_name_tform_box();
  const ::rocos::SE3Pose& frame_name_tform_box() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::SE3Pose* release_frame_name_tform_box();
  ::rocos::SE3Pose* mutable_frame_name_tform_box();
  void set_allocated_frame_name_tform_box(::rocos::SE3Pose* frame_name_tform_box);
  private:
  const ::rocos::SE3Pose& _internal_frame_name_tform_box() const;
  ::rocos::SE3Pose* _internal_mutable_frame_name_tform_box();
  public:
  void unsafe_arena_set_allocated_frame_name_tform_box(
      ::rocos::SE3Pose* frame_name_tform_box);
  ::rocos::SE3Pose* unsafe_arena_release_frame_name_tform_box();

  // @@protoc_insertion_point(class_scope:rocos.Box3WithFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
  ::rocos::Box3* box_;
  ::rocos::SE3Pose* frame_name_tform_box_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Matrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Matrix) */ {
 public:
  inline Matrix() : Matrix(nullptr) {}
  ~Matrix() override;
  explicit constexpr Matrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrix(const Matrix& from);
  Matrix(Matrix&& from) noexcept
    : Matrix() {
    *this = ::std::move(from);
  }

  inline Matrix& operator=(const Matrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrix& operator=(Matrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Matrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrix* internal_default_instance() {
    return reinterpret_cast<const Matrix*>(
               &_Matrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Matrix& a, Matrix& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrix* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Matrix* New() const final {
    return new Matrix();
  }

  Matrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Matrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Matrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Matrix& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Matrix* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Matrix";
  }
  protected:
  explicit Matrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated double values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // int32 rows = 1;
  void clear_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 rows() const;
  void set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rows() const;
  void _internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cols = 2;
  void clear_cols();
  ::PROTOBUF_NAMESPACE_ID::int32 cols() const;
  void set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cols() const;
  void _internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Matrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
  ::PROTOBUF_NAMESPACE_ID::int32 rows_;
  ::PROTOBUF_NAMESPACE_ID::int32 cols_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Covariance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.SE3Covariance) */ {
 public:
  inline SE3Covariance() : SE3Covariance(nullptr) {}
  ~SE3Covariance() override;
  explicit constexpr SE3Covariance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SE3Covariance(const SE3Covariance& from);
  SE3Covariance(SE3Covariance&& from) noexcept
    : SE3Covariance() {
    *this = ::std::move(from);
  }

  inline SE3Covariance& operator=(const SE3Covariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Covariance& operator=(SE3Covariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SE3Covariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SE3Covariance* internal_default_instance() {
    return reinterpret_cast<const SE3Covariance*>(
               &_SE3Covariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SE3Covariance& a, SE3Covariance& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Covariance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Covariance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE3Covariance* New() const final {
    return new SE3Covariance();
  }

  SE3Covariance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE3Covariance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SE3Covariance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SE3Covariance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Covariance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.SE3Covariance";
  }
  protected:
  explicit SE3Covariance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatrixFieldNumber = 1,
    kYawVarianceFieldNumber = 2,
    kCovXxFieldNumber = 3,
    kCovXyFieldNumber = 4,
    kCovXzFieldNumber = 5,
    kCovYxFieldNumber = 6,
    kCovYyFieldNumber = 7,
    kCovYzFieldNumber = 8,
    kCovZxFieldNumber = 9,
    kCovZyFieldNumber = 10,
    kCovZzFieldNumber = 11,
  };
  // .rocos.Matrix matrix = 1;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;
  public:
  void clear_matrix();
  const ::rocos::Matrix& matrix() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Matrix* release_matrix();
  ::rocos::Matrix* mutable_matrix();
  void set_allocated_matrix(::rocos::Matrix* matrix);
  private:
  const ::rocos::Matrix& _internal_matrix() const;
  ::rocos::Matrix* _internal_mutable_matrix();
  public:
  void unsafe_arena_set_allocated_matrix(
      ::rocos::Matrix* matrix);
  ::rocos::Matrix* unsafe_arena_release_matrix();

  // double yaw_variance = 2 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_yaw_variance();
  PROTOBUF_DEPRECATED double yaw_variance() const;
  PROTOBUF_DEPRECATED void set_yaw_variance(double value);
  private:
  double _internal_yaw_variance() const;
  void _internal_set_yaw_variance(double value);
  public:

  // double cov_xx = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_xx();
  PROTOBUF_DEPRECATED double cov_xx() const;
  PROTOBUF_DEPRECATED void set_cov_xx(double value);
  private:
  double _internal_cov_xx() const;
  void _internal_set_cov_xx(double value);
  public:

  // double cov_xy = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_xy();
  PROTOBUF_DEPRECATED double cov_xy() const;
  PROTOBUF_DEPRECATED void set_cov_xy(double value);
  private:
  double _internal_cov_xy() const;
  void _internal_set_cov_xy(double value);
  public:

  // double cov_xz = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_xz();
  PROTOBUF_DEPRECATED double cov_xz() const;
  PROTOBUF_DEPRECATED void set_cov_xz(double value);
  private:
  double _internal_cov_xz() const;
  void _internal_set_cov_xz(double value);
  public:

  // double cov_yx = 6 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_yx();
  PROTOBUF_DEPRECATED double cov_yx() const;
  PROTOBUF_DEPRECATED void set_cov_yx(double value);
  private:
  double _internal_cov_yx() const;
  void _internal_set_cov_yx(double value);
  public:

  // double cov_yy = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_yy();
  PROTOBUF_DEPRECATED double cov_yy() const;
  PROTOBUF_DEPRECATED void set_cov_yy(double value);
  private:
  double _internal_cov_yy() const;
  void _internal_set_cov_yy(double value);
  public:

  // double cov_yz = 8 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_yz();
  PROTOBUF_DEPRECATED double cov_yz() const;
  PROTOBUF_DEPRECATED void set_cov_yz(double value);
  private:
  double _internal_cov_yz() const;
  void _internal_set_cov_yz(double value);
  public:

  // double cov_zx = 9 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_zx();
  PROTOBUF_DEPRECATED double cov_zx() const;
  PROTOBUF_DEPRECATED void set_cov_zx(double value);
  private:
  double _internal_cov_zx() const;
  void _internal_set_cov_zx(double value);
  public:

  // double cov_zy = 10 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_zy();
  PROTOBUF_DEPRECATED double cov_zy() const;
  PROTOBUF_DEPRECATED void set_cov_zy(double value);
  private:
  double _internal_cov_zy() const;
  void _internal_set_cov_zy(double value);
  public:

  // double cov_zz = 11 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_cov_zz();
  PROTOBUF_DEPRECATED double cov_zz() const;
  PROTOBUF_DEPRECATED void set_cov_zz(double value);
  private:
  double _internal_cov_zz() const;
  void _internal_set_cov_zz(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.SE3Covariance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Matrix* matrix_;
  double yaw_variance_;
  double cov_xx_;
  double cov_xy_;
  double cov_xz_;
  double cov_yx_;
  double cov_yy_;
  double cov_yz_;
  double cov_zx_;
  double cov_zy_;
  double cov_zz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PolyLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.PolyLine) */ {
 public:
  inline PolyLine() : PolyLine(nullptr) {}
  ~PolyLine() override;
  explicit constexpr PolyLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyLine(const PolyLine& from);
  PolyLine(PolyLine&& from) noexcept
    : PolyLine() {
    *this = ::std::move(from);
  }

  inline PolyLine& operator=(const PolyLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLine& operator=(PolyLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolyLine* internal_default_instance() {
    return reinterpret_cast<const PolyLine*>(
               &_PolyLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PolyLine& a, PolyLine& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLine* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PolyLine* New() const final {
    return new PolyLine();
  }

  PolyLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PolyLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolyLine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.PolyLine";
  }
  protected:
  explicit PolyLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .rocos.Vec2 points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::rocos::Vec2* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >*
      mutable_points();
  private:
  const ::rocos::Vec2& _internal_points(int index) const;
  ::rocos::Vec2* _internal_add_points();
  public:
  const ::rocos::Vec2& points(int index) const;
  ::rocos::Vec2* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >&
      points() const;

  // @@protoc_insertion_point(class_scope:rocos.PolyLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 > points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit constexpr Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return new Polygon();
  }

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Polygon& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexesFieldNumber = 1,
  };
  // repeated .rocos.Vec2 vertexes = 1;
  int vertexes_size() const;
  private:
  int _internal_vertexes_size() const;
  public:
  void clear_vertexes();
  ::rocos::Vec2* mutable_vertexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >*
      mutable_vertexes();
  private:
  const ::rocos::Vec2& _internal_vertexes(int index) const;
  ::rocos::Vec2* _internal_add_vertexes();
  public:
  const ::rocos::Vec2& vertexes(int index) const;
  ::rocos::Vec2* add_vertexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >&
      vertexes() const;

  // @@protoc_insertion_point(class_scope:rocos.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 > vertexes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PolygonWithExclusions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.PolygonWithExclusions) */ {
 public:
  inline PolygonWithExclusions() : PolygonWithExclusions(nullptr) {}
  ~PolygonWithExclusions() override;
  explicit constexpr PolygonWithExclusions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolygonWithExclusions(const PolygonWithExclusions& from);
  PolygonWithExclusions(PolygonWithExclusions&& from) noexcept
    : PolygonWithExclusions() {
    *this = ::std::move(from);
  }

  inline PolygonWithExclusions& operator=(const PolygonWithExclusions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolygonWithExclusions& operator=(PolygonWithExclusions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolygonWithExclusions& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolygonWithExclusions* internal_default_instance() {
    return reinterpret_cast<const PolygonWithExclusions*>(
               &_PolygonWithExclusions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PolygonWithExclusions& a, PolygonWithExclusions& b) {
    a.Swap(&b);
  }
  inline void Swap(PolygonWithExclusions* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolygonWithExclusions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PolygonWithExclusions* New() const final {
    return new PolygonWithExclusions();
  }

  PolygonWithExclusions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PolygonWithExclusions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolygonWithExclusions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolygonWithExclusions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolygonWithExclusions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.PolygonWithExclusions";
  }
  protected:
  explicit PolygonWithExclusions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExclusionsFieldNumber = 6,
    kInclusionFieldNumber = 5,
  };
  // repeated .rocos.Polygon exclusions = 6;
  int exclusions_size() const;
  private:
  int _internal_exclusions_size() const;
  public:
  void clear_exclusions();
  ::rocos::Polygon* mutable_exclusions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Polygon >*
      mutable_exclusions();
  private:
  const ::rocos::Polygon& _internal_exclusions(int index) const;
  ::rocos::Polygon* _internal_add_exclusions();
  public:
  const ::rocos::Polygon& exclusions(int index) const;
  ::rocos::Polygon* add_exclusions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Polygon >&
      exclusions() const;

  // .rocos.Polygon inclusion = 5;
  bool has_inclusion() const;
  private:
  bool _internal_has_inclusion() const;
  public:
  void clear_inclusion();
  const ::rocos::Polygon& inclusion() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Polygon* release_inclusion();
  ::rocos::Polygon* mutable_inclusion();
  void set_allocated_inclusion(::rocos::Polygon* inclusion);
  private:
  const ::rocos::Polygon& _internal_inclusion() const;
  ::rocos::Polygon* _internal_mutable_inclusion();
  public:
  void unsafe_arena_set_allocated_inclusion(
      ::rocos::Polygon* inclusion);
  ::rocos::Polygon* unsafe_arena_release_inclusion();

  // @@protoc_insertion_point(class_scope:rocos.PolygonWithExclusions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Polygon > exclusions_;
  ::rocos::Polygon* inclusion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Circle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {}
  ~Circle() override;
  explicit constexpr Circle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Circle(const Circle& from);
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Circle* New() const final {
    return new Circle();
  }

  Circle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Circle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Circle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Circle";
  }
  protected:
  explicit Circle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterPtFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .rocos.Vec2 center_pt = 1;
  bool has_center_pt() const;
  private:
  bool _internal_has_center_pt() const;
  public:
  void clear_center_pt();
  const ::rocos::Vec2& center_pt() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec2* release_center_pt();
  ::rocos::Vec2* mutable_center_pt();
  void set_allocated_center_pt(::rocos::Vec2* center_pt);
  private:
  const ::rocos::Vec2& _internal_center_pt() const;
  ::rocos::Vec2* _internal_mutable_center_pt();
  public:
  void unsafe_arena_set_allocated_center_pt(
      ::rocos::Vec2* center_pt);
  ::rocos::Vec2* unsafe_arena_release_center_pt();

  // double radius = 2;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Circle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::rocos::Vec2* center_pt_;
  double radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Area final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Area) */ {
 public:
  inline Area() : Area(nullptr) {}
  ~Area() override;
  explicit constexpr Area(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Area(const Area& from);
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  inline Area& operator=(Area&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Area& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kPolygon = 1,
    kCircle = 2,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }
  inline void Swap(Area* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Area* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Area* New() const final {
    return new Area();
  }

  Area* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Area>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Area& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Area& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Area* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Area";
  }
  protected:
  explicit Area(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 1,
    kCircleFieldNumber = 2,
  };
  // .rocos.Polygon polygon = 1;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::rocos::Polygon& polygon() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Polygon* release_polygon();
  ::rocos::Polygon* mutable_polygon();
  void set_allocated_polygon(::rocos::Polygon* polygon);
  private:
  const ::rocos::Polygon& _internal_polygon() const;
  ::rocos::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::rocos::Polygon* polygon);
  ::rocos::Polygon* unsafe_arena_release_polygon();

  // .rocos.Circle circle = 2;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;
  public:
  void clear_circle();
  const ::rocos::Circle& circle() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Circle* release_circle();
  ::rocos::Circle* mutable_circle();
  void set_allocated_circle(::rocos::Circle* circle);
  private:
  const ::rocos::Circle& _internal_circle() const;
  ::rocos::Circle* _internal_mutable_circle();
  public:
  void unsafe_arena_set_allocated_circle(
      ::rocos::Circle* circle);
  ::rocos::Circle* unsafe_arena_release_circle();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:rocos.Area)
 private:
  class _Internal;
  void set_has_polygon();
  void set_has_circle();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union GeometryUnion {
    constexpr GeometryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::Polygon* polygon_;
    ::rocos::Circle* circle_;
  } geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Volume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Volume) */ {
 public:
  inline Volume() : Volume(nullptr) {}
  ~Volume() override;
  explicit constexpr Volume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Volume(const Volume& from);
  Volume(Volume&& from) noexcept
    : Volume() {
    *this = ::std::move(from);
  }

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  inline Volume& operator=(Volume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Volume& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kBox = 1,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const Volume* internal_default_instance() {
    return reinterpret_cast<const Volume*>(
               &_Volume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Volume& a, Volume& b) {
    a.Swap(&b);
  }
  inline void Swap(Volume* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Volume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Volume* New() const final {
    return new Volume();
  }

  Volume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Volume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Volume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Volume& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Volume* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Volume";
  }
  protected:
  explicit Volume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 1,
  };
  // .rocos.Vec3 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::rocos::Vec3& box() const;
  PROTOBUF_MUST_USE_RESULT ::rocos::Vec3* release_box();
  ::rocos::Vec3* mutable_box();
  void set_allocated_box(::rocos::Vec3* box);
  private:
  const ::rocos::Vec3& _internal_box() const;
  ::rocos::Vec3* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::rocos::Vec3* box);
  ::rocos::Vec3* unsafe_arena_release_box();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:rocos.Volume)
 private:
  class _Internal;
  void set_has_box();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union GeometryUnion {
    constexpr GeometryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::rocos::Vec3* box_;
  } geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Bounds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Bounds) */ {
 public:
  inline Bounds() : Bounds(nullptr) {}
  ~Bounds() override;
  explicit constexpr Bounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bounds(const Bounds& from);
  Bounds(Bounds&& from) noexcept
    : Bounds() {
    *this = ::std::move(from);
  }

  inline Bounds& operator=(const Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bounds& operator=(Bounds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bounds* internal_default_instance() {
    return reinterpret_cast<const Bounds*>(
               &_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Bounds& a, Bounds& b) {
    a.Swap(&b);
  }
  inline void Swap(Bounds* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bounds* New() const final {
    return new Bounds();
  }

  Bounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bounds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bounds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bounds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Bounds";
  }
  protected:
  explicit Bounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerFieldNumber = 1,
    kUpperFieldNumber = 2,
  };
  // double lower = 1;
  void clear_lower();
  double lower() const;
  void set_lower(double value);
  private:
  double _internal_lower() const;
  void _internal_set_lower(double value);
  public:

  // double upper = 2;
  void clear_upper();
  double upper() const;
  void set_upper(double value);
  private:
  double _internal_upper() const;
  void _internal_set_upper(double value);
  public:

  // @@protoc_insertion_point(class_scope:rocos.Bounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double lower_;
  double upper_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Vec2Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Vec2Value) */ {
 public:
  inline Vec2Value() : Vec2Value(nullptr) {}
  ~Vec2Value() override;
  explicit constexpr Vec2Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2Value(const Vec2Value& from);
  Vec2Value(Vec2Value&& from) noexcept
    : Vec2Value() {
    *this = ::std::move(from);
  }

  inline Vec2Value& operator=(const Vec2Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2Value& operator=(Vec2Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2Value* internal_default_instance() {
    return reinterpret_cast<const Vec2Value*>(
               &_Vec2Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Vec2Value& a, Vec2Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2Value* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2Value* New() const final {
    return new Vec2Value();
  }

  Vec2Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec2Value& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Vec2Value";
  }
  protected:
  explicit Vec2Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // .google.protobuf.DoubleValue x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& x() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_x();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_x();
  void set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_x() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_x();

  // .google.protobuf.DoubleValue y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& y() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_y();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_y();
  void set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_y() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_y();

  // @@protoc_insertion_point(class_scope:rocos.Vec2Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* x_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Vec3Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.Vec3Value) */ {
 public:
  inline Vec3Value() : Vec3Value(nullptr) {}
  ~Vec3Value() override;
  explicit constexpr Vec3Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3Value(const Vec3Value& from);
  Vec3Value(Vec3Value&& from) noexcept
    : Vec3Value() {
    *this = ::std::move(from);
  }

  inline Vec3Value& operator=(const Vec3Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3Value& operator=(Vec3Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3Value* internal_default_instance() {
    return reinterpret_cast<const Vec3Value*>(
               &_Vec3Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Vec3Value& a, Vec3Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3Value* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3Value* New() const final {
    return new Vec3Value();
  }

  Vec3Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec3Value& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.Vec3Value";
  }
  protected:
  explicit Vec3Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& x() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_x();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_x();
  void set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_x() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_x();

  // .google.protobuf.DoubleValue y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& y() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_y();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_y();
  void set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_y() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_y();

  // .google.protobuf.DoubleValue z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& z() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_z();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_z();
  void set_allocated_z(PROTOBUF_NAMESPACE_ID::DoubleValue* z);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_z() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      PROTOBUF_NAMESPACE_ID::DoubleValue* z);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:rocos.Vec3Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* x_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* y_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class JointArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rocos.JointArray) */ {
 public:
  inline JointArray() : JointArray(nullptr) {}
  ~JointArray() override;
  explicit constexpr JointArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointArray(const JointArray& from);
  JointArray(JointArray&& from) noexcept
    : JointArray() {
    *this = ::std::move(from);
  }

  inline JointArray& operator=(const JointArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointArray& operator=(JointArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointArray* internal_default_instance() {
    return reinterpret_cast<const JointArray*>(
               &_JointArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(JointArray& a, JointArray& b) {
    a.Swap(&b);
  }
  inline void Swap(JointArray* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointArray* New() const final {
    return new JointArray();
  }

  JointArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JointArray& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointArray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rocos.JointArray";
  }
  protected:
  explicit JointArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated double data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:rocos.JointArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2

// double x = 1;
inline void Vec2::clear_x() {
  x_ = 0;
}
inline double Vec2::_internal_x() const {
  return x_;
}
inline double Vec2::x() const {
  // @@protoc_insertion_point(field_get:rocos.Vec2.x)
  return _internal_x();
}
inline void Vec2::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec2::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rocos.Vec2.x)
}

// double y = 2;
inline void Vec2::clear_y() {
  y_ = 0;
}
inline double Vec2::_internal_y() const {
  return y_;
}
inline double Vec2::y() const {
  // @@protoc_insertion_point(field_get:rocos.Vec2.y)
  return _internal_y();
}
inline void Vec2::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec2::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rocos.Vec2.y)
}

// -------------------------------------------------------------------

// Vec3

// double x = 1;
inline void Vec3::clear_x() {
  x_ = 0;
}
inline double Vec3::_internal_x() const {
  return x_;
}
inline double Vec3::x() const {
  // @@protoc_insertion_point(field_get:rocos.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rocos.Vec3.x)
}

// double y = 2;
inline void Vec3::clear_y() {
  y_ = 0;
}
inline double Vec3::_internal_y() const {
  return y_;
}
inline double Vec3::y() const {
  // @@protoc_insertion_point(field_get:rocos.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rocos.Vec3.y)
}

// double z = 3;
inline void Vec3::clear_z() {
  z_ = 0;
}
inline double Vec3::_internal_z() const {
  return z_;
}
inline double Vec3::z() const {
  // @@protoc_insertion_point(field_get:rocos.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vec3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:rocos.Vec3.z)
}

// -------------------------------------------------------------------

// CylindricalCoordinate

// double r = 1;
inline void CylindricalCoordinate::clear_r() {
  r_ = 0;
}
inline double CylindricalCoordinate::_internal_r() const {
  return r_;
}
inline double CylindricalCoordinate::r() const {
  // @@protoc_insertion_point(field_get:rocos.CylindricalCoordinate.r)
  return _internal_r();
}
inline void CylindricalCoordinate::_internal_set_r(double value) {
  
  r_ = value;
}
inline void CylindricalCoordinate::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:rocos.CylindricalCoordinate.r)
}

// double theta = 2;
inline void CylindricalCoordinate::clear_theta() {
  theta_ = 0;
}
inline double CylindricalCoordinate::_internal_theta() const {
  return theta_;
}
inline double CylindricalCoordinate::theta() const {
  // @@protoc_insertion_point(field_get:rocos.CylindricalCoordinate.theta)
  return _internal_theta();
}
inline void CylindricalCoordinate::_internal_set_theta(double value) {
  
  theta_ = value;
}
inline void CylindricalCoordinate::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:rocos.CylindricalCoordinate.theta)
}

// double z = 3;
inline void CylindricalCoordinate::clear_z() {
  z_ = 0;
}
inline double CylindricalCoordinate::_internal_z() const {
  return z_;
}
inline double CylindricalCoordinate::z() const {
  // @@protoc_insertion_point(field_get:rocos.CylindricalCoordinate.z)
  return _internal_z();
}
inline void CylindricalCoordinate::_internal_set_z(double value) {
  
  z_ = value;
}
inline void CylindricalCoordinate::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:rocos.CylindricalCoordinate.z)
}

// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  x_ = 0;
}
inline double Quaternion::_internal_x() const {
  return x_;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:rocos.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rocos.Quaternion.x)
}

// double y = 2;
inline void Quaternion::clear_y() {
  y_ = 0;
}
inline double Quaternion::_internal_y() const {
  return y_;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:rocos.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rocos.Quaternion.y)
}

// double z = 3;
inline void Quaternion::clear_z() {
  z_ = 0;
}
inline double Quaternion::_internal_z() const {
  return z_;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:rocos.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:rocos.Quaternion.z)
}

// double w = 4;
inline void Quaternion::clear_w() {
  w_ = 0;
}
inline double Quaternion::_internal_w() const {
  return w_;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:rocos.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(double value) {
  
  w_ = value;
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:rocos.Quaternion.w)
}

// -------------------------------------------------------------------

// Plane

// .rocos.Vec3 point = 1;
inline bool Plane::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool Plane::has_point() const {
  return _internal_has_point();
}
inline void Plane::clear_point() {
  if (GetArenaForAllocation() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::rocos::Vec3& Plane::_internal_point() const {
  const ::rocos::Vec3* p = point_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Plane::point() const {
  // @@protoc_insertion_point(field_get:rocos.Plane.point)
  return _internal_point();
}
inline void Plane::unsafe_arena_set_allocated_point(
    ::rocos::Vec3* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Plane.point)
}
inline ::rocos::Vec3* Plane::release_point() {
  
  ::rocos::Vec3* temp = point_;
  point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Plane::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:rocos.Plane.point)
  
  ::rocos::Vec3* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Plane::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    point_ = p;
  }
  return point_;
}
inline ::rocos::Vec3* Plane::mutable_point() {
  ::rocos::Vec3* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:rocos.Plane.point)
  return _msg;
}
inline void Plane::set_allocated_point(::rocos::Vec3* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:rocos.Plane.point)
}

// .rocos.Vec3 normal = 2;
inline bool Plane::_internal_has_normal() const {
  return this != internal_default_instance() && normal_ != nullptr;
}
inline bool Plane::has_normal() const {
  return _internal_has_normal();
}
inline void Plane::clear_normal() {
  if (GetArenaForAllocation() == nullptr && normal_ != nullptr) {
    delete normal_;
  }
  normal_ = nullptr;
}
inline const ::rocos::Vec3& Plane::_internal_normal() const {
  const ::rocos::Vec3* p = normal_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Plane::normal() const {
  // @@protoc_insertion_point(field_get:rocos.Plane.normal)
  return _internal_normal();
}
inline void Plane::unsafe_arena_set_allocated_normal(
    ::rocos::Vec3* normal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(normal_);
  }
  normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Plane.normal)
}
inline ::rocos::Vec3* Plane::release_normal() {
  
  ::rocos::Vec3* temp = normal_;
  normal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Plane::unsafe_arena_release_normal() {
  // @@protoc_insertion_point(field_release:rocos.Plane.normal)
  
  ::rocos::Vec3* temp = normal_;
  normal_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Plane::_internal_mutable_normal() {
  
  if (normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    normal_ = p;
  }
  return normal_;
}
inline ::rocos::Vec3* Plane::mutable_normal() {
  ::rocos::Vec3* _msg = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:rocos.Plane.normal)
  return _msg;
}
inline void Plane::set_allocated_normal(::rocos::Vec3* normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete normal_;
  }
  if (normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(normal);
    if (message_arena != submessage_arena) {
      normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    
  } else {
    
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:rocos.Plane.normal)
}

// -------------------------------------------------------------------

// Quad

// .rocos.SE3Pose pose = 1;
inline bool Quad::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool Quad::has_pose() const {
  return _internal_has_pose();
}
inline void Quad::clear_pose() {
  if (GetArenaForAllocation() == nullptr && pose_ != nullptr) {
    delete pose_;
  }
  pose_ = nullptr;
}
inline const ::rocos::SE3Pose& Quad::_internal_pose() const {
  const ::rocos::SE3Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& Quad::pose() const {
  // @@protoc_insertion_point(field_get:rocos.Quad.pose)
  return _internal_pose();
}
inline void Quad::unsafe_arena_set_allocated_pose(
    ::rocos::SE3Pose* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Quad.pose)
}
inline ::rocos::SE3Pose* Quad::release_pose() {
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* Quad::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:rocos.Quad.pose)
  
  ::rocos::SE3Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* Quad::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    pose_ = p;
  }
  return pose_;
}
inline ::rocos::SE3Pose* Quad::mutable_pose() {
  ::rocos::SE3Pose* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:rocos.Quad.pose)
  return _msg;
}
inline void Quad::set_allocated_pose(::rocos::SE3Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::SE3Pose>::GetOwningArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:rocos.Quad.pose)
}

// double size = 2;
inline void Quad::clear_size() {
  size_ = 0;
}
inline double Quad::_internal_size() const {
  return size_;
}
inline double Quad::size() const {
  // @@protoc_insertion_point(field_get:rocos.Quad.size)
  return _internal_size();
}
inline void Quad::_internal_set_size(double value) {
  
  size_ = value;
}
inline void Quad::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:rocos.Quad.size)
}

// -------------------------------------------------------------------

// Ray

// .rocos.Vec3 origin = 1;
inline bool Ray::_internal_has_origin() const {
  return this != internal_default_instance() && origin_ != nullptr;
}
inline bool Ray::has_origin() const {
  return _internal_has_origin();
}
inline void Ray::clear_origin() {
  if (GetArenaForAllocation() == nullptr && origin_ != nullptr) {
    delete origin_;
  }
  origin_ = nullptr;
}
inline const ::rocos::Vec3& Ray::_internal_origin() const {
  const ::rocos::Vec3* p = origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Ray::origin() const {
  // @@protoc_insertion_point(field_get:rocos.Ray.origin)
  return _internal_origin();
}
inline void Ray::unsafe_arena_set_allocated_origin(
    ::rocos::Vec3* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_);
  }
  origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Ray.origin)
}
inline ::rocos::Vec3* Ray::release_origin() {
  
  ::rocos::Vec3* temp = origin_;
  origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Ray::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:rocos.Ray.origin)
  
  ::rocos::Vec3* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Ray::_internal_mutable_origin() {
  
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    origin_ = p;
  }
  return origin_;
}
inline ::rocos::Vec3* Ray::mutable_origin() {
  ::rocos::Vec3* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:rocos.Ray.origin)
  return _msg;
}
inline void Ray::set_allocated_origin(::rocos::Vec3* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:rocos.Ray.origin)
}

// .rocos.Vec3 direction = 2;
inline bool Ray::_internal_has_direction() const {
  return this != internal_default_instance() && direction_ != nullptr;
}
inline bool Ray::has_direction() const {
  return _internal_has_direction();
}
inline void Ray::clear_direction() {
  if (GetArenaForAllocation() == nullptr && direction_ != nullptr) {
    delete direction_;
  }
  direction_ = nullptr;
}
inline const ::rocos::Vec3& Ray::_internal_direction() const {
  const ::rocos::Vec3* p = direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Ray::direction() const {
  // @@protoc_insertion_point(field_get:rocos.Ray.direction)
  return _internal_direction();
}
inline void Ray::unsafe_arena_set_allocated_direction(
    ::rocos::Vec3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction_);
  }
  direction_ = direction;
  if (direction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Ray.direction)
}
inline ::rocos::Vec3* Ray::release_direction() {
  
  ::rocos::Vec3* temp = direction_;
  direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Ray::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:rocos.Ray.direction)
  
  ::rocos::Vec3* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Ray::_internal_mutable_direction() {
  
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    direction_ = p;
  }
  return direction_;
}
inline ::rocos::Vec3* Ray::mutable_direction() {
  ::rocos::Vec3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:rocos.Ray.direction)
  return _msg;
}
inline void Ray::set_allocated_direction(::rocos::Vec3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(direction);
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:rocos.Ray.direction)
}

// -------------------------------------------------------------------

// SE2Pose

// .rocos.Vec2 position = 1;
inline bool SE2Pose::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SE2Pose::has_position() const {
  return _internal_has_position();
}
inline void SE2Pose::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::rocos::Vec2& SE2Pose::_internal_position() const {
  const ::rocos::Vec2* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec2&>(
      ::rocos::_Vec2_default_instance_);
}
inline const ::rocos::Vec2& SE2Pose::position() const {
  // @@protoc_insertion_point(field_get:rocos.SE2Pose.position)
  return _internal_position();
}
inline void SE2Pose::unsafe_arena_set_allocated_position(
    ::rocos::Vec2* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE2Pose.position)
}
inline ::rocos::Vec2* SE2Pose::release_position() {
  
  ::rocos::Vec2* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec2* SE2Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:rocos.SE2Pose.position)
  
  ::rocos::Vec2* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::rocos::Vec2* SE2Pose::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec2>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::rocos::Vec2* SE2Pose::mutable_position() {
  ::rocos::Vec2* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:rocos.SE2Pose.position)
  return _msg;
}
inline void SE2Pose::set_allocated_position(::rocos::Vec2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec2>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE2Pose.position)
}

// double angle = 2;
inline void SE2Pose::clear_angle() {
  angle_ = 0;
}
inline double SE2Pose::_internal_angle() const {
  return angle_;
}
inline double SE2Pose::angle() const {
  // @@protoc_insertion_point(field_get:rocos.SE2Pose.angle)
  return _internal_angle();
}
inline void SE2Pose::_internal_set_angle(double value) {
  
  angle_ = value;
}
inline void SE2Pose::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:rocos.SE2Pose.angle)
}

// -------------------------------------------------------------------

// SE2Velocity

// .rocos.Vec2 linear = 1;
inline bool SE2Velocity::_internal_has_linear() const {
  return this != internal_default_instance() && linear_ != nullptr;
}
inline bool SE2Velocity::has_linear() const {
  return _internal_has_linear();
}
inline void SE2Velocity::clear_linear() {
  if (GetArenaForAllocation() == nullptr && linear_ != nullptr) {
    delete linear_;
  }
  linear_ = nullptr;
}
inline const ::rocos::Vec2& SE2Velocity::_internal_linear() const {
  const ::rocos::Vec2* p = linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec2&>(
      ::rocos::_Vec2_default_instance_);
}
inline const ::rocos::Vec2& SE2Velocity::linear() const {
  // @@protoc_insertion_point(field_get:rocos.SE2Velocity.linear)
  return _internal_linear();
}
inline void SE2Velocity::unsafe_arena_set_allocated_linear(
    ::rocos::Vec2* linear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_);
  }
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE2Velocity.linear)
}
inline ::rocos::Vec2* SE2Velocity::release_linear() {
  
  ::rocos::Vec2* temp = linear_;
  linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec2* SE2Velocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:rocos.SE2Velocity.linear)
  
  ::rocos::Vec2* temp = linear_;
  linear_ = nullptr;
  return temp;
}
inline ::rocos::Vec2* SE2Velocity::_internal_mutable_linear() {
  
  if (linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec2>(GetArenaForAllocation());
    linear_ = p;
  }
  return linear_;
}
inline ::rocos::Vec2* SE2Velocity::mutable_linear() {
  ::rocos::Vec2* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:rocos.SE2Velocity.linear)
  return _msg;
}
inline void SE2Velocity::set_allocated_linear(::rocos::Vec2* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec2>::GetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE2Velocity.linear)
}

// double angular = 2;
inline void SE2Velocity::clear_angular() {
  angular_ = 0;
}
inline double SE2Velocity::_internal_angular() const {
  return angular_;
}
inline double SE2Velocity::angular() const {
  // @@protoc_insertion_point(field_get:rocos.SE2Velocity.angular)
  return _internal_angular();
}
inline void SE2Velocity::_internal_set_angular(double value) {
  
  angular_ = value;
}
inline void SE2Velocity::set_angular(double value) {
  _internal_set_angular(value);
  // @@protoc_insertion_point(field_set:rocos.SE2Velocity.angular)
}

// -------------------------------------------------------------------

// SE2VelocityLimit

// .rocos.SE2Velocity max_vel = 1;
inline bool SE2VelocityLimit::_internal_has_max_vel() const {
  return this != internal_default_instance() && max_vel_ != nullptr;
}
inline bool SE2VelocityLimit::has_max_vel() const {
  return _internal_has_max_vel();
}
inline void SE2VelocityLimit::clear_max_vel() {
  if (GetArenaForAllocation() == nullptr && max_vel_ != nullptr) {
    delete max_vel_;
  }
  max_vel_ = nullptr;
}
inline const ::rocos::SE2Velocity& SE2VelocityLimit::_internal_max_vel() const {
  const ::rocos::SE2Velocity* p = max_vel_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE2Velocity&>(
      ::rocos::_SE2Velocity_default_instance_);
}
inline const ::rocos::SE2Velocity& SE2VelocityLimit::max_vel() const {
  // @@protoc_insertion_point(field_get:rocos.SE2VelocityLimit.max_vel)
  return _internal_max_vel();
}
inline void SE2VelocityLimit::unsafe_arena_set_allocated_max_vel(
    ::rocos::SE2Velocity* max_vel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_vel_);
  }
  max_vel_ = max_vel;
  if (max_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE2VelocityLimit.max_vel)
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::release_max_vel() {
  
  ::rocos::SE2Velocity* temp = max_vel_;
  max_vel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::unsafe_arena_release_max_vel() {
  // @@protoc_insertion_point(field_release:rocos.SE2VelocityLimit.max_vel)
  
  ::rocos::SE2Velocity* temp = max_vel_;
  max_vel_ = nullptr;
  return temp;
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::_internal_mutable_max_vel() {
  
  if (max_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE2Velocity>(GetArenaForAllocation());
    max_vel_ = p;
  }
  return max_vel_;
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::mutable_max_vel() {
  ::rocos::SE2Velocity* _msg = _internal_mutable_max_vel();
  // @@protoc_insertion_point(field_mutable:rocos.SE2VelocityLimit.max_vel)
  return _msg;
}
inline void SE2VelocityLimit::set_allocated_max_vel(::rocos::SE2Velocity* max_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete max_vel_;
  }
  if (max_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::SE2Velocity>::GetOwningArena(max_vel);
    if (message_arena != submessage_arena) {
      max_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_vel, submessage_arena);
    }
    
  } else {
    
  }
  max_vel_ = max_vel;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE2VelocityLimit.max_vel)
}

// .rocos.SE2Velocity min_vel = 2;
inline bool SE2VelocityLimit::_internal_has_min_vel() const {
  return this != internal_default_instance() && min_vel_ != nullptr;
}
inline bool SE2VelocityLimit::has_min_vel() const {
  return _internal_has_min_vel();
}
inline void SE2VelocityLimit::clear_min_vel() {
  if (GetArenaForAllocation() == nullptr && min_vel_ != nullptr) {
    delete min_vel_;
  }
  min_vel_ = nullptr;
}
inline const ::rocos::SE2Velocity& SE2VelocityLimit::_internal_min_vel() const {
  const ::rocos::SE2Velocity* p = min_vel_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE2Velocity&>(
      ::rocos::_SE2Velocity_default_instance_);
}
inline const ::rocos::SE2Velocity& SE2VelocityLimit::min_vel() const {
  // @@protoc_insertion_point(field_get:rocos.SE2VelocityLimit.min_vel)
  return _internal_min_vel();
}
inline void SE2VelocityLimit::unsafe_arena_set_allocated_min_vel(
    ::rocos::SE2Velocity* min_vel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_vel_);
  }
  min_vel_ = min_vel;
  if (min_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE2VelocityLimit.min_vel)
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::release_min_vel() {
  
  ::rocos::SE2Velocity* temp = min_vel_;
  min_vel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::unsafe_arena_release_min_vel() {
  // @@protoc_insertion_point(field_release:rocos.SE2VelocityLimit.min_vel)
  
  ::rocos::SE2Velocity* temp = min_vel_;
  min_vel_ = nullptr;
  return temp;
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::_internal_mutable_min_vel() {
  
  if (min_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE2Velocity>(GetArenaForAllocation());
    min_vel_ = p;
  }
  return min_vel_;
}
inline ::rocos::SE2Velocity* SE2VelocityLimit::mutable_min_vel() {
  ::rocos::SE2Velocity* _msg = _internal_mutable_min_vel();
  // @@protoc_insertion_point(field_mutable:rocos.SE2VelocityLimit.min_vel)
  return _msg;
}
inline void SE2VelocityLimit::set_allocated_min_vel(::rocos::SE2Velocity* min_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete min_vel_;
  }
  if (min_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::SE2Velocity>::GetOwningArena(min_vel);
    if (message_arena != submessage_arena) {
      min_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_vel, submessage_arena);
    }
    
  } else {
    
  }
  min_vel_ = min_vel;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE2VelocityLimit.min_vel)
}

// -------------------------------------------------------------------

// SE3Pose

// .rocos.Vec3 position = 1;
inline bool SE3Pose::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SE3Pose::has_position() const {
  return _internal_has_position();
}
inline void SE3Pose::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::rocos::Vec3& SE3Pose::_internal_position() const {
  const ::rocos::Vec3* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& SE3Pose::position() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Pose.position)
  return _internal_position();
}
inline void SE3Pose::unsafe_arena_set_allocated_position(
    ::rocos::Vec3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE3Pose.position)
}
inline ::rocos::Vec3* SE3Pose::release_position() {
  
  ::rocos::Vec3* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* SE3Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:rocos.SE3Pose.position)
  
  ::rocos::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* SE3Pose::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::rocos::Vec3* SE3Pose::mutable_position() {
  ::rocos::Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:rocos.SE3Pose.position)
  return _msg;
}
inline void SE3Pose::set_allocated_position(::rocos::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE3Pose.position)
}

// .rocos.Quaternion rotation = 2;
inline bool SE3Pose::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool SE3Pose::has_rotation() const {
  return _internal_has_rotation();
}
inline void SE3Pose::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::rocos::Quaternion& SE3Pose::_internal_rotation() const {
  const ::rocos::Quaternion* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Quaternion&>(
      ::rocos::_Quaternion_default_instance_);
}
inline const ::rocos::Quaternion& SE3Pose::rotation() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Pose.rotation)
  return _internal_rotation();
}
inline void SE3Pose::unsafe_arena_set_allocated_rotation(
    ::rocos::Quaternion* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE3Pose.rotation)
}
inline ::rocos::Quaternion* SE3Pose::release_rotation() {
  
  ::rocos::Quaternion* temp = rotation_;
  rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Quaternion* SE3Pose::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:rocos.SE3Pose.rotation)
  
  ::rocos::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::rocos::Quaternion* SE3Pose::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Quaternion>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::rocos::Quaternion* SE3Pose::mutable_rotation() {
  ::rocos::Quaternion* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:rocos.SE3Pose.rotation)
  return _msg;
}
inline void SE3Pose::set_allocated_rotation(::rocos::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Quaternion>::GetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE3Pose.rotation)
}

// -------------------------------------------------------------------

// SE3Velocity

// .rocos.Vec3 linear = 1;
inline bool SE3Velocity::_internal_has_linear() const {
  return this != internal_default_instance() && linear_ != nullptr;
}
inline bool SE3Velocity::has_linear() const {
  return _internal_has_linear();
}
inline void SE3Velocity::clear_linear() {
  if (GetArenaForAllocation() == nullptr && linear_ != nullptr) {
    delete linear_;
  }
  linear_ = nullptr;
}
inline const ::rocos::Vec3& SE3Velocity::_internal_linear() const {
  const ::rocos::Vec3* p = linear_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& SE3Velocity::linear() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Velocity.linear)
  return _internal_linear();
}
inline void SE3Velocity::unsafe_arena_set_allocated_linear(
    ::rocos::Vec3* linear) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_);
  }
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE3Velocity.linear)
}
inline ::rocos::Vec3* SE3Velocity::release_linear() {
  
  ::rocos::Vec3* temp = linear_;
  linear_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* SE3Velocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:rocos.SE3Velocity.linear)
  
  ::rocos::Vec3* temp = linear_;
  linear_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* SE3Velocity::_internal_mutable_linear() {
  
  if (linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    linear_ = p;
  }
  return linear_;
}
inline ::rocos::Vec3* SE3Velocity::mutable_linear() {
  ::rocos::Vec3* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:rocos.SE3Velocity.linear)
  return _msg;
}
inline void SE3Velocity::set_allocated_linear(::rocos::Vec3* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE3Velocity.linear)
}

// .rocos.Vec3 angular = 2;
inline bool SE3Velocity::_internal_has_angular() const {
  return this != internal_default_instance() && angular_ != nullptr;
}
inline bool SE3Velocity::has_angular() const {
  return _internal_has_angular();
}
inline void SE3Velocity::clear_angular() {
  if (GetArenaForAllocation() == nullptr && angular_ != nullptr) {
    delete angular_;
  }
  angular_ = nullptr;
}
inline const ::rocos::Vec3& SE3Velocity::_internal_angular() const {
  const ::rocos::Vec3* p = angular_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& SE3Velocity::angular() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Velocity.angular)
  return _internal_angular();
}
inline void SE3Velocity::unsafe_arena_set_allocated_angular(
    ::rocos::Vec3* angular) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_);
  }
  angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE3Velocity.angular)
}
inline ::rocos::Vec3* SE3Velocity::release_angular() {
  
  ::rocos::Vec3* temp = angular_;
  angular_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* SE3Velocity::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:rocos.SE3Velocity.angular)
  
  ::rocos::Vec3* temp = angular_;
  angular_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* SE3Velocity::_internal_mutable_angular() {
  
  if (angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    angular_ = p;
  }
  return angular_;
}
inline ::rocos::Vec3* SE3Velocity::mutable_angular() {
  ::rocos::Vec3* _msg = _internal_mutable_angular();
  // @@protoc_insertion_point(field_mutable:rocos.SE3Velocity.angular)
  return _msg;
}
inline void SE3Velocity::set_allocated_angular(::rocos::Vec3* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    
  } else {
    
  }
  angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE3Velocity.angular)
}

// -------------------------------------------------------------------

// Wrench

// .rocos.Vec3 force = 1;
inline bool Wrench::_internal_has_force() const {
  return this != internal_default_instance() && force_ != nullptr;
}
inline bool Wrench::has_force() const {
  return _internal_has_force();
}
inline void Wrench::clear_force() {
  if (GetArenaForAllocation() == nullptr && force_ != nullptr) {
    delete force_;
  }
  force_ = nullptr;
}
inline const ::rocos::Vec3& Wrench::_internal_force() const {
  const ::rocos::Vec3* p = force_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Wrench::force() const {
  // @@protoc_insertion_point(field_get:rocos.Wrench.force)
  return _internal_force();
}
inline void Wrench::unsafe_arena_set_allocated_force(
    ::rocos::Vec3* force) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(force_);
  }
  force_ = force;
  if (force) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Wrench.force)
}
inline ::rocos::Vec3* Wrench::release_force() {
  
  ::rocos::Vec3* temp = force_;
  force_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Wrench::unsafe_arena_release_force() {
  // @@protoc_insertion_point(field_release:rocos.Wrench.force)
  
  ::rocos::Vec3* temp = force_;
  force_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Wrench::_internal_mutable_force() {
  
  if (force_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    force_ = p;
  }
  return force_;
}
inline ::rocos::Vec3* Wrench::mutable_force() {
  ::rocos::Vec3* _msg = _internal_mutable_force();
  // @@protoc_insertion_point(field_mutable:rocos.Wrench.force)
  return _msg;
}
inline void Wrench::set_allocated_force(::rocos::Vec3* force) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete force_;
  }
  if (force) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(force);
    if (message_arena != submessage_arena) {
      force = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    
  } else {
    
  }
  force_ = force;
  // @@protoc_insertion_point(field_set_allocated:rocos.Wrench.force)
}

// .rocos.Vec3 torque = 2;
inline bool Wrench::_internal_has_torque() const {
  return this != internal_default_instance() && torque_ != nullptr;
}
inline bool Wrench::has_torque() const {
  return _internal_has_torque();
}
inline void Wrench::clear_torque() {
  if (GetArenaForAllocation() == nullptr && torque_ != nullptr) {
    delete torque_;
  }
  torque_ = nullptr;
}
inline const ::rocos::Vec3& Wrench::_internal_torque() const {
  const ::rocos::Vec3* p = torque_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Wrench::torque() const {
  // @@protoc_insertion_point(field_get:rocos.Wrench.torque)
  return _internal_torque();
}
inline void Wrench::unsafe_arena_set_allocated_torque(
    ::rocos::Vec3* torque) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(torque_);
  }
  torque_ = torque;
  if (torque) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Wrench.torque)
}
inline ::rocos::Vec3* Wrench::release_torque() {
  
  ::rocos::Vec3* temp = torque_;
  torque_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Wrench::unsafe_arena_release_torque() {
  // @@protoc_insertion_point(field_release:rocos.Wrench.torque)
  
  ::rocos::Vec3* temp = torque_;
  torque_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Wrench::_internal_mutable_torque() {
  
  if (torque_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    torque_ = p;
  }
  return torque_;
}
inline ::rocos::Vec3* Wrench::mutable_torque() {
  ::rocos::Vec3* _msg = _internal_mutable_torque();
  // @@protoc_insertion_point(field_mutable:rocos.Wrench.torque)
  return _msg;
}
inline void Wrench::set_allocated_torque(::rocos::Vec3* torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete torque_;
  }
  if (torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(torque);
    if (message_arena != submessage_arena) {
      torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:rocos.Wrench.torque)
}

// -------------------------------------------------------------------

// FrameTreeSnapshot_ParentEdge

// string parent_frame_name = 1;
inline void FrameTreeSnapshot_ParentEdge::clear_parent_frame_name() {
  parent_frame_name_.ClearToEmpty();
}
inline const std::string& FrameTreeSnapshot_ParentEdge::parent_frame_name() const {
  // @@protoc_insertion_point(field_get:rocos.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _internal_parent_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameTreeSnapshot_ParentEdge::set_parent_frame_name(ArgT0&& arg0, ArgT... args) {
 
 parent_frame_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocos.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}
inline std::string* FrameTreeSnapshot_ParentEdge::mutable_parent_frame_name() {
  std::string* _s = _internal_mutable_parent_frame_name();
  // @@protoc_insertion_point(field_mutable:rocos.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _s;
}
inline const std::string& FrameTreeSnapshot_ParentEdge::_internal_parent_frame_name() const {
  return parent_frame_name_.Get();
}
inline void FrameTreeSnapshot_ParentEdge::_internal_set_parent_frame_name(const std::string& value) {
  
  parent_frame_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FrameTreeSnapshot_ParentEdge::_internal_mutable_parent_frame_name() {
  
  return parent_frame_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FrameTreeSnapshot_ParentEdge::release_parent_frame_name() {
  // @@protoc_insertion_point(field_release:rocos.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return parent_frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FrameTreeSnapshot_ParentEdge::set_allocated_parent_frame_name(std::string* parent_frame_name) {
  if (parent_frame_name != nullptr) {
    
  } else {
    
  }
  parent_frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_frame_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rocos.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}

// .rocos.SE3Pose parent_tform_child = 2;
inline bool FrameTreeSnapshot_ParentEdge::_internal_has_parent_tform_child() const {
  return this != internal_default_instance() && parent_tform_child_ != nullptr;
}
inline bool FrameTreeSnapshot_ParentEdge::has_parent_tform_child() const {
  return _internal_has_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::clear_parent_tform_child() {
  if (GetArenaForAllocation() == nullptr && parent_tform_child_ != nullptr) {
    delete parent_tform_child_;
  }
  parent_tform_child_ = nullptr;
}
inline const ::rocos::SE3Pose& FrameTreeSnapshot_ParentEdge::_internal_parent_tform_child() const {
  const ::rocos::SE3Pose* p = parent_tform_child_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& FrameTreeSnapshot_ParentEdge::parent_tform_child() const {
  // @@protoc_insertion_point(field_get:rocos.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  return _internal_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::unsafe_arena_set_allocated_parent_tform_child(
    ::rocos::SE3Pose* parent_tform_child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_tform_child_);
  }
  parent_tform_child_ = parent_tform_child;
  if (parent_tform_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.FrameTreeSnapshot.ParentEdge.parent_tform_child)
}
inline ::rocos::SE3Pose* FrameTreeSnapshot_ParentEdge::release_parent_tform_child() {
  
  ::rocos::SE3Pose* temp = parent_tform_child_;
  parent_tform_child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* FrameTreeSnapshot_ParentEdge::unsafe_arena_release_parent_tform_child() {
  // @@protoc_insertion_point(field_release:rocos.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  
  ::rocos::SE3Pose* temp = parent_tform_child_;
  parent_tform_child_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* FrameTreeSnapshot_ParentEdge::_internal_mutable_parent_tform_child() {
  
  if (parent_tform_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    parent_tform_child_ = p;
  }
  return parent_tform_child_;
}
inline ::rocos::SE3Pose* FrameTreeSnapshot_ParentEdge::mutable_parent_tform_child() {
  ::rocos::SE3Pose* _msg = _internal_mutable_parent_tform_child();
  // @@protoc_insertion_point(field_mutable:rocos.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  return _msg;
}
inline void FrameTreeSnapshot_ParentEdge::set_allocated_parent_tform_child(::rocos::SE3Pose* parent_tform_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete parent_tform_child_;
  }
  if (parent_tform_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::SE3Pose>::GetOwningArena(parent_tform_child);
    if (message_arena != submessage_arena) {
      parent_tform_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_tform_child, submessage_arena);
    }
    
  } else {
    
  }
  parent_tform_child_ = parent_tform_child;
  // @@protoc_insertion_point(field_set_allocated:rocos.FrameTreeSnapshot.ParentEdge.parent_tform_child)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FrameTreeSnapshot

// map<string, .rocos.FrameTreeSnapshot.ParentEdge> child_to_parent_edge_map = 1;
inline int FrameTreeSnapshot::_internal_child_to_parent_edge_map_size() const {
  return child_to_parent_edge_map_.size();
}
inline int FrameTreeSnapshot::child_to_parent_edge_map_size() const {
  return _internal_child_to_parent_edge_map_size();
}
inline void FrameTreeSnapshot::clear_child_to_parent_edge_map() {
  child_to_parent_edge_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >&
FrameTreeSnapshot::_internal_child_to_parent_edge_map() const {
  return child_to_parent_edge_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >&
FrameTreeSnapshot::child_to_parent_edge_map() const {
  // @@protoc_insertion_point(field_map:rocos.FrameTreeSnapshot.child_to_parent_edge_map)
  return _internal_child_to_parent_edge_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >*
FrameTreeSnapshot::_internal_mutable_child_to_parent_edge_map() {
  return child_to_parent_edge_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::rocos::FrameTreeSnapshot_ParentEdge >*
FrameTreeSnapshot::mutable_child_to_parent_edge_map() {
  // @@protoc_insertion_point(field_mutable_map:rocos.FrameTreeSnapshot.child_to_parent_edge_map)
  return _internal_mutable_child_to_parent_edge_map();
}

// -------------------------------------------------------------------

// Box2

// .rocos.Vec2 size = 1;
inline bool Box2::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Box2::has_size() const {
  return _internal_has_size();
}
inline void Box2::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::rocos::Vec2& Box2::_internal_size() const {
  const ::rocos::Vec2* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec2&>(
      ::rocos::_Vec2_default_instance_);
}
inline const ::rocos::Vec2& Box2::size() const {
  // @@protoc_insertion_point(field_get:rocos.Box2.size)
  return _internal_size();
}
inline void Box2::unsafe_arena_set_allocated_size(
    ::rocos::Vec2* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Box2.size)
}
inline ::rocos::Vec2* Box2::release_size() {
  
  ::rocos::Vec2* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec2* Box2::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:rocos.Box2.size)
  
  ::rocos::Vec2* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::rocos::Vec2* Box2::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec2>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::rocos::Vec2* Box2::mutable_size() {
  ::rocos::Vec2* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:rocos.Box2.size)
  return _msg;
}
inline void Box2::set_allocated_size(::rocos::Vec2* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec2>::GetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:rocos.Box2.size)
}

// -------------------------------------------------------------------

// Box2WithFrame

// .rocos.Box2 box = 1;
inline bool Box2WithFrame::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Box2WithFrame::has_box() const {
  return _internal_has_box();
}
inline void Box2WithFrame::clear_box() {
  if (GetArenaForAllocation() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
}
inline const ::rocos::Box2& Box2WithFrame::_internal_box() const {
  const ::rocos::Box2* p = box_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Box2&>(
      ::rocos::_Box2_default_instance_);
}
inline const ::rocos::Box2& Box2WithFrame::box() const {
  // @@protoc_insertion_point(field_get:rocos.Box2WithFrame.box)
  return _internal_box();
}
inline void Box2WithFrame::unsafe_arena_set_allocated_box(
    ::rocos::Box2* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Box2WithFrame.box)
}
inline ::rocos::Box2* Box2WithFrame::release_box() {
  
  ::rocos::Box2* temp = box_;
  box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Box2* Box2WithFrame::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:rocos.Box2WithFrame.box)
  
  ::rocos::Box2* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::rocos::Box2* Box2WithFrame::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Box2>(GetArenaForAllocation());
    box_ = p;
  }
  return box_;
}
inline ::rocos::Box2* Box2WithFrame::mutable_box() {
  ::rocos::Box2* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:rocos.Box2WithFrame.box)
  return _msg;
}
inline void Box2WithFrame::set_allocated_box(::rocos::Box2* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Box2>::GetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:rocos.Box2WithFrame.box)
}

// string frame_name = 2;
inline void Box2WithFrame::clear_frame_name() {
  frame_name_.ClearToEmpty();
}
inline const std::string& Box2WithFrame::frame_name() const {
  // @@protoc_insertion_point(field_get:rocos.Box2WithFrame.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Box2WithFrame::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 frame_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocos.Box2WithFrame.frame_name)
}
inline std::string* Box2WithFrame::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:rocos.Box2WithFrame.frame_name)
  return _s;
}
inline const std::string& Box2WithFrame::_internal_frame_name() const {
  return frame_name_.Get();
}
inline void Box2WithFrame::_internal_set_frame_name(const std::string& value) {
  
  frame_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Box2WithFrame::_internal_mutable_frame_name() {
  
  return frame_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Box2WithFrame::release_frame_name() {
  // @@protoc_insertion_point(field_release:rocos.Box2WithFrame.frame_name)
  return frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Box2WithFrame::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rocos.Box2WithFrame.frame_name)
}

// .rocos.SE3Pose frame_name_tform_box = 3;
inline bool Box2WithFrame::_internal_has_frame_name_tform_box() const {
  return this != internal_default_instance() && frame_name_tform_box_ != nullptr;
}
inline bool Box2WithFrame::has_frame_name_tform_box() const {
  return _internal_has_frame_name_tform_box();
}
inline void Box2WithFrame::clear_frame_name_tform_box() {
  if (GetArenaForAllocation() == nullptr && frame_name_tform_box_ != nullptr) {
    delete frame_name_tform_box_;
  }
  frame_name_tform_box_ = nullptr;
}
inline const ::rocos::SE3Pose& Box2WithFrame::_internal_frame_name_tform_box() const {
  const ::rocos::SE3Pose* p = frame_name_tform_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& Box2WithFrame::frame_name_tform_box() const {
  // @@protoc_insertion_point(field_get:rocos.Box2WithFrame.frame_name_tform_box)
  return _internal_frame_name_tform_box();
}
inline void Box2WithFrame::unsafe_arena_set_allocated_frame_name_tform_box(
    ::rocos::SE3Pose* frame_name_tform_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_name_tform_box_);
  }
  frame_name_tform_box_ = frame_name_tform_box;
  if (frame_name_tform_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Box2WithFrame.frame_name_tform_box)
}
inline ::rocos::SE3Pose* Box2WithFrame::release_frame_name_tform_box() {
  
  ::rocos::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* Box2WithFrame::unsafe_arena_release_frame_name_tform_box() {
  // @@protoc_insertion_point(field_release:rocos.Box2WithFrame.frame_name_tform_box)
  
  ::rocos::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* Box2WithFrame::_internal_mutable_frame_name_tform_box() {
  
  if (frame_name_tform_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    frame_name_tform_box_ = p;
  }
  return frame_name_tform_box_;
}
inline ::rocos::SE3Pose* Box2WithFrame::mutable_frame_name_tform_box() {
  ::rocos::SE3Pose* _msg = _internal_mutable_frame_name_tform_box();
  // @@protoc_insertion_point(field_mutable:rocos.Box2WithFrame.frame_name_tform_box)
  return _msg;
}
inline void Box2WithFrame::set_allocated_frame_name_tform_box(::rocos::SE3Pose* frame_name_tform_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_name_tform_box_;
  }
  if (frame_name_tform_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::SE3Pose>::GetOwningArena(frame_name_tform_box);
    if (message_arena != submessage_arena) {
      frame_name_tform_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_name_tform_box, submessage_arena);
    }
    
  } else {
    
  }
  frame_name_tform_box_ = frame_name_tform_box;
  // @@protoc_insertion_point(field_set_allocated:rocos.Box2WithFrame.frame_name_tform_box)
}

// -------------------------------------------------------------------

// Box3

// .rocos.Vec3 size = 1;
inline bool Box3::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Box3::has_size() const {
  return _internal_has_size();
}
inline void Box3::clear_size() {
  if (GetArenaForAllocation() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::rocos::Vec3& Box3::_internal_size() const {
  const ::rocos::Vec3* p = size_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec3&>(
      ::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Box3::size() const {
  // @@protoc_insertion_point(field_get:rocos.Box3.size)
  return _internal_size();
}
inline void Box3::unsafe_arena_set_allocated_size(
    ::rocos::Vec3* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Box3.size)
}
inline ::rocos::Vec3* Box3::release_size() {
  
  ::rocos::Vec3* temp = size_;
  size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec3* Box3::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:rocos.Box3.size)
  
  ::rocos::Vec3* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::rocos::Vec3* Box3::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec3>(GetArenaForAllocation());
    size_ = p;
  }
  return size_;
}
inline ::rocos::Vec3* Box3::mutable_size() {
  ::rocos::Vec3* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:rocos.Box3.size)
  return _msg;
}
inline void Box3::set_allocated_size(::rocos::Vec3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec3>::GetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:rocos.Box3.size)
}

// -------------------------------------------------------------------

// Box3WithFrame

// .rocos.Box3 box = 1;
inline bool Box3WithFrame::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Box3WithFrame::has_box() const {
  return _internal_has_box();
}
inline void Box3WithFrame::clear_box() {
  if (GetArenaForAllocation() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
}
inline const ::rocos::Box3& Box3WithFrame::_internal_box() const {
  const ::rocos::Box3* p = box_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Box3&>(
      ::rocos::_Box3_default_instance_);
}
inline const ::rocos::Box3& Box3WithFrame::box() const {
  // @@protoc_insertion_point(field_get:rocos.Box3WithFrame.box)
  return _internal_box();
}
inline void Box3WithFrame::unsafe_arena_set_allocated_box(
    ::rocos::Box3* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Box3WithFrame.box)
}
inline ::rocos::Box3* Box3WithFrame::release_box() {
  
  ::rocos::Box3* temp = box_;
  box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Box3* Box3WithFrame::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:rocos.Box3WithFrame.box)
  
  ::rocos::Box3* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::rocos::Box3* Box3WithFrame::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Box3>(GetArenaForAllocation());
    box_ = p;
  }
  return box_;
}
inline ::rocos::Box3* Box3WithFrame::mutable_box() {
  ::rocos::Box3* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:rocos.Box3WithFrame.box)
  return _msg;
}
inline void Box3WithFrame::set_allocated_box(::rocos::Box3* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Box3>::GetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:rocos.Box3WithFrame.box)
}

// string frame_name = 2;
inline void Box3WithFrame::clear_frame_name() {
  frame_name_.ClearToEmpty();
}
inline const std::string& Box3WithFrame::frame_name() const {
  // @@protoc_insertion_point(field_get:rocos.Box3WithFrame.frame_name)
  return _internal_frame_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Box3WithFrame::set_frame_name(ArgT0&& arg0, ArgT... args) {
 
 frame_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rocos.Box3WithFrame.frame_name)
}
inline std::string* Box3WithFrame::mutable_frame_name() {
  std::string* _s = _internal_mutable_frame_name();
  // @@protoc_insertion_point(field_mutable:rocos.Box3WithFrame.frame_name)
  return _s;
}
inline const std::string& Box3WithFrame::_internal_frame_name() const {
  return frame_name_.Get();
}
inline void Box3WithFrame::_internal_set_frame_name(const std::string& value) {
  
  frame_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Box3WithFrame::_internal_mutable_frame_name() {
  
  return frame_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Box3WithFrame::release_frame_name() {
  // @@protoc_insertion_point(field_release:rocos.Box3WithFrame.frame_name)
  return frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Box3WithFrame::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:rocos.Box3WithFrame.frame_name)
}

// .rocos.SE3Pose frame_name_tform_box = 3;
inline bool Box3WithFrame::_internal_has_frame_name_tform_box() const {
  return this != internal_default_instance() && frame_name_tform_box_ != nullptr;
}
inline bool Box3WithFrame::has_frame_name_tform_box() const {
  return _internal_has_frame_name_tform_box();
}
inline void Box3WithFrame::clear_frame_name_tform_box() {
  if (GetArenaForAllocation() == nullptr && frame_name_tform_box_ != nullptr) {
    delete frame_name_tform_box_;
  }
  frame_name_tform_box_ = nullptr;
}
inline const ::rocos::SE3Pose& Box3WithFrame::_internal_frame_name_tform_box() const {
  const ::rocos::SE3Pose* p = frame_name_tform_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::SE3Pose&>(
      ::rocos::_SE3Pose_default_instance_);
}
inline const ::rocos::SE3Pose& Box3WithFrame::frame_name_tform_box() const {
  // @@protoc_insertion_point(field_get:rocos.Box3WithFrame.frame_name_tform_box)
  return _internal_frame_name_tform_box();
}
inline void Box3WithFrame::unsafe_arena_set_allocated_frame_name_tform_box(
    ::rocos::SE3Pose* frame_name_tform_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_name_tform_box_);
  }
  frame_name_tform_box_ = frame_name_tform_box;
  if (frame_name_tform_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Box3WithFrame.frame_name_tform_box)
}
inline ::rocos::SE3Pose* Box3WithFrame::release_frame_name_tform_box() {
  
  ::rocos::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::SE3Pose* Box3WithFrame::unsafe_arena_release_frame_name_tform_box() {
  // @@protoc_insertion_point(field_release:rocos.Box3WithFrame.frame_name_tform_box)
  
  ::rocos::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
  return temp;
}
inline ::rocos::SE3Pose* Box3WithFrame::_internal_mutable_frame_name_tform_box() {
  
  if (frame_name_tform_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::SE3Pose>(GetArenaForAllocation());
    frame_name_tform_box_ = p;
  }
  return frame_name_tform_box_;
}
inline ::rocos::SE3Pose* Box3WithFrame::mutable_frame_name_tform_box() {
  ::rocos::SE3Pose* _msg = _internal_mutable_frame_name_tform_box();
  // @@protoc_insertion_point(field_mutable:rocos.Box3WithFrame.frame_name_tform_box)
  return _msg;
}
inline void Box3WithFrame::set_allocated_frame_name_tform_box(::rocos::SE3Pose* frame_name_tform_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_name_tform_box_;
  }
  if (frame_name_tform_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::SE3Pose>::GetOwningArena(frame_name_tform_box);
    if (message_arena != submessage_arena) {
      frame_name_tform_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_name_tform_box, submessage_arena);
    }
    
  } else {
    
  }
  frame_name_tform_box_ = frame_name_tform_box;
  // @@protoc_insertion_point(field_set_allocated:rocos.Box3WithFrame.frame_name_tform_box)
}

// -------------------------------------------------------------------

// Matrix

// int32 rows = 1;
inline void Matrix::clear_rows() {
  rows_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Matrix::_internal_rows() const {
  return rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Matrix::rows() const {
  // @@protoc_insertion_point(field_get:rocos.Matrix.rows)
  return _internal_rows();
}
inline void Matrix::_internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rows_ = value;
}
inline void Matrix::set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:rocos.Matrix.rows)
}

// int32 cols = 2;
inline void Matrix::clear_cols() {
  cols_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Matrix::_internal_cols() const {
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Matrix::cols() const {
  // @@protoc_insertion_point(field_get:rocos.Matrix.cols)
  return _internal_cols();
}
inline void Matrix::_internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cols_ = value;
}
inline void Matrix::set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:rocos.Matrix.cols)
}

// repeated double values = 3;
inline int Matrix::_internal_values_size() const {
  return values_.size();
}
inline int Matrix::values_size() const {
  return _internal_values_size();
}
inline void Matrix::clear_values() {
  values_.Clear();
}
inline double Matrix::_internal_values(int index) const {
  return values_.Get(index);
}
inline double Matrix::values(int index) const {
  // @@protoc_insertion_point(field_get:rocos.Matrix.values)
  return _internal_values(index);
}
inline void Matrix::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.Matrix.values)
}
inline void Matrix::_internal_add_values(double value) {
  values_.Add(value);
}
inline void Matrix::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:rocos.Matrix.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Matrix::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Matrix::values() const {
  // @@protoc_insertion_point(field_list:rocos.Matrix.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Matrix::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Matrix::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:rocos.Matrix.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// SE3Covariance

// .rocos.Matrix matrix = 1;
inline bool SE3Covariance::_internal_has_matrix() const {
  return this != internal_default_instance() && matrix_ != nullptr;
}
inline bool SE3Covariance::has_matrix() const {
  return _internal_has_matrix();
}
inline void SE3Covariance::clear_matrix() {
  if (GetArenaForAllocation() == nullptr && matrix_ != nullptr) {
    delete matrix_;
  }
  matrix_ = nullptr;
}
inline const ::rocos::Matrix& SE3Covariance::_internal_matrix() const {
  const ::rocos::Matrix* p = matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Matrix&>(
      ::rocos::_Matrix_default_instance_);
}
inline const ::rocos::Matrix& SE3Covariance::matrix() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.matrix)
  return _internal_matrix();
}
inline void SE3Covariance::unsafe_arena_set_allocated_matrix(
    ::rocos::Matrix* matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(matrix_);
  }
  matrix_ = matrix;
  if (matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.SE3Covariance.matrix)
}
inline ::rocos::Matrix* SE3Covariance::release_matrix() {
  
  ::rocos::Matrix* temp = matrix_;
  matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Matrix* SE3Covariance::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_release:rocos.SE3Covariance.matrix)
  
  ::rocos::Matrix* temp = matrix_;
  matrix_ = nullptr;
  return temp;
}
inline ::rocos::Matrix* SE3Covariance::_internal_mutable_matrix() {
  
  if (matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Matrix>(GetArenaForAllocation());
    matrix_ = p;
  }
  return matrix_;
}
inline ::rocos::Matrix* SE3Covariance::mutable_matrix() {
  ::rocos::Matrix* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:rocos.SE3Covariance.matrix)
  return _msg;
}
inline void SE3Covariance::set_allocated_matrix(::rocos::Matrix* matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete matrix_;
  }
  if (matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Matrix>::GetOwningArena(matrix);
    if (message_arena != submessage_arena) {
      matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matrix, submessage_arena);
    }
    
  } else {
    
  }
  matrix_ = matrix;
  // @@protoc_insertion_point(field_set_allocated:rocos.SE3Covariance.matrix)
}

// double yaw_variance = 2 [deprecated = true];
inline void SE3Covariance::clear_yaw_variance() {
  yaw_variance_ = 0;
}
inline double SE3Covariance::_internal_yaw_variance() const {
  return yaw_variance_;
}
inline double SE3Covariance::yaw_variance() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.yaw_variance)
  return _internal_yaw_variance();
}
inline void SE3Covariance::_internal_set_yaw_variance(double value) {
  
  yaw_variance_ = value;
}
inline void SE3Covariance::set_yaw_variance(double value) {
  _internal_set_yaw_variance(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.yaw_variance)
}

// double cov_xx = 3 [deprecated = true];
inline void SE3Covariance::clear_cov_xx() {
  cov_xx_ = 0;
}
inline double SE3Covariance::_internal_cov_xx() const {
  return cov_xx_;
}
inline double SE3Covariance::cov_xx() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_xx)
  return _internal_cov_xx();
}
inline void SE3Covariance::_internal_set_cov_xx(double value) {
  
  cov_xx_ = value;
}
inline void SE3Covariance::set_cov_xx(double value) {
  _internal_set_cov_xx(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_xx)
}

// double cov_xy = 4 [deprecated = true];
inline void SE3Covariance::clear_cov_xy() {
  cov_xy_ = 0;
}
inline double SE3Covariance::_internal_cov_xy() const {
  return cov_xy_;
}
inline double SE3Covariance::cov_xy() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_xy)
  return _internal_cov_xy();
}
inline void SE3Covariance::_internal_set_cov_xy(double value) {
  
  cov_xy_ = value;
}
inline void SE3Covariance::set_cov_xy(double value) {
  _internal_set_cov_xy(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_xy)
}

// double cov_xz = 5 [deprecated = true];
inline void SE3Covariance::clear_cov_xz() {
  cov_xz_ = 0;
}
inline double SE3Covariance::_internal_cov_xz() const {
  return cov_xz_;
}
inline double SE3Covariance::cov_xz() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_xz)
  return _internal_cov_xz();
}
inline void SE3Covariance::_internal_set_cov_xz(double value) {
  
  cov_xz_ = value;
}
inline void SE3Covariance::set_cov_xz(double value) {
  _internal_set_cov_xz(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_xz)
}

// double cov_yx = 6 [deprecated = true];
inline void SE3Covariance::clear_cov_yx() {
  cov_yx_ = 0;
}
inline double SE3Covariance::_internal_cov_yx() const {
  return cov_yx_;
}
inline double SE3Covariance::cov_yx() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_yx)
  return _internal_cov_yx();
}
inline void SE3Covariance::_internal_set_cov_yx(double value) {
  
  cov_yx_ = value;
}
inline void SE3Covariance::set_cov_yx(double value) {
  _internal_set_cov_yx(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_yx)
}

// double cov_yy = 7 [deprecated = true];
inline void SE3Covariance::clear_cov_yy() {
  cov_yy_ = 0;
}
inline double SE3Covariance::_internal_cov_yy() const {
  return cov_yy_;
}
inline double SE3Covariance::cov_yy() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_yy)
  return _internal_cov_yy();
}
inline void SE3Covariance::_internal_set_cov_yy(double value) {
  
  cov_yy_ = value;
}
inline void SE3Covariance::set_cov_yy(double value) {
  _internal_set_cov_yy(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_yy)
}

// double cov_yz = 8 [deprecated = true];
inline void SE3Covariance::clear_cov_yz() {
  cov_yz_ = 0;
}
inline double SE3Covariance::_internal_cov_yz() const {
  return cov_yz_;
}
inline double SE3Covariance::cov_yz() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_yz)
  return _internal_cov_yz();
}
inline void SE3Covariance::_internal_set_cov_yz(double value) {
  
  cov_yz_ = value;
}
inline void SE3Covariance::set_cov_yz(double value) {
  _internal_set_cov_yz(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_yz)
}

// double cov_zx = 9 [deprecated = true];
inline void SE3Covariance::clear_cov_zx() {
  cov_zx_ = 0;
}
inline double SE3Covariance::_internal_cov_zx() const {
  return cov_zx_;
}
inline double SE3Covariance::cov_zx() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_zx)
  return _internal_cov_zx();
}
inline void SE3Covariance::_internal_set_cov_zx(double value) {
  
  cov_zx_ = value;
}
inline void SE3Covariance::set_cov_zx(double value) {
  _internal_set_cov_zx(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_zx)
}

// double cov_zy = 10 [deprecated = true];
inline void SE3Covariance::clear_cov_zy() {
  cov_zy_ = 0;
}
inline double SE3Covariance::_internal_cov_zy() const {
  return cov_zy_;
}
inline double SE3Covariance::cov_zy() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_zy)
  return _internal_cov_zy();
}
inline void SE3Covariance::_internal_set_cov_zy(double value) {
  
  cov_zy_ = value;
}
inline void SE3Covariance::set_cov_zy(double value) {
  _internal_set_cov_zy(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_zy)
}

// double cov_zz = 11 [deprecated = true];
inline void SE3Covariance::clear_cov_zz() {
  cov_zz_ = 0;
}
inline double SE3Covariance::_internal_cov_zz() const {
  return cov_zz_;
}
inline double SE3Covariance::cov_zz() const {
  // @@protoc_insertion_point(field_get:rocos.SE3Covariance.cov_zz)
  return _internal_cov_zz();
}
inline void SE3Covariance::_internal_set_cov_zz(double value) {
  
  cov_zz_ = value;
}
inline void SE3Covariance::set_cov_zz(double value) {
  _internal_set_cov_zz(value);
  // @@protoc_insertion_point(field_set:rocos.SE3Covariance.cov_zz)
}

// -------------------------------------------------------------------

// PolyLine

// repeated .rocos.Vec2 points = 1;
inline int PolyLine::_internal_points_size() const {
  return points_.size();
}
inline int PolyLine::points_size() const {
  return _internal_points_size();
}
inline void PolyLine::clear_points() {
  points_.Clear();
}
inline ::rocos::Vec2* PolyLine::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.PolyLine.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >*
PolyLine::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:rocos.PolyLine.points)
  return &points_;
}
inline const ::rocos::Vec2& PolyLine::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::rocos::Vec2& PolyLine::points(int index) const {
  // @@protoc_insertion_point(field_get:rocos.PolyLine.points)
  return _internal_points(index);
}
inline ::rocos::Vec2* PolyLine::_internal_add_points() {
  return points_.Add();
}
inline ::rocos::Vec2* PolyLine::add_points() {
  ::rocos::Vec2* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:rocos.PolyLine.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >&
PolyLine::points() const {
  // @@protoc_insertion_point(field_list:rocos.PolyLine.points)
  return points_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .rocos.Vec2 vertexes = 1;
inline int Polygon::_internal_vertexes_size() const {
  return vertexes_.size();
}
inline int Polygon::vertexes_size() const {
  return _internal_vertexes_size();
}
inline void Polygon::clear_vertexes() {
  vertexes_.Clear();
}
inline ::rocos::Vec2* Polygon::mutable_vertexes(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.Polygon.vertexes)
  return vertexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >*
Polygon::mutable_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:rocos.Polygon.vertexes)
  return &vertexes_;
}
inline const ::rocos::Vec2& Polygon::_internal_vertexes(int index) const {
  return vertexes_.Get(index);
}
inline const ::rocos::Vec2& Polygon::vertexes(int index) const {
  // @@protoc_insertion_point(field_get:rocos.Polygon.vertexes)
  return _internal_vertexes(index);
}
inline ::rocos::Vec2* Polygon::_internal_add_vertexes() {
  return vertexes_.Add();
}
inline ::rocos::Vec2* Polygon::add_vertexes() {
  ::rocos::Vec2* _add = _internal_add_vertexes();
  // @@protoc_insertion_point(field_add:rocos.Polygon.vertexes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Vec2 >&
Polygon::vertexes() const {
  // @@protoc_insertion_point(field_list:rocos.Polygon.vertexes)
  return vertexes_;
}

// -------------------------------------------------------------------

// PolygonWithExclusions

// .rocos.Polygon inclusion = 5;
inline bool PolygonWithExclusions::_internal_has_inclusion() const {
  return this != internal_default_instance() && inclusion_ != nullptr;
}
inline bool PolygonWithExclusions::has_inclusion() const {
  return _internal_has_inclusion();
}
inline void PolygonWithExclusions::clear_inclusion() {
  if (GetArenaForAllocation() == nullptr && inclusion_ != nullptr) {
    delete inclusion_;
  }
  inclusion_ = nullptr;
}
inline const ::rocos::Polygon& PolygonWithExclusions::_internal_inclusion() const {
  const ::rocos::Polygon* p = inclusion_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Polygon&>(
      ::rocos::_Polygon_default_instance_);
}
inline const ::rocos::Polygon& PolygonWithExclusions::inclusion() const {
  // @@protoc_insertion_point(field_get:rocos.PolygonWithExclusions.inclusion)
  return _internal_inclusion();
}
inline void PolygonWithExclusions::unsafe_arena_set_allocated_inclusion(
    ::rocos::Polygon* inclusion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inclusion_);
  }
  inclusion_ = inclusion;
  if (inclusion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.PolygonWithExclusions.inclusion)
}
inline ::rocos::Polygon* PolygonWithExclusions::release_inclusion() {
  
  ::rocos::Polygon* temp = inclusion_;
  inclusion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Polygon* PolygonWithExclusions::unsafe_arena_release_inclusion() {
  // @@protoc_insertion_point(field_release:rocos.PolygonWithExclusions.inclusion)
  
  ::rocos::Polygon* temp = inclusion_;
  inclusion_ = nullptr;
  return temp;
}
inline ::rocos::Polygon* PolygonWithExclusions::_internal_mutable_inclusion() {
  
  if (inclusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Polygon>(GetArenaForAllocation());
    inclusion_ = p;
  }
  return inclusion_;
}
inline ::rocos::Polygon* PolygonWithExclusions::mutable_inclusion() {
  ::rocos::Polygon* _msg = _internal_mutable_inclusion();
  // @@protoc_insertion_point(field_mutable:rocos.PolygonWithExclusions.inclusion)
  return _msg;
}
inline void PolygonWithExclusions::set_allocated_inclusion(::rocos::Polygon* inclusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inclusion_;
  }
  if (inclusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Polygon>::GetOwningArena(inclusion);
    if (message_arena != submessage_arena) {
      inclusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inclusion, submessage_arena);
    }
    
  } else {
    
  }
  inclusion_ = inclusion;
  // @@protoc_insertion_point(field_set_allocated:rocos.PolygonWithExclusions.inclusion)
}

// repeated .rocos.Polygon exclusions = 6;
inline int PolygonWithExclusions::_internal_exclusions_size() const {
  return exclusions_.size();
}
inline int PolygonWithExclusions::exclusions_size() const {
  return _internal_exclusions_size();
}
inline void PolygonWithExclusions::clear_exclusions() {
  exclusions_.Clear();
}
inline ::rocos::Polygon* PolygonWithExclusions::mutable_exclusions(int index) {
  // @@protoc_insertion_point(field_mutable:rocos.PolygonWithExclusions.exclusions)
  return exclusions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Polygon >*
PolygonWithExclusions::mutable_exclusions() {
  // @@protoc_insertion_point(field_mutable_list:rocos.PolygonWithExclusions.exclusions)
  return &exclusions_;
}
inline const ::rocos::Polygon& PolygonWithExclusions::_internal_exclusions(int index) const {
  return exclusions_.Get(index);
}
inline const ::rocos::Polygon& PolygonWithExclusions::exclusions(int index) const {
  // @@protoc_insertion_point(field_get:rocos.PolygonWithExclusions.exclusions)
  return _internal_exclusions(index);
}
inline ::rocos::Polygon* PolygonWithExclusions::_internal_add_exclusions() {
  return exclusions_.Add();
}
inline ::rocos::Polygon* PolygonWithExclusions::add_exclusions() {
  ::rocos::Polygon* _add = _internal_add_exclusions();
  // @@protoc_insertion_point(field_add:rocos.PolygonWithExclusions.exclusions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rocos::Polygon >&
PolygonWithExclusions::exclusions() const {
  // @@protoc_insertion_point(field_list:rocos.PolygonWithExclusions.exclusions)
  return exclusions_;
}

// -------------------------------------------------------------------

// Circle

// .rocos.Vec2 center_pt = 1;
inline bool Circle::_internal_has_center_pt() const {
  return this != internal_default_instance() && center_pt_ != nullptr;
}
inline bool Circle::has_center_pt() const {
  return _internal_has_center_pt();
}
inline void Circle::clear_center_pt() {
  if (GetArenaForAllocation() == nullptr && center_pt_ != nullptr) {
    delete center_pt_;
  }
  center_pt_ = nullptr;
}
inline const ::rocos::Vec2& Circle::_internal_center_pt() const {
  const ::rocos::Vec2* p = center_pt_;
  return p != nullptr ? *p : reinterpret_cast<const ::rocos::Vec2&>(
      ::rocos::_Vec2_default_instance_);
}
inline const ::rocos::Vec2& Circle::center_pt() const {
  // @@protoc_insertion_point(field_get:rocos.Circle.center_pt)
  return _internal_center_pt();
}
inline void Circle::unsafe_arena_set_allocated_center_pt(
    ::rocos::Vec2* center_pt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_pt_);
  }
  center_pt_ = center_pt;
  if (center_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Circle.center_pt)
}
inline ::rocos::Vec2* Circle::release_center_pt() {
  
  ::rocos::Vec2* temp = center_pt_;
  center_pt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rocos::Vec2* Circle::unsafe_arena_release_center_pt() {
  // @@protoc_insertion_point(field_release:rocos.Circle.center_pt)
  
  ::rocos::Vec2* temp = center_pt_;
  center_pt_ = nullptr;
  return temp;
}
inline ::rocos::Vec2* Circle::_internal_mutable_center_pt() {
  
  if (center_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::rocos::Vec2>(GetArenaForAllocation());
    center_pt_ = p;
  }
  return center_pt_;
}
inline ::rocos::Vec2* Circle::mutable_center_pt() {
  ::rocos::Vec2* _msg = _internal_mutable_center_pt();
  // @@protoc_insertion_point(field_mutable:rocos.Circle.center_pt)
  return _msg;
}
inline void Circle::set_allocated_center_pt(::rocos::Vec2* center_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_pt_;
  }
  if (center_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rocos::Vec2>::GetOwningArena(center_pt);
    if (message_arena != submessage_arena) {
      center_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_pt, submessage_arena);
    }
    
  } else {
    
  }
  center_pt_ = center_pt;
  // @@protoc_insertion_point(field_set_allocated:rocos.Circle.center_pt)
}

// double radius = 2;
inline void Circle::clear_radius() {
  radius_ = 0;
}
inline double Circle::_internal_radius() const {
  return radius_;
}
inline double Circle::radius() const {
  // @@protoc_insertion_point(field_get:rocos.Circle.radius)
  return _internal_radius();
}
inline void Circle::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void Circle::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:rocos.Circle.radius)
}

// -------------------------------------------------------------------

// Area

// .rocos.Polygon polygon = 1;
inline bool Area::_internal_has_polygon() const {
  return geometry_case() == kPolygon;
}
inline bool Area::has_polygon() const {
  return _internal_has_polygon();
}
inline void Area::set_has_polygon() {
  _oneof_case_[0] = kPolygon;
}
inline void Area::clear_polygon() {
  if (_internal_has_polygon()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.polygon_;
    }
    clear_has_geometry();
  }
}
inline ::rocos::Polygon* Area::release_polygon() {
  // @@protoc_insertion_point(field_release:rocos.Area.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
      ::rocos::Polygon* temp = geometry_.polygon_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::Polygon& Area::_internal_polygon() const {
  return _internal_has_polygon()
      ? *geometry_.polygon_
      : reinterpret_cast< ::rocos::Polygon&>(::rocos::_Polygon_default_instance_);
}
inline const ::rocos::Polygon& Area::polygon() const {
  // @@protoc_insertion_point(field_get:rocos.Area.polygon)
  return _internal_polygon();
}
inline ::rocos::Polygon* Area::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.Area.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
    ::rocos::Polygon* temp = geometry_.polygon_;
    geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Area::unsafe_arena_set_allocated_polygon(::rocos::Polygon* polygon) {
  clear_geometry();
  if (polygon) {
    set_has_polygon();
    geometry_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Area.polygon)
}
inline ::rocos::Polygon* Area::_internal_mutable_polygon() {
  if (!_internal_has_polygon()) {
    clear_geometry();
    set_has_polygon();
    geometry_.polygon_ = CreateMaybeMessage< ::rocos::Polygon >(GetArenaForAllocation());
  }
  return geometry_.polygon_;
}
inline ::rocos::Polygon* Area::mutable_polygon() {
  ::rocos::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:rocos.Area.polygon)
  return _msg;
}

// .rocos.Circle circle = 2;
inline bool Area::_internal_has_circle() const {
  return geometry_case() == kCircle;
}
inline bool Area::has_circle() const {
  return _internal_has_circle();
}
inline void Area::set_has_circle() {
  _oneof_case_[0] = kCircle;
}
inline void Area::clear_circle() {
  if (_internal_has_circle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.circle_;
    }
    clear_has_geometry();
  }
}
inline ::rocos::Circle* Area::release_circle() {
  // @@protoc_insertion_point(field_release:rocos.Area.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
      ::rocos::Circle* temp = geometry_.circle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::Circle& Area::_internal_circle() const {
  return _internal_has_circle()
      ? *geometry_.circle_
      : reinterpret_cast< ::rocos::Circle&>(::rocos::_Circle_default_instance_);
}
inline const ::rocos::Circle& Area::circle() const {
  // @@protoc_insertion_point(field_get:rocos.Area.circle)
  return _internal_circle();
}
inline ::rocos::Circle* Area::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.Area.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
    ::rocos::Circle* temp = geometry_.circle_;
    geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Area::unsafe_arena_set_allocated_circle(::rocos::Circle* circle) {
  clear_geometry();
  if (circle) {
    set_has_circle();
    geometry_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Area.circle)
}
inline ::rocos::Circle* Area::_internal_mutable_circle() {
  if (!_internal_has_circle()) {
    clear_geometry();
    set_has_circle();
    geometry_.circle_ = CreateMaybeMessage< ::rocos::Circle >(GetArenaForAllocation());
  }
  return geometry_.circle_;
}
inline ::rocos::Circle* Area::mutable_circle() {
  ::rocos::Circle* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:rocos.Area.circle)
  return _msg;
}

inline bool Area::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Area::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Area::GeometryCase Area::geometry_case() const {
  return Area::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Volume

// .rocos.Vec3 box = 1;
inline bool Volume::_internal_has_box() const {
  return geometry_case() == kBox;
}
inline bool Volume::has_box() const {
  return _internal_has_box();
}
inline void Volume::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void Volume::clear_box() {
  if (_internal_has_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete geometry_.box_;
    }
    clear_has_geometry();
  }
}
inline ::rocos::Vec3* Volume::release_box() {
  // @@protoc_insertion_point(field_release:rocos.Volume.box)
  if (_internal_has_box()) {
    clear_has_geometry();
      ::rocos::Vec3* temp = geometry_.box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::rocos::Vec3& Volume::_internal_box() const {
  return _internal_has_box()
      ? *geometry_.box_
      : reinterpret_cast< ::rocos::Vec3&>(::rocos::_Vec3_default_instance_);
}
inline const ::rocos::Vec3& Volume::box() const {
  // @@protoc_insertion_point(field_get:rocos.Volume.box)
  return _internal_box();
}
inline ::rocos::Vec3* Volume::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rocos.Volume.box)
  if (_internal_has_box()) {
    clear_has_geometry();
    ::rocos::Vec3* temp = geometry_.box_;
    geometry_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Volume::unsafe_arena_set_allocated_box(::rocos::Vec3* box) {
  clear_geometry();
  if (box) {
    set_has_box();
    geometry_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Volume.box)
}
inline ::rocos::Vec3* Volume::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_geometry();
    set_has_box();
    geometry_.box_ = CreateMaybeMessage< ::rocos::Vec3 >(GetArenaForAllocation());
  }
  return geometry_.box_;
}
inline ::rocos::Vec3* Volume::mutable_box() {
  ::rocos::Vec3* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:rocos.Volume.box)
  return _msg;
}

inline bool Volume::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Volume::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Volume::GeometryCase Volume::geometry_case() const {
  return Volume::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Bounds

// double lower = 1;
inline void Bounds::clear_lower() {
  lower_ = 0;
}
inline double Bounds::_internal_lower() const {
  return lower_;
}
inline double Bounds::lower() const {
  // @@protoc_insertion_point(field_get:rocos.Bounds.lower)
  return _internal_lower();
}
inline void Bounds::_internal_set_lower(double value) {
  
  lower_ = value;
}
inline void Bounds::set_lower(double value) {
  _internal_set_lower(value);
  // @@protoc_insertion_point(field_set:rocos.Bounds.lower)
}

// double upper = 2;
inline void Bounds::clear_upper() {
  upper_ = 0;
}
inline double Bounds::_internal_upper() const {
  return upper_;
}
inline double Bounds::upper() const {
  // @@protoc_insertion_point(field_get:rocos.Bounds.upper)
  return _internal_upper();
}
inline void Bounds::_internal_set_upper(double value) {
  
  upper_ = value;
}
inline void Bounds::set_upper(double value) {
  _internal_set_upper(value);
  // @@protoc_insertion_point(field_set:rocos.Bounds.upper)
}

// -------------------------------------------------------------------

// Vec2Value

// .google.protobuf.DoubleValue x = 1;
inline bool Vec2Value::_internal_has_x() const {
  return this != internal_default_instance() && x_ != nullptr;
}
inline bool Vec2Value::has_x() const {
  return _internal_has_x();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::_internal_x() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = x_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::x() const {
  // @@protoc_insertion_point(field_get:rocos.Vec2Value.x)
  return _internal_x();
}
inline void Vec2Value::unsafe_arena_set_allocated_x(
    PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Vec2Value.x)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::release_x() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:rocos.Vec2Value.x)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::_internal_mutable_x() {
  
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    x_ = p;
  }
  return x_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::mutable_x() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:rocos.Vec2Value.x)
  return _msg;
}
inline void Vec2Value::set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x));
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:rocos.Vec2Value.x)
}

// .google.protobuf.DoubleValue y = 2;
inline bool Vec2Value::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool Vec2Value::has_y() const {
  return _internal_has_y();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::_internal_y() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = y_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::y() const {
  // @@protoc_insertion_point(field_get:rocos.Vec2Value.y)
  return _internal_y();
}
inline void Vec2Value::unsafe_arena_set_allocated_y(
    PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Vec2Value.y)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::release_y() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:rocos.Vec2Value.y)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    y_ = p;
  }
  return y_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::mutable_y() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:rocos.Vec2Value.y)
  return _msg;
}
inline void Vec2Value::set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y));
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:rocos.Vec2Value.y)
}

// -------------------------------------------------------------------

// Vec3Value

// .google.protobuf.DoubleValue x = 1;
inline bool Vec3Value::_internal_has_x() const {
  return this != internal_default_instance() && x_ != nullptr;
}
inline bool Vec3Value::has_x() const {
  return _internal_has_x();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_x() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = x_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::x() const {
  // @@protoc_insertion_point(field_get:rocos.Vec3Value.x)
  return _internal_x();
}
inline void Vec3Value::unsafe_arena_set_allocated_x(
    PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Vec3Value.x)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_x() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:rocos.Vec3Value.x)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_x() {
  
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    x_ = p;
  }
  return x_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_x() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:rocos.Vec3Value.x)
  return _msg;
}
inline void Vec3Value::set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x));
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:rocos.Vec3Value.x)
}

// .google.protobuf.DoubleValue y = 2;
inline bool Vec3Value::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool Vec3Value::has_y() const {
  return _internal_has_y();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_y() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = y_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::y() const {
  // @@protoc_insertion_point(field_get:rocos.Vec3Value.y)
  return _internal_y();
}
inline void Vec3Value::unsafe_arena_set_allocated_y(
    PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Vec3Value.y)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_y() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:rocos.Vec3Value.y)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    y_ = p;
  }
  return y_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_y() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:rocos.Vec3Value.y)
  return _msg;
}
inline void Vec3Value::set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y));
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:rocos.Vec3Value.y)
}

// .google.protobuf.DoubleValue z = 3;
inline bool Vec3Value::_internal_has_z() const {
  return this != internal_default_instance() && z_ != nullptr;
}
inline bool Vec3Value::has_z() const {
  return _internal_has_z();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_z() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = z_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::z() const {
  // @@protoc_insertion_point(field_get:rocos.Vec3Value.z)
  return _internal_z();
}
inline void Vec3Value::unsafe_arena_set_allocated_z(
    PROTOBUF_NAMESPACE_ID::DoubleValue* z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  z_ = z;
  if (z) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rocos.Vec3Value.z)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_z() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = z_;
  z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:rocos.Vec3Value.z)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = z_;
  z_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_z() {
  
  if (z_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    z_ = p;
  }
  return z_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_z() {
  PROTOBUF_NAMESPACE_ID::DoubleValue* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:rocos.Vec3Value.z)
  return _msg;
}
inline void Vec3Value::set_allocated_z(PROTOBUF_NAMESPACE_ID::DoubleValue* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z));
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:rocos.Vec3Value.z)
}

// -------------------------------------------------------------------

// JointArray

// repeated double data = 1;
inline int JointArray::_internal_data_size() const {
  return data_.size();
}
inline int JointArray::data_size() const {
  return _internal_data_size();
}
inline void JointArray::clear_data() {
  data_.Clear();
}
inline double JointArray::_internal_data(int index) const {
  return data_.Get(index);
}
inline double JointArray::data(int index) const {
  // @@protoc_insertion_point(field_get:rocos.JointArray.data)
  return _internal_data(index);
}
inline void JointArray::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:rocos.JointArray.data)
}
inline void JointArray::_internal_add_data(double value) {
  data_.Add(value);
}
inline void JointArray::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:rocos.JointArray.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JointArray::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
JointArray::data() const {
  // @@protoc_insertion_point(field_list:rocos.JointArray.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JointArray::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
JointArray::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:rocos.JointArray.data)
  return _internal_mutable_data();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rocos

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_geometry_2eproto
